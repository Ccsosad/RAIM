diff --git a/astropy/table/operations.py b/astropy/table/operations.py
index 0d1d769..20c3b12 100644
--- a/astropy/table/operations.py
+++ b/astropy/table/operations.py
@@ -801,28 +801,36 @@ def _join(left, right, keys=None, join_type='inner',
     # Store user-provided col_name_map until the end
     _col_name_map = col_name_map
 
-    if join_type not in ('inner', 'outer', 'left', 'right'):
+    if join_type not in ('inner', 'outer', 'left', 'right', 'cartesian'):
         raise ValueError("The 'join_type' argument should be in 'inner', "
-                         "'outer', 'left' or 'right' (got '{}' instead)".
+                         "'outer', 'left', 'right' or 'cartesian' (got '{}' instead)".
                          format(join_type))
 
-    # If we have a single key, put it in a tuple
-    if keys is None:
-        keys = tuple(name for name in left.colnames if name in right.colnames)
-        if len(keys) == 0:
-            raise TableMergeError('No keys in common between left and right tables')
-    elif isinstance(keys, str):
-        keys = (keys,)
-
-    # Check the key columns
-    for arr, arr_label in ((left, 'Left'), (right, 'Right')):
-        for name in keys:
-            if name not in arr.colnames:
-                raise TableMergeError('{} table does not have key column {!r}'
-                                      .format(arr_label, name))
-            if hasattr(arr[name], 'mask') and np.any(arr[name].mask):
-                raise TableMergeError('{} key column {!r} has missing values'
-                                      .format(arr_label, name))
+    # For cartesian join, keys must not be specified
+    if join_type == 'cartesian':
+        if keys is not None:
+            raise ValueError("cannot supply keys for a cartesian join")
+        # Use empty keys tuple for cartesian
+        keys = ()
+    else:
+        # If we have a single key, put it in a tuple
+        if keys is None:
+            keys = tuple(name for name in left.colnames if name in right.colnames)
+            if len(keys) == 0:
+                raise TableMergeError('No keys in common between left and right tables')
+        elif isinstance(keys, str):
+            keys = (keys,)
+
+    # Check the key columns (skip for cartesian join)
+    if join_type != 'cartesian':
+        for arr, arr_label in ((left, 'Left'), (right, 'Right')):
+            for name in keys:
+                if name not in arr.colnames:
+                    raise TableMergeError('{} table does not have key column {!r}'
+                                          .format(arr_label, name))
+                if hasattr(arr[name], 'mask') and np.any(arr[name].mask):
+                    raise TableMergeError('{} key column {!r} has missing values'
+                                          .format(arr_label, name))
 
     len_left, len_right = len(left), len(right)
 
@@ -833,16 +841,28 @@ def _join(left, right, keys=None, join_type='inner',
     col_name_map = get_col_name_map([left, right], keys, uniq_col_name, table_names)
     out_descrs = get_descrs([left, right], col_name_map)
 
-    try:
-        idxs, idx_sort = _get_join_sort_idxs(keys, left, right)
-    except NotImplementedError:
-        raise TypeError('one or more key columns are not sortable')
+    if join_type == 'cartesian':
+        # For cartesian join, we need to generate all combinations
+        # left_out = [0,0,0,1,1,1,...] for len_left=3, len_right=3
+        # right_out = [0,1,2,0,1,2,...]
+        n_out = len_left * len_right
+        left_out = np.repeat(np.arange(len_left), len_right)
+        right_out = np.tile(np.arange(len_right), len_left)
+        # For cartesian join, all rows are present from both tables
+        left_mask = np.zeros(n_out, dtype=bool)
+        right_mask = np.zeros(n_out, dtype=bool)
+        masked = False
+    else:
+        try:
+            idxs, idx_sort = _get_join_sort_idxs(keys, left, right)
+        except NotImplementedError:
+            raise TypeError('one or more key columns are not sortable')
 
-    # Main inner loop in Cython to compute the cartesian product
-    # indices for the given join type
-    int_join_type = {'inner': 0, 'outer': 1, 'left': 2, 'right': 3}[join_type]
-    masked, n_out, left_out, left_mask, right_out, right_mask = \
-        _np_utils.join_inner(idxs, idx_sort, len_left, int_join_type)
+        # Main inner loop in Cython to compute the cartesian product
+        # indices for the given join type
+        int_join_type = {'inner': 0, 'outer': 1, 'left': 2, 'right': 3}[join_type]
+        masked, n_out, left_out, left_mask, right_out, right_mask = \
+            _np_utils.join_inner(idxs, idx_sort, len_left, int_join_type)
 
     out = _get_out_class([left, right])()
 
@@ -850,6 +870,8 @@ def _join(left, right, keys=None, join_type='inner',
 
         left_name, right_name = col_name_map[out_name]
         if left_name and right_name:  # this is a key which comes from left and right
+            # For cartesian join, keys are empty, so this shouldn't happen
+            # But handle it generically
             cols = [left[left_name], right[right_name]]
 
             col_cls = _get_out_class(cols)
@@ -859,18 +881,27 @@ def _join(left, right, keys=None, join_type='inner',
 
             out[out_name] = col_cls.info.new_like(cols, n_out, metadata_conflicts, out_name)
 
-            if not NUMPY_LT_1_17 or issubclass(col_cls, (Column, Time)):
-                out[out_name][:] = np.where(right_mask,
-                                            left[left_name].take(left_out),
-                                            right[right_name].take(right_out))
+            if join_type == 'cartesian':
+                # For cartesian join, we need to handle columns from both tables
+                # that have the same name. The output column should have values
+                # from the left table repeated and right table tiled appropriately.
+                # Actually, for cartesian join with same column name in both tables,
+                # we should have already renamed them with suffixes. So this case
+                # shouldn't occur. But if it does, we'll use left table values.
+                out[out_name][:] = left[left_name].take(left_out)
             else:
-                # np.where does not work for mixin columns (e.g. Quantity) so
-                # use a slower workaround.
-                non_right_mask = ~right_mask
-                if np.any(right_mask):
-                    out[out_name][:] = left[left_name].take(left_out)
-                if np.any(non_right_mask):
-                    out[out_name][non_right_mask] = right[right_name].take(right_out)[non_right_mask]
+                if not NUMPY_LT_1_17 or issubclass(col_cls, (Column, Time)):
+                    out[out_name][:] = np.where(right_mask,
+                                                left[left_name].take(left_out),
+                                                right[right_name].take(right_out))
+                else:
+                    # np.where does not work for mixin columns (e.g. Quantity) so
+                    # use a slower workaround.
+                    non_right_mask = ~right_mask
+                    if np.any(right_mask):
+                        out[out_name][:] = left[left_name].take(left_out)
+                    if np.any(non_right_mask):
+                        out[out_name][non_right_mask] = right[right_name].take(right_out)[non_right_mask]
             continue
         elif left_name:  # out_name came from the left table
             name, array, array_out, array_mask = left_name, left, left_out, left_mask
