diff --git a/sklearn/multioutput.py b/sklearn/multioutput.py
index 50d6d32..58a6b87 100644
--- a/sklearn/multioutput.py
+++ b/sklearn/multioutput.py
@@ -32,12 +32,14 @@ __all__ = ["MultiOutputRegressor", "MultiOutputClassifier",
            "ClassifierChain", "RegressorChain"]
 
 
-def _fit_estimator(estimator, X, y, sample_weight=None):
+def _fit_estimator(estimator, X, y, sample_weight=None, fit_params=None):
     estimator = clone(estimator)
+    if fit_params is None:
+        fit_params = {}
     if sample_weight is not None:
-        estimator.fit(X, y, sample_weight=sample_weight)
+        estimator.fit(X, y, sample_weight=sample_weight, **fit_params)
     else:
-        estimator.fit(X, y)
+        estimator.fit(X, y, **fit_params)
     return estimator
 
 
@@ -121,7 +123,7 @@ class _MultiOutputEstimator(BaseEstimator, MetaEstimatorMixin,
                 sample_weight, first_time) for i in range(y.shape[1]))
         return self
 
-    def fit(self, X, y, sample_weight=None):
+    def fit(self, X, y, sample_weight=None, fit_params=None):
         """ Fit the model to data.
         Fit a separate model for each output variable.
 
@@ -139,6 +141,10 @@ class _MultiOutputEstimator(BaseEstimator, MetaEstimatorMixin,
             Only supported if the underlying regressor supports sample
             weights.
 
+        fit_params : dict, default=None
+            Additional fit parameters to pass to the underlying estimator's
+            fit method for each output.
+
         Returns
         -------
         self : object
@@ -164,9 +170,12 @@ class _MultiOutputEstimator(BaseEstimator, MetaEstimatorMixin,
             raise ValueError("Underlying estimator does not support"
                              " sample weights.")
 
+        if fit_params is None:
+            fit_params = {}
+
         self.estimators_ = Parallel(n_jobs=self.n_jobs)(
             delayed(_fit_estimator)(
-                self.estimator, X, y[:, i], sample_weight)
+                self.estimator, X, y[:, i], sample_weight, fit_params)
             for i in range(y.shape[1]))
         return self
 
@@ -338,7 +347,7 @@ class MultiOutputClassifier(ClassifierMixin, _MultiOutputEstimator):
     def __init__(self, estimator, n_jobs=None):
         super().__init__(estimator, n_jobs)
 
-    def fit(self, X, Y, sample_weight=None):
+    def fit(self, X, Y, sample_weight=None, **fit_params):
         """Fit the model to data matrix X and targets Y.
 
         Parameters
@@ -351,12 +360,15 @@ class MultiOutputClassifier(ClassifierMixin, _MultiOutputEstimator):
             Sample weights. If None, then samples are equally weighted.
             Only supported if the underlying classifier supports sample
             weights.
+        **fit_params : dict of string -> object
+            Additional fit parameters to pass to the underlying estimator's
+            fit method for each output.
 
         Returns
         -------
         self : object
         """
-        super().fit(X, Y, sample_weight)
+        super().fit(X, Y, sample_weight=sample_weight, fit_params=fit_params)
         self.classes_ = [estimator.classes_ for estimator in self.estimators_]
         return self
 
