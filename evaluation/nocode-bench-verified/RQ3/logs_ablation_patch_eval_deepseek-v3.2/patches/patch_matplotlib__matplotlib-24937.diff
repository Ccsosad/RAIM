diff --git a/lib/matplotlib/axes/_axes.py b/lib/matplotlib/axes/_axes.py
index 44120b5..6357fd7 100644
--- a/lib/matplotlib/axes/_axes.py
+++ b/lib/matplotlib/axes/_axes.py
@@ -3075,7 +3075,7 @@ class Axes(_AxesBase):
             autopct=None, pctdistance=0.6, shadow=False, labeldistance=1.1,
             startangle=0, radius=1, counterclock=True,
             wedgeprops=None, textprops=None, center=(0, 0),
-            frame=False, rotatelabels=False, *, normalize=True):
+            frame=False, rotatelabels=False, *, normalize=True, hatch=None):
         """
         Plot a pie chart.
 
@@ -3101,6 +3101,13 @@ class Axes(_AxesBase):
             A sequence of colors through which the pie chart will cycle.  If
             *None*, will use the colors in the currently active cycle.
 
+        hatch : str or list, default: None
+            A hatch pattern or a list of hatch patterns to be applied to the
+            wedges. If a list, its length must be equal to the number of wedges.
+            If a single string, the same hatching is applied to all wedges.
+            Hatching is only supported if the wedge does not have a fillstyle
+            of 'none'. See also :doc:`/gallery/shapes_and_collections/hatch_style_reference`.
+
         autopct : None or str or callable, default: None
             If not *None*, is a string or function used to label the wedges
             with their numeric value.  The label will be placed inside the
@@ -3207,6 +3214,16 @@ class Axes(_AxesBase):
             def get_next_color():
                 return next(color_cycle)
 
+        # Process hatch: if None, create a list of None; if a string, repeat it;
+        # if a list, use it as is, but cycle if too short.
+        if hatch is None:
+            hatches = [None] * len(x)
+        elif isinstance(hatch, str):
+            hatches = [hatch] * len(x)
+        else:
+            # assume it's a list or iterable
+            hatches = list(itertools.islice(itertools.cycle(hatch), len(x)))
+
         _api.check_isinstance(Number, radius=radius, startangle=startangle)
         if radius <= 0:
             raise ValueError(f'radius must be a positive number, not {radius}')
@@ -3223,7 +3240,7 @@ class Axes(_AxesBase):
         slices = []
         autotexts = []
 
-        for frac, label, expl in zip(x, labels, explode):
+        for frac, label, expl, hatch_pattern in zip(x, labels, explode, hatches):
             x, y = center
             theta2 = (theta1 + frac) if counterclock else (theta1 - frac)
             thetam = 2 * np.pi * 0.5 * (theta1 + theta2)
@@ -3234,7 +3251,8 @@ class Axes(_AxesBase):
                                360. * max(theta1, theta2),
                                facecolor=get_next_color(),
                                clip_on=False,
-                               label=label)
+                               label=label,
+                               hatch=hatch_pattern)
             w.set(**wedgeprops)
             slices.append(w)
             self.add_patch(w)
@@ -8280,4 +8298,4 @@ such objects
         figure_size = self.get_figure().get_size_inches()
         ll, ur = self.get_position() * figure_size
         width, height = ur - ll
-        return height / (width * self.get_data_ratio())
+        return height / (width * self.get_data_ratio())
