diff --git a/seaborn/categorical.py b/seaborn/categorical.py
index 8858341..1169b67 100644
--- a/seaborn/categorical.py
+++ b/seaborn/categorical.py
@@ -1575,14 +1575,14 @@ class _BarPlotter(_CategoricalStatPlotter):
     """Show point estimates and confidence intervals with bars."""
 
     def __init__(self, x, y, hue, data, order, hue_order,
-                 estimator, ci, n_boot, units, seed,
+                 estimator, errorbar, n_boot, units, seed,
                  orient, color, palette, saturation, width,
                  errcolor, errwidth, capsize, dodge):
         """Initialize the plotter."""
         self.establish_variables(x, y, hue, data, orient,
                                  order, hue_order, units)
         self.establish_colors(color, palette, saturation)
-        self.estimate_statistic(estimator, ci, n_boot, seed)
+        self.estimate_statistic(estimator, errorbar, n_boot, seed)
 
         self.dodge = dodge
         self.width = width
@@ -1647,14 +1647,14 @@ class _PointPlotter(_CategoricalStatPlotter):
 
     """Show point estimates and confidence intervals with (joined) points."""
     def __init__(self, x, y, hue, data, order, hue_order,
-                 estimator, ci, n_boot, units, seed,
+                 estimator, errorbar, n_boot, units, seed,
                  markers, linestyles, dodge, join, scale,
                  orient, color, palette, errwidth=None, capsize=None):
         """Initialize the plotter."""
         self.establish_variables(x, y, hue, data, orient,
                                  order, hue_order, units)
         self.establish_colors(color, palette, 1)
-        self.estimate_statistic(estimator, ci, n_boot, seed)
+        self.estimate_statistic(estimator, errorbar, n_boot, seed)
 
         # Override the default palette for single-color plots
         if hue is None and color is None and palette is None:
diff --git a/seaborn/errorbars.py b/seaborn/errorbars.py
new file mode 100644
index 0000000..214d2d9
--- /dev/null
+++ b/seaborn/errorbars.py
@@ -0,0 +1,145 @@
+"""
+Functions for computing error bars from data.
+"""
+import numpy as np
+import pandas as pd
+from scipy import stats
+from seaborn.utils import bootstrap
+
+
+def _get_errorbars(x, estimator, errorbar, n_boot, seed):
+    """
+    Compute point estimate and error bar limits from data.
+
+    Parameters
+    ----------
+    x : array
+        Input data.
+    estimator : callable or string
+        Function to compute point estimate.
+    errorbar : string, (string, number) tuple, or callable
+        Specification for error bars.
+    n_boot : int
+        Number of bootstrap samples.
+    seed : int
+        Random seed for bootstrap.
+
+    Returns
+    -------
+    point : float
+        Point estimate.
+    err_low : float
+        Lower error bar limit.
+    err_high : float
+        Upper error bar limit.
+    """
+    # Handle string estimators
+    if isinstance(estimator, str):
+        if estimator == "mean":
+            estimator = np.mean
+        elif estimator == "median":
+            estimator = np.median
+        else:
+            raise ValueError(f"Estimator '{estimator}' not recognized.")
+
+    # Compute point estimate
+    point = estimator(x)
+
+    # Parse errorbar specification
+    if errorbar is None:
+        return point, np.nan, np.nan
+
+    if callable(errorbar):
+        # User-provided function
+        err_low, err_high = errorbar(x)
+        return point, err_low, err_high
+
+    # Default is 95% confidence interval
+    if errorbar == "ci":
+        errorbar = ("ci", 95)
+
+    if isinstance(errorbar, tuple):
+        method, amount = errorbar
+    else:
+        method, amount = errorbar, None
+
+    if method == "sd":
+        # Standard deviation
+        std = np.std(x, ddof=1)
+        if amount is None:
+            amount = 1
+        err = std * amount
+        return point, point - err, point + err
+
+    elif method == "se":
+        # Standard error
+        se = stats.sem(x)
+        if amount is None:
+            amount = 1
+        err = se * amount
+        return point, point - err, point + err
+
+    elif method == "pi":
+        # Percentile interval
+        if amount is None:
+            amount = 95
+        low = (100 - amount) / 2
+        high = 100 - low
+        err_low, err_high = np.percentile(x, [low, high])
+        return point, err_low, err_high
+
+    elif method == "ci":
+        # Bootstrap confidence interval
+        if amount is None:
+            amount = 95
+        boot_data = bootstrap(x, n_boot=n_boot, seed=seed)
+        boot_est = [estimator(b) for b in boot_data]
+        low = (100 - amount) / 2
+        high = 100 - low
+        err_low, err_high = np.percentile(boot_est, [low, high])
+        return point, err_low, err_high
+
+    else:
+        raise ValueError(f"Error bar method '{method}' not recognized.")
+
+
+def compute_errorbars(data, estimator, errorbar, n_boot, seed):
+    """
+    Compute error bars for grouped data.
+
+    Parameters
+    ----------
+    data : pandas Series or array
+        Data grouped by condition.
+    estimator : callable or string
+        Function to compute point estimate.
+    errorbar : string, (string, number) tuple, or callable
+        Specification for error bars.
+    n_boot : int
+        Number of bootstrap samples.
+    seed : int
+        Random seed for bootstrap.
+
+    Returns
+    -------
+    statistic : array
+        Point estimates.
+    confint : array
+        Error bar limits.
+    """
+    grouped = data
+    if isinstance(grouped, pd.Series):
+        groups = [grouped]
+    else:
+        groups = [g for _, g in grouped]
+
+    statistic = []
+    confint = []
+    for g in groups:
+        point, low, high = _get_errorbars(g, estimator, errorbar, n_boot, seed)
+        statistic.append(point)
+        confint.append([low, high])
+
+    statistic = np.array(statistic)
+    confint = np.array(confint)
+    return statistic, confint
