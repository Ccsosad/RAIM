diff --git a/seaborn/categorical.py b/seaborn/categorical.py
index 27d5801..954a8ed 100644
--- a/seaborn/categorical.py
+++ b/seaborn/categorical.py
@@ -1520,6 +1520,28 @@ class _SwarmPlotter(_CategoricalScatterPlotter):
         else:
             self.add_gutters(new_y, center, width)
 
+        # Reorder the points to the original order if needed
+        if hasattr(points, '_sns_orig_order'):
+            # The current offsets are in sorted order, so we need to reorder
+            # to the original order.
+            orig_order = points._sns_orig_order
+            # We have new_x and new_y for sorted data.
+            # Create an array for the sorted data
+            sorted_offsets = np.column_stack((new_x, new_y))
+            # Create an array for the original order
+            orig_offsets = np.empty_like(sorted_offsets)
+            # The sorter that was used to sort the data is argsort(swarm_data)
+            # We have stored the original order as an array of indices in the original data.
+            # But we need to map from sorted index to original index.
+            # We have orig_order_sorted, which is the original index for each sorted point.
+            # So we can do:
+            # For each original index i, find the sorted index j such that orig_order_sorted[j] == i
+            # Actually, we have the inverse: from sorted to original.
+            # We want to place the sorted point j into position orig_order_sorted[j] in the original array.
+            # So:
+            orig_offsets[points._sns_orig_order] = sorted_offsets
+            new_x, new_y = orig_offsets[:,0], orig_offsets[:,1]
+
         # Reposition the points so they do not overlap
         points.set_offsets(np.c_[new_x, new_y])
 
@@ -1529,6 +1551,7 @@ class _SwarmPlotter(_CategoricalScatterPlotter):
 
         centers = []
         swarms = []
+        beeswarm_objects = []
 
         palette = np.asarray(self.colors)
 
@@ -1556,21 +1579,33 @@ class _SwarmPlotter(_CategoricalScatterPlotter):
                 swarm_data = np.asarray(group_data[hue_mask])
                 point_colors = np.asarray(self.point_colors[i][hue_mask])
 
+                # Store the original order
+                orig_order = np.arange(len(swarm_data))
                 # Sort the points for the beeswarm algorithm
                 sorter = np.argsort(swarm_data)
-                swarm_data = swarm_data[sorter]
-                point_colors = point_colors[sorter]
+                swarm_data_sorted = swarm_data[sorter]
+                point_colors_sorted = point_colors[sorter]
+                orig_order_sorted = orig_order[sorter]
 
-                # Plot the points in centered positions
-                cat_pos = np.ones(swarm_data.size) * i
-                kws.update(c=palette[point_colors])
+                # Plot the points in centered positions (sorted)
+                cat_pos = np.ones(swarm_data_sorted.size) * i
+                kws.update(c=palette[point_colors_sorted])
                 if self.orient == "v":
-                    points = ax.scatter(cat_pos, swarm_data, s=s, **kws)
+                    points = ax.scatter(cat_pos, swarm_data_sorted, s=s, **kws)
                 else:
-                    points = ax.scatter(swarm_data, cat_pos, s=s, **kws)
+                    points = ax.scatter(swarm_data_sorted, cat_pos, s=s, **kws)
+
+                # Store the original data (unsorted) for the artist
+                points._sns_orig_data = np.column_stack((cat_pos, swarm_data)) if self.orient == "v" else np.column_stack((swarm_data, cat_pos))
+                points._sns_orig_order = orig_order
+                points._sns_center = i
+                points._sns_width = width
+                points._sns_s = s
+                points._sns_kws = kws.copy()
 
                 centers.append(i)
                 swarms.append(points)
+                beeswarm_objects.append(points)
 
             else:
                 offsets = self.hue_offsets
@@ -1581,31 +1616,48 @@ class _SwarmPlotter(_CategoricalScatterPlotter):
                     swarm_data = np.asarray(group_data[hue_mask])
                     point_colors = np.asarray(self.point_colors[i][hue_mask])
 
+                    # Store the original order
+                    orig_order = np.arange(len(swarm_data))
                     # Sort the points for the beeswarm algorithm
                     sorter = np.argsort(swarm_data)
-                    swarm_data = swarm_data[sorter]
-                    point_colors = point_colors[sorter]
+                    swarm_data_sorted = swarm_data[sorter]
+                    point_colors_sorted = point_colors[sorter]
+                    orig_order_sorted = orig_order[sorter]
 
                     # Plot the points in centered positions
                     center = i + offsets[j]
-                    cat_pos = np.ones(swarm_data.size) * center
-                    kws.update(c=palette[point_colors])
+                    cat_pos = np.ones(swarm_data_sorted.size) * center
+                    kws.update(c=palette[point_colors_sorted])
                     if self.orient == "v":
-                        points = ax.scatter(cat_pos, swarm_data, s=s, **kws)
+                        points = ax.scatter(cat_pos, swarm_data_sorted, s=s, **kws)
                     else:
-                        points = ax.scatter(swarm_data, cat_pos, s=s, **kws)
+                        points = ax.scatter(swarm_data_sorted, cat_pos, s=s, **kws)
+
+                    # Store the original data (unsorted) for the artist
+                    points._sns_orig_data = np.column_stack((cat_pos, swarm_data)) if self.orient == "v" else np.column_stack((swarm_data, cat_pos))
+                    points._sns_orig_order = orig_order
+                    points._sns_center = center
+                    points._sns_width = width
+                    points._sns_s = s
+                    points._sns_kws = kws.copy()
 
                     centers.append(center)
                     swarms.append(points)
+                    beeswarm_objects.append(points)
 
         # Autoscale the valus axis to set the data/axes transforms properly
         ax.autoscale_view(scalex=self.orient == "h", scaley=self.orient == "v")
 
-        # Update the position of each point on the categorical axis
-        # Do this after plotting so that the numerical axis limits are correct
-        for center, swarm in zip(centers, swarms):
-            if swarm.get_offsets().size:
-                self.swarm_points(ax, swarm, center, width, s, **kws)
+        # Create a draw callback to update the swarm positions
+        def on_draw(event):
+            for artist in beeswarm_objects:
+                if artist.get_offsets().size:
+                    self.swarm_points(ax, artist, artist._sns_center, artist._sns_width, artist._sns_s, **artist._sns_kws)
+        ax.figure.canvas.mpl_connect('draw_event', on_draw)
+        # Also update once initially
+        for artist in beeswarm_objects:
+            if artist.get_offsets().size:
+                self.swarm_points(ax, artist, artist._sns_center, artist._sns_width, artist._sns_s, **artist._sns_kws)
 
     def plot(self, ax, kws):
         """Make the full plot."""
