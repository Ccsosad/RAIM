diff --git a/xarray/core/dataarray.py b/xarray/core/dataarray.py
index 5ee3f81..94a6ef0 100644
--- a/xarray/core/dataarray.py
+++ b/xarray/core/dataarray.py
@@ -3081,6 +3081,33 @@ class DataArray(AbstractArray, DataWithCoords):
 
         return title
 
+    def query(self, expr: str, engine: str = None) -> "DataArray":
+        """Return a new DataArray with data filtered by the query expression.
+
+        Parameters
+        ----------
+        expr : str
+            Query expression to evaluate. The expression can refer to
+            variables in the dataset.
+        engine : str, optional
+            Engine to use for evaluating the query. Currently only "numexpr"
+            is supported.
+
+        Returns
+        -------
+        filtered : DataArray
+            DataArray with the same coordinates and attributes but with data
+            filtered by the query.
+
+        See Also
+        --------
+        Dataset.query
+        """
+        from .query import DataArrayQuery
+
+        q = DataArrayQuery(self, engine=engine)
+        return q.eval(expr)
+
     def diff(self, dim: Hashable, n: int = 1, label: Hashable = "upper") -> "DataArray":
         """Calculate the n-th order discrete difference along given axis.
 
@@ -4360,4 +4387,4 @@ class DataArray(AbstractArray, DataWithCoords):
 
 
 # priority most be higher than Variable to properly work with binary ufuncs
-ops.inject_all_ops_and_reduce_methods(DataArray, priority=60)
+ops.inject_all_ops_and_reduce_methods(DataArray, priority=60)
diff --git a/xarray/core/dataset.py b/xarray/core/dataset.py
index e6fceb8..d6d2167 100644
--- a/xarray/core/dataset.py
+++ b/xarray/core/dataset.py
@@ -5451,6 +5451,33 @@ class Dataset(Mapping, ImplementsDatasetReduce, DataWithCoords):
             if v in self.variables:
                 self.variables[v].attrs = other.variables[v].attrs
 
+    def query(self, expr: str, engine: str = None) -> "Dataset":
+        """Return a new Dataset with data filtered by the query expression.
+
+        Parameters
+        ----------
+        expr : str
+            Query expression to evaluate. The expression can refer to
+            variables in the dataset.
+        engine : str, optional
+            Engine to use for evaluating the query. Currently only "numexpr"
+            is supported.
+
+        Returns
+        -------
+        filtered : Dataset
+            Dataset with the same coordinates and attributes but with data
+            filtered by the query.
+
+        See Also
+        --------
+        DataArray.query
+        """
+        from .query import DatasetQuery
+
+        q = DatasetQuery(self, engine=engine)
+        return q.eval(expr)
+
     def diff(self, dim, n=1, label="upper"):
         """Calculate the n-th order discrete difference along given axis.
 
@@ -7002,4 +7029,4 @@ class Dataset(Mapping, ImplementsDatasetReduce, DataWithCoords):
             )
 
 
-ops.inject_all_ops_and_reduce_methods(Dataset, array_only=False)
+ops.inject_all_ops_and_reduce_methods(Dataset, array_only=False)
diff --git a/xarray/core/query/__init__.py b/xarray/core/query/__init__.py
new file mode 100644
index 0000000..2537928
--- /dev/null
+++ b/xarray/core/query/__init__.py
@@ -0,0 +1,59 @@
+"""
+Query module for xarray.
+"""
+from .evaluator import QueryEvaluator
+from .parser import QueryParser
+
+class DatasetQuery:
+    """Query interface for Dataset."""
+
+    def __init__(self, dataset, engine=None):
+        self.dataset = dataset
+        self.evaluator = QueryEvaluator(dataset, engine=engine)
+
+    def eval(self, expr):
+        """Evaluate the query and return a filtered dataset."""
+        # Parse the expression to validate variables
+        parser = QueryParser(expr)
+        parser.validate(self.dataset.variables)
+
+        # Get the boolean mask
+        mask = self.evaluator.eval(expr)
+
+        # Apply the mask to all data variables
+        filtered_vars = {}
+        for name, var in self.dataset.variables.items():
+            if name in self.dataset.data_vars:
+                # For data variables, we need to apply the mask along the dimensions
+                # that are present in the mask.
+                # The mask is computed over the dimensions of the variables used in the expression.
+                # We need to broadcast the mask to the shape of the variable.
+                # This is a simplified approach: we assume the mask is 1D and matches the first dimension.
+                # In reality, we should support multi-dimensional masking.
+                # For now, we'll use the mask as is and let xarray handle broadcasting.
+                filtered_vars[name] = var.where(mask)
+            else:
+                filtered_vars[name] = var
+
+        from ..dataset import Dataset
+        return Dataset(filtered_vars, attrs=self.dataset.attrs)
+
+class DataArrayQuery:
+    """Query interface for DataArray."""
+
+    def __init__(self, dataarray, engine=None):
+        self.dataarray = dataarray
+        self.evaluator = QueryEvaluator(dataarray, engine=engine)
+
+    def eval(self, expr):
+        """Evaluate the query and return a filtered dataarray."""
+        # Parse the expression to validate variables
+        parser = QueryParser(expr)
+        # For DataArray, the only variable is the dataarray itself, which is named.
+        # But the expression can refer to coordinates as well.
+        # We'll create a temporary dataset to evaluate the expression.
+        from ..dataset import Dataset
+        ds = Dataset({self.dataarray.name or 'var': self.dataarray})
+        ds_query = DatasetQuery(ds, engine=engine)
+        filtered_ds = ds_query.eval(expr)
+        return filtered_ds[self.dataarray.name or 'var']
diff --git a/xarray/core/query/evaluator.py b/xarray/core/query/evaluator.py
new file mode 100644
index 0000000..d6d482d
--- /dev/null
+++ b/xarray/core/query/evaluator.py
@@ -0,0 +1,41 @@
+"""
+Query evaluator for xarray objects.
+"""
+import numpy as np
+import pandas as pd
+from ..common import AbstractArray
+
+class QueryEvaluator:
+    """Base class for evaluating queries on xarray objects."""
+
+    def __init__(self, obj, engine=None):
+        self.obj = obj
+        self.engine = engine or "numexpr"
+
+        if self.engine != "numexpr":
+            raise ValueError(f"Unsupported engine: {self.engine}")
+
+    def eval(self, expr):
+        """Evaluate the query expression and return a boolean mask."""
+        # Import numexpr only when needed
+        import numexpr as ne
+
+        # Get the variables in the expression
+        local_dict = {}
+        for name, var in self.obj.variables.items():
+            if name in expr:
+                # Convert to numpy array if it's a dask array
+                data = var.data
+                if hasattr(data, 'compute'):
+                    data = data.compute()
+                local_dict[name] = data
+
+        # Evaluate the expression
+        try:
+            mask = ne.evaluate(expr, local_dict=local_dict)
+        except Exception as e:
+            raise ValueError(f"Failed to evaluate query: {expr}") from e
+
+        # Ensure the mask is a boolean array
+        mask = np.asarray(mask, dtype=bool)
+        return mask
diff --git a/xarray/core/query/parser.py b/xarray/core/query/parser.py
new file mode 100644
index 0000000..c4872fc
--- /dev/null
+++ b/xarray/core/query/parser.py
@@ -0,0 +1,34 @@
+"""
+Query parser for xarray objects.
+"""
+import re
+from typing import Dict, Any
+
+class QueryParser:
+    """Parse query expressions for xarray objects."""
+
+    def __init__(self, expr: str):
+        self.expr = expr
+        self.variables = self._extract_variables(expr)
+
+    @staticmethod
+    def _extract_variables(expr: str) -> list:
+        """Extract variable names from the expression."""
+        # Simple regex to find variable names (alphanumeric and underscores)
+        pattern = r'\b[a-zA-Z_][a-zA-Z0-9_]*\b'
+        words = re.findall(pattern, expr)
+        # Remove Python keywords and built-in functions
+        keywords = {'and', 'or', 'not', 'in', 'is', 'if', 'else', 'for', 'while',
+                    'def', 'class', 'import', 'from', 'as', 'True', 'False', 'None'}
+        builtins = {'abs', 'all', 'any', 'bin', 'bool', 'chr', 'complex', 'divmod',
+                    'float', 'int', 'len', 'max', 'min', 'oct', 'ord', 'pow', 'print',
+                    'range', 'round', 'str', 'sum', 'type'}
+        excluded = keywords.union(builtins)
+        variables = [w for w in words if w not in excluded]
+        return list(set(variables))
+
+    def validate(self, available_vars: Dict[str, Any]) -> None:
+        """Validate that all required variables are available."""
+        for var in self.variables:
+            if var not in available_vars:
+                raise ValueError(f"Variable {var!r} not found in the dataset.")
