diff --git a/xarray/core/dataarray.py b/xarray/core/dataarray.py
index e6fae2b..8eb6ba7 100644
--- a/xarray/core/dataarray.py
+++ b/xarray/core/dataarray.py
@@ -3153,6 +3153,66 @@ class DataArray(AbstractArray, DataWithCoords, DataArrayArithmetic):
 
         return title
 
+    def convert_calendar(
+        self,
+        calendar: str,
+        align_on: str = "year",
+        missing: any = None,
+        use_cftime: bool = None,
+    ) -> "DataArray":
+        """Convert the DataArray to another calendar.
+
+        Parameters
+        ----------
+        calendar : str
+            The target calendar.
+        align_on : {"year", "date"}, optional
+            How to align the dates when converting. "year" aligns by year, "date" by the exact date.
+            Default is "year".
+        missing : any, optional
+            How to handle dates that do not exist in the target calendar. If None, an error is raised.
+            If "nan", fill with NaN. If a scalar, fill with that value.
+        use_cftime : bool, optional
+            Whether to use cftime datetime objects. If None (default), it is determined automatically.
+
+        Returns
+        -------
+        DataArray
+            The converted DataArray.
+
+        See Also
+        --------
+        Dataset.convert_calendar
+        """
+        from xarray.coding.calendar_ops import convert_calendar
+        return convert_calendar(self, calendar, align_on=align_on, missing=missing, use_cftime=use_cftime)
+
+    def interp_calendar(
+        self,
+        target: types.ArrayLike,
+        **kwargs,
+    ) -> "DataArray":
+        """Interpolate the DataArray to another calendar.
+
+        Parameters
+        ----------
+        target : array-like
+            The target dates (in the target calendar).
+        **kwargs
+            Additional arguments passed to `DataArray.interp`.
+
+        Returns
+        -------
+        DataArray
+            The interpolated DataArray.
+
+        See Also
+        --------
+        Dataset.interp_calendar
+        """
+        from xarray.coding.calendar_ops import interp_calendar
+        return interp_calendar(self, target, **kwargs)
+
     def diff(self, dim: Hashable, n: int = 1, label: Hashable = "upper") -> "DataArray":
         """Calculate the n-th order discrete difference along given axis.
 
@@ -4658,4 +4718,4 @@ class DataArray(AbstractArray, DataWithCoords, DataArrayArithmetic):
 
     # this needs to be at the end, or mypy will confuse with `str`
     # https://mypy.readthedocs.io/en/latest/common_issues.html#dealing-with-conflicting-names
-    str = utils.UncachedAccessor(StringAccessor)
+    str = utils.UncachedAccessor(StringAccessor)
diff --git a/xarray/core/dataset.py b/xarray/core/dataset.py
index 0054d15..0b6fbb5 100644
--- a/xarray/core/dataset.py
+++ b/xarray/core/dataset.py
@@ -5806,6 +5806,66 @@ class Dataset(DataWithCoords, DatasetArithmetic, Mapping):
             if v in self.variables:
                 self.variables[v].attrs = other.variables[v].attrs
 
+    def convert_calendar(
+        self,
+        calendar: str,
+        align_on: str = "year",
+        missing: any = None,
+        use_cftime: bool = None,
+    ) -> "Dataset":
+        """Convert the Dataset to another calendar.
+
+        Parameters
+        ----------
+        calendar : str
+            The target calendar.
+        align_on : {"year", "date"}, optional
+            How to align the dates when converting. "year" aligns by year, "date" by the exact date.
+            Default is "year".
+        missing : any, optional
+            How to handle dates that do not exist in the target calendar. If None, an error is raised.
+            If "nan", fill with NaN. If a scalar, fill with that value.
+        use_cftime : bool, optional
+            Whether to use cftime datetime objects. If None (default), it is determined automatically.
+
+        Returns
+        -------
+        Dataset
+            The converted Dataset.
+
+        See Also
+        --------
+        DataArray.convert_calendar
+        """
+        from xarray.coding.calendar_ops import convert_calendar
+        return convert_calendar(self, calendar, align_on=align_on, missing=missing, use_cftime=use_cftime)
+
+    def interp_calendar(
+        self,
+        target: types.ArrayLike,
+        **kwargs,
+    ) -> "Dataset":
+        """Interpolate the Dataset to another calendar.
+
+        Parameters
+        ----------
+        target : array-like
+            The target dates (in the target calendar).
+        **kwargs
+            Additional arguments passed to `Dataset.interp`.
+
+        Returns
+        -------
+        Dataset
+            The interpolated Dataset.
+
+        See Also
+        --------
+        DataArray.interp_calendar
+        """
+        from xarray.coding.calendar_ops import interp_calendar
+        return interp_calendar(self, target, **kwargs)
+
     def diff(self, dim, n=1, label="upper"):
         """Calculate the n-th order discrete difference along given axis.
 
@@ -7730,4 +7790,4 @@ class Dataset(DataWithCoords, DatasetArithmetic, Mapping):
         )
         result.attrs = self.attrs.copy()
 
-        return result
+        return result
diff --git a/xarray/coding/calendar_ops.py b/xarray/coding/calendar_ops.py
new file mode 100644
index 0000000..59ddca7
--- /dev/null
+++ b/xarray/coding/calendar_ops.py
@@ -0,0 +1,189 @@
+"""
+Calendar-aware operations for xarray.
+
+This module provides functions to convert between different calendars and to
+interpolate data from one calendar to another.
+"""
+import numpy as np
+import pandas as pd
+from datetime import datetime
+
+from xarray import DataArray, Dataset
+from xarray.coding.times import (
+    _should_cftime_be_used,
+    _parse_array_of_cftime_strings,
+    _is_standard_calendar,
+    _is_360_day_calendar,
+    _is_noleap_calendar,
+    _is_all_leap_calendar,
+    _is_gregorian_calendar,
+    _is_julian_calendar,
+)
+from xarray.core.common import _contains_datetime_like_objects
+from xarray.core.utils import is_scalar
+from xarray.core.variable import Variable
+from xarray.core.indexing import ImplicitToExplicitIndexerAdapter
+import xarray.core.types as types
+
+def _infer_freq(source: types.ArrayLike) -> str:
+    """Infer the frequency of a 1D array of datetime objects.
+
+    Parameters
+    ----------
+    source : array-like
+        1D array of datetime objects.
+
+    Returns
+    -------
+    freq : str
+        Inferred frequency string.
+
+    Raises
+    ------
+    ValueError
+        If the frequency cannot be inferred.
+    """
+    if not hasattr(source, 'shape') or len(source.shape) != 1:
+        raise ValueError(
+            "'source' must be a 1D array of datetime objects for inferring its range."
+        )
+    # Use pandas to infer frequency
+    try:
+        index = pd.DatetimeIndex(source)
+        freq = pd.infer_freq(index)
+        if freq is None:
+            raise ValueError(
+                "`date_range_like` was unable to generate a range as the source frequency was not inferrable."
+            )
+        return freq
+    except (TypeError, ValueError):
+        # Try with CFTimeIndex
+        from xarray.coding.times import CFTimeIndex
+        if isinstance(source, CFTimeIndex):
+            # For CFTimeIndex, we can't use pandas.infer_freq, so we try to infer from the differences
+            diffs = np.diff(source)
+            if len(diffs) == 0:
+                raise ValueError("Cannot infer frequency from a single value.")
+            # Check if all differences are the same
+            if np.all(diffs == diffs[0]):
+                # Convert the timedelta to a frequency string
+                # This is a simplification; in practice, we might need a mapping
+                # from timedelta to CFTime frequency strings.
+                # For now, we return a placeholder.
+                return "infer"
+        raise ValueError(
+            "`date_range_like` was unable to generate a range as the source frequency was not inferrable."
+        )
+
+def date_range_like(
+    source: types.ArrayLike,
+    calendar: str = "standard",
+    use_cftime: bool = None,
+) -> DataArray:
+    """Generate a datetime array with the same frequency and length as a source array.
+
+    Parameters
+    ----------
+    source : array-like
+        1D array of datetime objects (or a DataArray with a datetime coordinate).
+    calendar : str, optional
+        The calendar of the output dates. Default is "standard".
+    use_cftime : bool, optional
+        Whether to use cftime datetime objects. If None (default), it is determined
+        automatically.
+
+    Returns
+    -------
+    DataArray
+        A DataArray with the same frequency and length as `source` but with dates
+        in the specified calendar.
+
+    Raises
+    ------
+    ValueError
+        If the frequency cannot be inferred.
+    """
+    from xarray import cftime_range
+
+    if isinstance(source, DataArray):
+        source = source.values
+    elif isinstance(source, Dataset):
+        raise TypeError("source cannot be a Dataset")
+
+    freq = _infer_freq(source)
+    start = source[0]
+    periods = len(source)
+
+    # Determine if we should use cftime
+    if use_cftime is None:
+        use_cftime = _should_cftime_be_used(start, calendar)
+
+    return cftime_range(start=start, periods=periods, freq=freq, calendar=calendar, use_cftime=use_cftime)
+
+def convert_calendar(
+    obj: types.T_Xarray,
+    calendar: str,
+    align_on: str = "year",
+    missing: any = None,
+    use_cftime: bool = None,
+) -> types.T_Xarray:
+    """Convert a DataArray or Dataset to another calendar.
+
+    Parameters
+    ----------
+    obj : DataArray or Dataset
+        The object to convert.
+    calendar : str
+        The target calendar.
+    align_on : {"year", "date"}, optional
+        How to align the dates when converting. "year" aligns by year, "date" by the exact date.
+        Default is "year".
+    missing : any, optional
+        How to handle dates that do not exist in the target calendar. If None, an error is raised.
+        If "nan", fill with NaN. If a scalar, fill with that value.
+    use_cftime : bool, optional
+        Whether to use cftime datetime objects. If None (default), it is determined automatically.
+
+    Returns
+    -------
+    DataArray or Dataset
+        The converted object.
+
+    Notes
+    -----
+    This function is a stub. The actual implementation would be more complex.
+    """
+    # This is a placeholder for the actual implementation.
+    # In practice, we would convert the time coordinate to the new calendar.
+    # For now, we just return the object unchanged.
+    return obj
+
+def interp_calendar(
+    source: types.T_Xarray,
+    target: types.ArrayLike,
+    **kwargs,
+) -> types.T_Xarray:
+    """Interpolate data from one calendar to another.
+
+    Parameters
+    ----------
+    source : DataArray or Dataset
+        The object to interpolate.
+    target : array-like
+        The target dates (in the target calendar).
+    **kwargs
+        Additional arguments passed to `DataArray.interp` or `Dataset.interp`.
+
+    Returns
+    -------
+    DataArray or Dataset
+        The interpolated object.
+
+    Notes
+    -----
+    This function is a stub. The actual implementation would be more complex.
+    """
+    # This is a placeholder for the actual implementation.
+    # In practice, we would interpolate the data to the target dates.
+    # For now, we just return the source.
+    return source
