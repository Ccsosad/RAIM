diff --git a/astropy/visualization/wcsaxes/core.py b/astropy/visualization/wcsaxes/core.py
index 573033c..8ceba46 100644
--- a/astropy/visualization/wcsaxes/core.py
+++ b/astropy/visualization/wcsaxes/core.py
@@ -94,7 +94,7 @@ class WCSAxes(Axes):
     """
 
     def __init__(self, fig, rect, wcs=None, transform=None, coord_meta=None,
-                 transData=None, slices=None, frame_class=RectangularFrame,
+                 transData=None, slices=None, frame_class=None,
                  **kwargs):
 
         super().__init__(fig, rect, **kwargs)
@@ -352,13 +352,24 @@ class WCSAxes(Axes):
             previous_frame = {'path': None}
 
         if self.wcs is not None:
-
             transform, coord_meta = transform_coord_meta_from_wcs(self.wcs, self.frame_class, slices=slices)
 
+        # Determine the number of visible world axes
+        if coord_meta is not None:
+            n_visible = sum(coord_meta.get('visible', []))
+        else:
+            n_visible = 2  # default
+
+        # If the frame_class is the default RectangularFrame and we have 1D, use RectangularFrame1D
+        if self.frame_class is RectangularFrame and n_visible == 1:
+            frame_class = RectangularFrame1D
+        else:
+            frame_class = self.frame_class
+
         self.coords = CoordinatesMap(self,
                                      transform=transform,
                                      coord_meta=coord_meta,
-                                     frame_class=self.frame_class,
+                                     frame_class=frame_class,
                                      previous_frame_path=previous_frame['path'])
 
         self._transform_pixel2world = transform
@@ -635,9 +646,11 @@ class WCSAxes(Axes):
         if axis == 'both':
             self.coords.grid(draw_grid=b, **kwargs)
         elif axis == 'x':
-            self.coords[0].grid(draw_grid=b, **kwargs)
+            if len(self.coords) > 0:
+                self.coords[0].grid(draw_grid=b, **kwargs)
         elif axis == 'y':
-            self.coords[1].grid(draw_grid=b, **kwargs)
+            if len(self.coords) > 1:
+                self.coords[1].grid(draw_grid=b, **kwargs)
         else:
             raise ValueError('axis should be one of x/y/both')
 
@@ -721,7 +734,7 @@ class WCSAxes(Axes):
 
             self.coords[axis].tick_params(**kwargs)
 
-        elif axis in ('x', 'y') and self.frame_class is RectangularFrame:
+        elif axis in ('x', 'y') and (self.frame_class is RectangularFrame or self.frame_class is RectangularFrame1D):
 
             spine = 'b' if axis == 'x' else 'l'
 
diff --git a/astropy/visualization/wcsaxes/frame.py b/astropy/visualization/wcsaxes/frame.py
index e6627e8..f643d25 100644
--- a/astropy/visualization/wcsaxes/frame.py
+++ b/astropy/visualization/wcsaxes/frame.py
@@ -197,6 +197,21 @@ class BaseFrame(OrderedDict, metaclass=abc.ABCMeta):
         raise NotImplementedError("")
 
 
+class RectangularFrame1D(BaseFrame):
+    """
+    A frame for 1D plots.
+    """
+
+    spine_names = 'b'
+
+    def update_spines(self):
+        xmin, xmax = self.parent_axes.get_xlim()
+        ymin, ymax = self.parent_axes.get_ylim()
+
+        # For 1D plots, we only show the bottom spine
+        self['b'].data = np.array([[xmin, ymin], [xmax, ymin]])
+
+
 class RectangularFrame(BaseFrame):
     """
     A classic rectangular frame.
diff --git a/astropy/visualization/wcsaxes/wcsapi.py b/astropy/visualization/wcsaxes/wcsapi.py
index 18817a1..a33eb5d 100644
--- a/astropy/visualization/wcsaxes/wcsapi.py
+++ b/astropy/visualization/wcsaxes/wcsapi.py
@@ -33,10 +33,14 @@ def transform_coord_meta_from_wcs(wcs, frame_class, slices=None):
             raise ValueError("'slices' should have as many elements as WCS "
                              "has pixel dimensions (should be {})"
                              .format(wcs.pixel_n_dim))
-    elif wcs.pixel_n_dim < 2:
-        raise ValueError("WCS should have at least 2 pixel dimensions")
-    elif slices is not None and slices != ('x', 'y') and slices != ('y', 'x'):
-        raise ValueError("WCS only has 2 pixel dimensions and cannot be sliced")
+    elif wcs.pixel_n_dim == 2:
+        if slices is not None and slices != ('x', 'y') and slices != ('y', 'x'):
+            raise ValueError("WCS only has 2 pixel dimensions and cannot be sliced")
+    elif wcs.pixel_n_dim == 1:
+        if slices is not None and slices != ('x',) and slices != ('y',):
+            raise ValueError("WCS only has 1 pixel dimension and cannot be sliced")
+    else:
+        raise ValueError("WCS should have at least 1 pixel dimension")
 
     is_fits_wcs = isinstance(wcs, WCS)
 
@@ -124,10 +128,17 @@ def transform_coord_meta_from_wcs(wcs, frame_class, slices=None):
     invert_xy = False
     if slices is not None:
         wcs_slice = list(slices)
-        wcs_slice[wcs_slice.index("x")] = slice(None)
-        wcs_slice[wcs_slice.index("y")] = slice(None)
-        wcs = SlicedLowLevelWCS(wcs, wcs_slice[::-1])
-        invert_xy = slices.index('x') > slices.index('y')
+        if 'x' in wcs_slice and 'y' in wcs_slice:
+            wcs_slice[wcs_slice.index("x")] = slice(None)
+            wcs_slice[wcs_slice.index("y")] = slice(None)
+            wcs = SlicedLowLevelWCS(wcs, wcs_slice[::-1])
+            invert_xy = slices.index('x') > slices.index('y')
+        elif 'x' in wcs_slice:
+            wcs_slice[wcs_slice.index("x")] = slice(None)
+            wcs = SlicedLowLevelWCS(wcs, wcs_slice[::-1])
+        elif 'y' in wcs_slice:
+            wcs_slice[wcs_slice.index("y")] = slice(None)
+            wcs = SlicedLowLevelWCS(wcs, wcs_slice[::-1])
         world_keep = wcs._world_keep
     else:
         world_keep = list(range(wcs.world_n_dim))
@@ -138,10 +149,20 @@ def transform_coord_meta_from_wcs(wcs, frame_class, slices=None):
     transform = WCSPixel2WorldTransform(wcs, invert_xy=invert_xy)
 
     m = wcs.axis_correlation_matrix.copy()
-    if invert_xy:
+    if invert_xy and m.shape[1] >= 2:
         m = m[:, ::-1]
 
-    if frame_class is RectangularFrame:
+    if frame_class is RectangularFrame1D:
+
+        # For 1D frames, we only have one spine (bottom)
+        for i in range(len(coord_meta['type'])):
+            if i in world_keep:
+                index = world_keep[i]
+                coord_meta['default_axislabel_position'][index] = 'b'
+                coord_meta['default_ticklabel_position'][index] = 'b'
+                coord_meta['default_ticks_position'][index] = 'b'
+
+    elif frame_class is RectangularFrame:
 
         for i, spine_name in enumerate('bltr'):
             pos = np.nonzero(m[:, i % 2])[0]
