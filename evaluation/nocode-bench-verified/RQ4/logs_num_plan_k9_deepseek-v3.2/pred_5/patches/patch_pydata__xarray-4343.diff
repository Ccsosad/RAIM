diff --git a/xarray/coding/cftimeindex.py b/xarray/coding/cftimeindex.py
index a4efa02..df9d484 100644
--- a/xarray/coding/cftimeindex.py
+++ b/xarray/coding/cftimeindex.py
@@ -415,7 +415,8 @@ class CFTimeIndex(pd.Index):
 
     def _get_string_slice(self, key):
         """Adapted from pandas.tseries.index.DatetimeIndex._get_string_slice"""
-        parsed, resolution = _parse_iso8601_with_reso(self.date_type, key)
+        from .times import parse_iso8601_like
+        parsed, resolution = parse_iso8601_like(self.date_type, key)
         try:
             loc = self._partial_date_slice(resolution, parsed)
         except KeyError:
@@ -459,7 +460,8 @@ class CFTimeIndex(pd.Index):
         """Adapted from
         pandas.tseries.index.DatetimeIndex._maybe_cast_slice_bound"""
         if isinstance(label, str):
-            parsed, resolution = _parse_iso8601_with_reso(self.date_type, label)
+            from .times import parse_iso8601_like
+            parsed, resolution = parse_iso8601_like(self.date_type, label)
             start, end = _parsed_string_to_bounds(self.date_type, resolution, parsed)
             if self.is_monotonic_decreasing and len(self) > 1:
                 return end if side == "left" else start
@@ -743,7 +745,8 @@ class CFTimeIndex(pd.Index):
 
 
 def _parse_iso8601_without_reso(date_type, datetime_str):
-    date, _ = _parse_iso8601_with_reso(date_type, datetime_str)
+    from .times import parse_iso8601_like
+    date, _ = parse_iso8601_like(date_type, datetime_str)
     return date
 
 
diff --git a/xarray/coding/times.py b/xarray/coding/times.py
index 1f45ede..06844fa 100644
--- a/xarray/coding/times.py
+++ b/xarray/coding/times.py
@@ -1,3 +1,4 @@
+
 import re
 import warnings
 from datetime import datetime
@@ -133,6 +134,50 @@ def _decode_datetime_with_pandas(flat_num_dates, units, calendar):
     return (pd.to_timedelta(flat_num_dates_ns_int, "ns") + ref_date).values
 
 
+def parse_iso8601_like(date_type, datetime_str):
+    """Parse a datetime string that may be in ISO 8601 basic, extended, or
+    cftime default format.
+
+    Parameters
+    ----------
+    date_type : cftime.datetime class
+    datetime_str : str
+
+    Returns
+    -------
+    parsed : cftime.datetime
+    resolution : str
+    """
+    # List of formats to try, in order of preference.
+    # Each format is a tuple (format_string, resolution)
+    # The resolution is determined by the number of components.
+    formats = [
+        ("%Y-%m-%dT%H:%M:%S", "second"),   # ISO extended with seconds
+        ("%Y-%m-%d %H:%M:%S", "second"),   # cftime default with seconds
+        ("%Y%m%d%H%M%S", "second"),        # ISO basic with seconds
+        ("%Y-%m-%dT%H:%M", "minute"),      # ISO extended without seconds
+        ("%Y-%m-%d %H:%M", "minute"),      # cftime default without seconds
+        ("%Y%m%d%H%M", "minute"),          # ISO basic without seconds
+        ("%Y-%m-%dT%H", "hour"),
+        ("%Y-%m-%d %H", "hour"),
+        ("%Y%m%d%H", "hour"),
+        ("%Y-%m-%d", "day"),
+        ("%Y%m%d", "day"),
+        ("%Y-%m", "month"),
+        ("%Y%m", "month"),
+        ("%Y", "year"),
+    ]
+
+    for fmt, res in formats:
+        try:
+            parsed = date_type.strptime(datetime_str, fmt)
+            return parsed, res
+        except ValueError:
+            continue
+
+    raise ValueError(f"Unrecognized datetime string: {datetime_str}")
+
+
 def decode_cf_datetime(num_dates, units, calendar=None, use_cftime=None):
     """Given an array of numeric dates in netCDF format, convert it into a
     numpy array of date time objects.
