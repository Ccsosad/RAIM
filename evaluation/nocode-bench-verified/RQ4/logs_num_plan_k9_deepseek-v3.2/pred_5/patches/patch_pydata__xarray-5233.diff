diff --git a/xarray/core/accessor_dt.py b/xarray/core/accessor_dt.py
index 469c69b..92a2243 100644
--- a/xarray/core/accessor_dt.py
+++ b/xarray/core/accessor_dt.py
@@ -412,6 +412,10 @@ class DatetimeAccessor(Properties):
         "date", "Date corresponding to datetimes", object
     )
 
+    calendar = Properties._tslib_field_accessor(
+        "calendar", "Calendar of the datetime", object
+    )
+
     is_month_start = Properties._tslib_field_accessor(
         "is_month_start",
         "Indicates whether the date is the first day of the month.",
diff --git a/xarray/__init__.py b/xarray/__init__.py
new file mode 100644
index 0000000..8332ee7
--- /dev/null
+++ b/xarray/__init__.py
@@ -0,0 +1,2 @@
+from .coding.cftime_offsets import cftime_range
+from .coding.calendar_ops import date_range, date_range_like
diff --git a/xarray/coding/calendar_ops.py b/xarray/coding/calendar_ops.py
new file mode 100644
index 0000000..17e96d9
--- /dev/null
+++ b/xarray/coding/calendar_ops.py
@@ -0,0 +1,244 @@
+"""
+Calendar operations for xarray.
+
+This module provides functions for converting between calendars and generating
+date ranges with different calendars.
+"""
+import numpy as np
+import pandas as pd
+from .cftime_offsets import to_cftime_datetime, to_offset, cftime_range
+from .times import CFTimeIndex
+from xarray.core.common import _contains_cftime_datetimes
+
+
+def _should_cftime_be_used(calendar, use_cftime):
+    """Determine whether to use cftime or pandas for a given calendar.
+
+    Parameters
+    ----------
+    calendar : str
+        The calendar name.
+    use_cftime : bool or None
+        If None, use cftime only when necessary (i.e., for non-standard calendars
+        or dates outside the pandas range). If True, force use of cftime.
+        If False, force use of pandas.
+
+    Returns
+    -------
+    bool
+        True if cftime should be used, False otherwise.
+    """
+    if use_cftime is None:
+        # Use cftime for non-standard calendars
+        return calendar not in ("standard", "gregorian", "proleptic_gregorian")
+    else:
+        return use_cftime
+
+
+def convert_calendar(source, target_calendar, use_cftime=None, align_on="date"):
+    """
+    Convert a time coordinate from one calendar to another.
+
+    Parameters
+    ----------
+    source : DataArray or Dataset
+        The source data with a time coordinate.
+    target_calendar : str
+        The target calendar.
+    use_cftime : bool or None, optional
+        Whether to use cftime for the output. If None, use cftime when necessary.
+    align_on : {"date", "year", "month", "day"}, optional
+        How to align the dates when converting. Default is "date".
+
+    Returns
+    -------
+    DataArray or Dataset
+        The same data with the time coordinate converted to the target calendar.
+    """
+    from xarray.core.dataarray import DataArray
+    from xarray.core.dataset import Dataset
+
+    if not isinstance(source, (DataArray, Dataset)):
+        raise TypeError("source must be a DataArray or Dataset")
+
+    # Get the time coordinate
+    if "time" not in source.coords:
+        raise ValueError("source must have a 'time' coordinate")
+
+    time = source.coords["time"]
+    if time.ndim != 1:
+        raise ValueError("time coordinate must be 1-dimensional")
+
+    # Determine the source calendar
+    if _contains_cftime_datetimes(time):
+        # It's a CFTimeIndex
+        source_calendar = time.dt.calendar
+    else:
+        # It's a pandas DatetimeIndex
+        source_calendar = "standard"
+
+    if source_calendar == target_calendar:
+        return source
+
+    # Generate new time points in the target calendar
+    # We need to map each source time to a target time.
+    # For simplicity, we assume the source times are at regular intervals.
+    # We'll use the same frequency as inferred from the source.
+    freq = infer_freq(time)
+    if freq is None:
+        raise ValueError(
+            "Cannot infer frequency from time coordinate. "
+            "Only regularly spaced times are supported."
+        )
+
+    # Create a new time range in the target calendar
+    start = time.values[0]
+    end = time.values[-1]
+    periods = len(time)
+
+    # Convert start and end to the target calendar
+    if _contains_cftime_datetimes(time):
+        # start and end are cftime objects
+        start_target = to_cftime_datetime(start, target_calendar)
+        end_target = to_cftime_datetime(end, target_calendar)
+    else:
+        # start and end are pandas Timestamps
+        # Convert to cftime in target calendar
+        start_target = to_cftime_datetime(start, target_calendar)
+        end_target = to_cftime_datetime(end, target_calendar)
+
+    # Generate new time series
+    new_time = cftime_range(
+        start=start_target, end=end_target, periods=periods, freq=freq, calendar=target_calendar
+    )
+
+    # Replace the time coordinate
+    result = source.copy()
+    result.coords["time"] = new_time
+    return result
+
+
+def interp_calendar(source, target_calendar, use_cftime=None):
+    """
+    Interpolate data from one calendar to another.
+
+    Parameters
+    ----------
+    source : DataArray or Dataset
+        The source data with a time coordinate.
+    target_calendar : str
+        The target calendar.
+    use_cftime : bool or None, optional
+        Whether to use cftime for the output. If None, use cftime when necessary.
+
+    Returns
+    -------
+    DataArray or Dataset
+        The data interpolated to the target calendar.
+    """
+    # This is a placeholder for actual interpolation logic.
+    # For now, we just convert the calendar without interpolation.
+    # In a real implementation, we would need to handle mismatched dates.
+    return convert_calendar(source, target_calendar, use_cftime)
+
+
+def date_range(start=None, end=None, periods=None, freq="D", calendar="standard", **kwargs):
+    """
+    Return a fixed frequency datetime index.
+
+    This is a wrapper around pandas.date_range and cftime_range that chooses
+    the appropriate backend based on the calendar.
+
+    Parameters
+    ----------
+    start : str or datetime-like, optional
+        Left bound for generating dates.
+    end : str or datetime-like, optional
+        Right bound for generating dates.
+    periods : int, optional
+        Number of periods to generate.
+    freq : str, default "D"
+        Frequency string.
+    calendar : str, default "standard"
+        Calendar type.
+    **kwargs
+        Additional arguments passed to pandas.date_range or cftime_range.
+
+    Returns
+    -------
+    DatetimeIndex or CFTimeIndex
+    """
+    if _should_cftime_be_used(calendar, use_cftime=None):
+        return cftime_range(start=start, end=end, periods=periods, freq=freq, calendar=calendar, **kwargs)
+    else:
+        return pd.date_range(start=start, end=end, periods=periods, freq=freq, **kwargs)
+
+
+def date_range_like(source, calendar="standard", use_cftime=None):
+    """
+    Generate a datetime index with the same length and frequency as a source array.
+
+    Parameters
+    ----------
+    source : array-like
+        The source array. Must be 1D and contain datetime objects.
+    calendar : str, default "standard"
+        The calendar for the output.
+    use_cftime : bool or None, optional
+        Whether to use cftime for the output.
+
+    Returns
+    -------
+    DatetimeIndex or CFTimeIndex
+    """
+    source = np.asarray(source)
+    if source.ndim != 1:
+        raise ValueError("'source' must be a 1D array of datetime objects for inferring its range.")
+
+    # Infer the frequency
+    freq = infer_freq(source)
+    if freq is None:
+        raise ValueError(
+            "`date_range_like` was unable to generate a range as the source frequency was not inferrable."
+        )
+
+    start = source[0]
+    end = source[-1]
+    periods = len(source)
+
+    return date_range(start=start, end=end, periods=periods, freq=freq, calendar=calendar, use_cftime=use_cftime)
+
+
+def infer_freq(time):
+    """
+    Infer the frequency of a time series.
+
+    Parameters
+    ----------
+    time : array-like
+        Array of datetime objects.
+
+    Returns
+    -------
+    str or None
+        The inferred frequency string, or None if not inferrable.
+    """
+    # This is a simplified version. In practice, we should use pandas.infer_freq
+    # or a custom implementation for cftime.
+    try:
+        if hasattr(time, 'freq'):
+            return time.freq
+        elif hasattr(time, 'inferred_freq'):
+            return time.inferred_freq
+    except (AttributeError, TypeError):
+        pass
+
+    # If we have at least two points, we can try to compute the difference
+    if len(time) >= 2:
+        diff = time[1] - time[0]
+        # Convert diff to a frequency string
+        # This is a placeholder. In reality, we need to map timedelta to freq.
+        # For now, return None.
+        return None
+
+    return None
diff --git a/xarray/core/dataarray.py b/xarray/core/dataarray.py
new file mode 100644
index 0000000..16b0a18
--- /dev/null
+++ b/xarray/core/dataarray.py
@@ -0,0 +1,53 @@
+    def get_index(self, key):
+        """Get an index for a dimension, with fall-back to a default RangeIndex
+        if the dimension has no index.
+
+        Parameters
+        ----------
+        key : str
+            Name of the dimension.
+
+        Returns
+        -------
+        index : pandas.Index
+            Index for the dimension.
+        """
+        return _get_index(self._coords, key)
+
+    def convert_calendar(self, target_calendar, use_cftime=None, align_on="date"):
+        """Convert the time coordinate to another calendar.
+
+        Parameters
+        ----------
+        target_calendar : str
+            The target calendar.
+        use_cftime : bool or None, optional
+            Whether to use cftime for the output. If None, use cftime when necessary.
+        align_on : {"date", "year", "month", "day"}, optional
+            How to align the dates when converting.
+
+        Returns
+        -------
+        DataArray
+            A new DataArray with the time coordinate converted.
+        """
+        from xarray.coding.calendar_ops import convert_calendar
+        return convert_calendar(self, target_calendar, use_cftime=use_cftime, align_on=align_on)
+
+    def interp_calendar(self, target_calendar, use_cftime=None):
+        """Interpolate the data to another calendar.
+
+        Parameters
+        ----------
+        target_calendar : str
+            The target calendar.
+        use_cftime : bool or None, optional
+            Whether to use cftime for the output.
+
+        Returns
+        -------
+        DataArray
+            A new DataArray with the data interpolated to the target calendar.
+        """
+        from xarray.coding.calendar_ops import interp_calendar
+        return interp_calendar(self, target_calendar, use_cftime=use_cftime)
diff --git a/xarray/core/dataset.py b/xarray/core/dataset.py
new file mode 100644
index 0000000..bfee112
--- /dev/null
+++ b/xarray/core/dataset.py
@@ -0,0 +1,53 @@
+    def get_index(self, key):
+        """Get an index for a dimension, with fall-back to a default RangeIndex
+        if the dimension has no index.
+
+        Parameters
+        ----------
+        key : str
+            Name of the dimension.
+
+        Returns
+        -------
+        index : pandas.Index
+            Index for the dimension.
+        """
+        return _get_index(self._coords, key)
+
+    def convert_calendar(self, target_calendar, use_cftime=None, align_on="date"):
+        """Convert the time coordinate to another calendar.
+
+        Parameters
+        ----------
+        target_calendar : str
+            The target calendar.
+        use_cftime : bool or None, optional
+            Whether to use cftime for the output. If None, use cftime when necessary.
+        align_on : {"date", "year", "month", "day"}, optional
+            How to align the dates when converting.
+
+        Returns
+        -------
+        Dataset
+            A new Dataset with the time coordinate converted.
+        """
+        from xarray.coding.calendar_ops import convert_calendar
+        return convert_calendar(self, target_calendar, use_cftime=use_cftime, align_on=align_on)
+
+    def interp_calendar(self, target_calendar, use_cftime=None):
+        """Interpolate the data to another calendar.
+
+        Parameters
+        ----------
+        target_calendar : str
+            The target calendar.
+        use_cftime : bool or None, optional
+            Whether to use cftime for the output.
+
+        Returns
+        -------
+        Dataset
+            A new Dataset with the data interpolated to the target calendar.
+        """
+        from xarray.coding.calendar_ops import interp_calendar
+        return interp_calendar(self, target_calendar, use_cftime=use_cftime)
