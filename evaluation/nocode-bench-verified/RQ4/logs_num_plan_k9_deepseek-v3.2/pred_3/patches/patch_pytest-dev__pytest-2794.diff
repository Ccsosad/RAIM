diff --git a/_pytest/logging.py b/_pytest/logging.py
new file mode 100644
index 0000000..9deca0d
--- /dev/null
+++ b/_pytest/logging.py
@@ -0,0 +1,265 @@
+# -*- coding: utf-8 -*-
+"""Logging support for pytest."""
+import logging
+import sys
+import warnings
+from contextlib import contextmanager
+
+import py
+import six
+
+import pytest
+from _pytest.config import create_terminal_writer
+from _pytest.fixtures import yield_fixture
+
+
+class LogCaptureHandler(logging.StreamHandler):
+    """A logging handler that stores log records and the log text."""
+
+    def __init__(self):
+        """Initialize the handler."""
+        logging.StreamHandler.__init__(self)
+        self.records = []
+        self.stream = six.StringIO()
+
+    def emit(self, record):
+        """Emit a record."""
+        self.records.append(record)
+        logging.StreamHandler.emit(self, record)
+
+    def reset(self):
+        """Reset the handler."""
+        self.records = []
+        self.stream = six.StringIO()
+
+
+class LogCaptureFixture(object):
+    """Fixture to capture log messages."""
+
+    def __init__(self, item):
+        """Initialize the fixture."""
+        self._item = item
+        self._initial_handler_level = None
+        self._initial_logger_levels = {}  # type: dict
+
+    @property
+    def handler(self):
+        """Get the log capture handler."""
+        return self._item.catch_log_handler
+
+    @property
+    def records(self):
+        """Get the list of log records."""
+        return self.handler.records
+
+    @property
+    def record_tuples(self):
+        """Get a list of a stripped down version of log records intended
+        for use in assertion comparison."""
+        return [(r.name, r.levelno, r.getMessage()) for r in self.records]
+
+    @property
+    def text(self):
+        """Get the formatted log text."""
+        return self.handler.stream.getvalue()
+
+    def set_level(self, level, logger=None):
+        """Set the threshold level of the handler or logger for the test."""
+        if logger is None:
+            self.handler.setLevel(level)
+        else:
+            logger = logging.getLogger(logger)
+            self._initial_logger_levels.setdefault(logger, logger.level)
+            logger.setLevel(level)
+
+    @contextmanager
+    def at_level(self, level, logger=None):
+        """Context manager to set the log level temporarily."""
+        if logger is None:
+            logger = self.handler
+            old_level = logger.level
+            logger.setLevel(level)
+            try:
+                yield
+            finally:
+                logger.setLevel(old_level)
+        else:
+            logger_obj = logging.getLogger(logger)
+            old_level = logger_obj.level
+            logger_obj.setLevel(level)
+            try:
+                yield
+            finally:
+                logger_obj.setLevel(old_level)
+
+    def clear(self):
+        """Clear the captured log records and the log text."""
+        self.handler.reset()
+
+
+@pytest.fixture
+def caplog(request):
+    """Access and control log capturing."""
+    if hasattr(request.node, 'catch_log_handler'):
+        return LogCaptureFixture(request.node)
+    else:
+        # This shouldn't happen if the plugin is active
+        raise RuntimeError("Log capture fixture is not available")
+
+
+def pytest_addoption(parser):
+    """Add options to control log capturing."""
+    group = parser.getgroup('logging')
+    group.addoption(
+        '--no-print-logs',
+        dest='log_print',
+        action='store_false',
+        default=True,
+        help='Disable printing captured logs on failed tests.'
+    )
+    group.addoption(
+        '--log-level',
+        dest='log_level',
+        default=None,
+        help='Set the log level for the root logger.'
+    )
+    group.addoption(
+        '--log-format',
+        dest='log_format',
+        default='%(levelname)-8s %(name)s %(message)s',
+        help='Log format used by the logging module.'
+    )
+    group.addoption(
+        '--log-date-format',
+        dest='log_date_format',
+        default=None,
+        help='Log date format used by the logging module.'
+    )
+    group.addoption(
+        '--log-cli-level',
+        dest='log_cli_level',
+        default=None,
+        help='Set the log level for the console logger.'
+    )
+    group.addoption(
+        '--log-cli-format',
+        dest='log_cli_format',
+        default=None,
+        help='Log format used by the console logger.'
+    )
+    group.addoption(
+        '--log-cli-date-format',
+        dest='log_cli_date_format',
+        default=None,
+        help='Log date format used by the console logger.'
+    )
+    group.addoption(
+        '--log-file',
+        dest='log_file',
+        default=None,
+        help='Path to a file where logs will be written.'
+    )
+    group.addoption(
+        '--log-file-level',
+        dest='log_file_level',
+        default=None,
+        help='Set the log level for the file logger.'
+    )
+    group.addoption(
+        '--log-file-format',
+        dest='log_file_format',
+        default=None,
+        help='Log format used by the file logger.'
+    )
+    group.addoption(
+        '--log-file-date-format',
+        dest='log_file_date_format',
+        default=None,
+        help='Log date format used by the file logger.'
+    )
+
+
+def pytest_configure(config):
+    """Configure the logging plugin."""
+    # Register the plugin
+    config.pluginmanager.register(LoggingPlugin(config), 'logging-plugin')
+
+
+class LoggingPlugin(object):
+    """Logging plugin for pytest."""
+
+    def __init__(self, config):
+        """Initialize the plugin."""
+        self.config = config
+        self.log_level = getattr(config.option, 'log_level', None)
+        self.log_format = getattr(config.option, 'log_format', None)
+        self.log_date_format = getattr(config.option, 'log_date_format', None)
+        self.log_print = getattr(config.option, 'log_print', True)
+        self.log_cli_level = getattr(config.option, 'log_cli_level', None)
+        self.log_cli_format = getattr(config.option, 'log_cli_format', None)
+        self.log_cli_date_format = getattr(config.option, 'log_cli_date_format', None)
+        self.log_file = getattr(config.option, 'log_file', None)
+        self.log_file_level = getattr(config.option, 'log_file_level', None)
+        self.log_file_format = getattr(config.option, 'log_file_format', None)
+        self.log_file_date_format = getattr(config.option, 'log_file_date_format', None)
+
+        # Set up logging capture
+        self.log_capture_handler = None
+
+    def pytest_runtest_setup(self, item):
+        """Set up log capturing for a test item."""
+        # Create a log capture handler for this test
+        handler = LogCaptureHandler()
+        self.log_capture_handler = handler
+        item.catch_log_handler = handler
+
+        # Configure the handler
+        if self.log_format:
+            formatter = logging.Formatter(
+                fmt=self.log_format,
+                datefmt=self.log_date_format
+            )
+            handler.setFormatter(formatter)
+
+        # Add the handler to the root logger
+        logging.getLogger().addHandler(handler)
+
+        # Set the log level if specified
+        if self.log_level:
+            level = getattr(logging, self.log_level.upper(), None)
+            if level is None:
+                # Try to parse as integer
+                try:
+                    level = int(self.log_level)
+                except ValueError:
+                    pass
+            if isinstance(level, int):
+                handler.setLevel(level)
+
+    def pytest_runtest_teardown(self, item, nextitem):
+        """Tear down log capturing for a test item."""
+        handler = getattr(item, 'catch_log_handler', None)
+        if handler:
+            # Remove the handler from the root logger
+            logging.getLogger().removeHandler(handler)
+            del item.catch_log_handler
+
+    def pytest_runtest_logreport(self, report):
+        """Add captured logs to the report if the test failed."""
+        if report.failed and self.log_print:
+            handler = getattr(report, 'catch_log_handler', None)
+            if handler and handler.records:
+                # Add the captured logs to the report
+                section_name = 'Captured stdlog call'
+                if not hasattr(report, 'sections'):
+                    report.sections = []
+                report.sections.append((section_name, handler.stream.getvalue()))
+
+    @pytest.mark.tryfirst
+    def pytest_runtest_makereport(self, item, call):
+        """Make the test report and attach the log handler."""
+        # Store the log handler on the report for use in logreport
+        if call.when == 'call':
+            report = item._report
+            if hasattr(item, 'catch_log_handler'):
+                report.catch_log_handler = item.catch_log_handler
