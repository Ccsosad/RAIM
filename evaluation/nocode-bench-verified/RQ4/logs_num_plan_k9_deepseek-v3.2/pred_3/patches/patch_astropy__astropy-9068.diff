diff --git a/astropy/table/table.py b/astropy/table/table.py
index d713a3b..818bbaf 100644
--- a/astropy/table/table.py
+++ b/astropy/table/table.py
@@ -3024,6 +3024,68 @@ class Table:
     def __ne__(self, other):
         return ~self.__eq__(other)
 
+    def values_equal(self, other):
+        """
+        Compare table values element-wise to another table, array, or scalar.
+
+        Parameters
+        ----------
+        other : Table, array-like, or scalar
+            The object to compare with.
+
+        Returns
+        -------
+        equal : Table
+            A new table with the same column names and length as the original table,
+            with boolean values indicating element-wise equality.
+
+        Raises
+        ------
+        ValueError
+            If `other` is a Table and the column names do not match.
+        """
+        from astropy.table import Table
+
+        if isinstance(other, Table):
+            # Check column names
+            if set(self.colnames) != set(other.colnames):
+                raise ValueError('cannot compare tables with different column names')
+            # Create a new table with boolean columns
+            out_cols = []
+            for name in self.colnames:
+                col_self = self[name]
+                col_other = other[name]
+                # Use the == operator for element-wise comparison
+                equal = (col_self == col_other)
+                # If the column is a MaskedColumn, we need to handle masks.
+                # We want a plain boolean array. Convert masked values to False.
+                if hasattr(equal, 'filled'):
+                    equal = equal.filled(False)
+                # Create a Column with the result
+                out_cols.append(self.Column(name=name, data=equal))
+            return Table(out_cols, copy=False)
+        elif np.isscalar(other):
+            # Compare each column to the scalar
+            out_cols = []
+            for col in self.itercols():
+                equal = (col == other)
+                if hasattr(equal, 'filled'):
+                    equal = equal.filled(False)
+                out_cols.append(self.Column(name=col.info.name, data=equal))
+            return Table(out_cols, copy=False)
+        else:
+            # Assume other is an array-like with length equal to number of columns
+            other = np.asarray(other)
+            if len(other) != len(self.columns):
+                raise ValueError('Length of array must match number of columns')
+            out_cols = []
+            for col, val in zip(self.itercols(), other):
+                equal = (col == val)
+                if hasattr(equal, 'filled'):
+                    equal = equal.filled(False)
+                out_cols.append(self.Column(name=col.info.name, data=equal))
+            return Table(out_cols, copy=False)
+
     @property
     def groups(self):
         if not hasattr(self, '_groups'):
