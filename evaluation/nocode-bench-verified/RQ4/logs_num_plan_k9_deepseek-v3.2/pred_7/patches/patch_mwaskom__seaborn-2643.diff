diff --git a/seaborn/axisgrid.py b/seaborn/axisgrid.py
index c1f490d..c6f86a3 100644
--- a/seaborn/axisgrid.py
+++ b/seaborn/axisgrid.py
@@ -248,6 +248,117 @@ class Grid(_BaseGrid):
             return None
 
 
+def move_legend(obj, loc, **kwargs):
+    """
+    Recreate a plot's legend in a new location or with new properties.
+    
+    Parameters
+    ----------
+    obj : matplotlib.axes.Axes or seaborn.axisgrid.FacetGrid
+        The object with the legend to move.
+    loc : str or int
+        The new location for the legend. See :meth:`matplotlib.axes.Axes.legend`.
+    **kwargs
+        Additional keyword arguments are passed to the underlying legend method.
+        
+    Returns
+    -------
+    self : matplotlib.axes.Axes or seaborn.axisgrid.FacetGrid
+        Returns the input object for easy chaining.
+        
+    Notes
+    -----
+    This function should be preferred over calling `ax.legend` with no legend
+    data, which does not reliably work across seaborn plot types.
+    
+    """
+    # Check if the object is a FacetGrid
+    if hasattr(obj, "_legend") and hasattr(obj, "add_legend"):
+        # It's a FacetGrid or similar
+        return _move_legend_grid(obj, loc, **kwargs)
+    else:
+        # Assume it's an Axes
+        return _move_legend_ax(obj, loc, **kwargs)
+
+
+def _move_legend_ax(ax, loc, **kwargs):
+    """Move legend on a single matplotlib Axes."""
+    if ax.legend_ is None:
+        # No legend exists
+        return ax
+    
+    # Get the current legend data
+    legend = ax.legend_
+    handles = legend.legendHandles
+    labels = [t.get_text() for t in legend.texts]
+    title = legend.get_title().get_text()
+    
+    # Remove the old legend
+    legend.remove()
+    ax.legend_ = None
+    
+    # Create new legend with updated location
+    new_legend = ax.legend(handles, labels, loc=loc, **kwargs)
+    if title:
+        new_legend.set_title(title)
+    
+    return ax
+
+
+def _move_legend_grid(grid, loc, **kwargs):
+    """Move legend on a FacetGrid."""
+    if grid._legend is None:
+        # No legend exists
+        return grid
+    
+    # Get the current legend data
+    legend = grid._legend
+    handles = legend.legendHandles
+    labels = [t.get_text() for t in legend.texts]
+    title = legend.get_title().get_text()
+    
+    # Remove the old legend
+    legend.remove()
+    grid._legend = None
+    
+    # Check if we need to adjust the figure layout
+    bbox_to_anchor = kwargs.pop("bbox_to_anchor", None)
+    
+    if bbox_to_anchor is not None or not grid._legend_out:
+        # For external legends with bbox_to_anchor or internal legends,
+        # we need to create a new figure legend
+        new_legend = grid._figure.legend(handles, labels, loc=loc, 
+                                         bbox_to_anchor=bbox_to_anchor, **kwargs)
+        if title:
+            new_legend.set_title(title)
+        grid._legend = new_legend
+        
+        # Update the layout if needed
+        if grid._legend_out and bbox_to_anchor is None:
+            # Standard external legend - adjust figure size
+            _draw_figure(grid._figure)
+            legend_width = new_legend.get_window_extent().width / grid._figure.dpi
+            fig_width, fig_height = grid._figure.get_size_inches()
+            grid._figure.set_size_inches(fig_width + legend_width, fig_height)
+            _draw_figure(grid._figure)
+            legend_width = new_legend.get_window_extent().width / grid._figure.dpi
+            space_needed = legend_width / (fig_width + legend_width)
+            margin = .04 if grid._margin_titles else .01
+            grid._space_needed = margin + space_needed
+            right = 1 - grid._space_needed
+            grid._figure.subplots_adjust(right=right)
+            grid._tight_layout_rect[2] = right
+    else:
+        # Internal legend on first axes
+        ax = grid.axes.flat[0]
+        new_legend = ax.legend(handles, labels, loc=loc, **kwargs)
+        if title:
+            new_legend.set_title(title)
+        grid._legend = new_legend
+    
+    return grid
+
+
 _facet_docs = dict(
 
     data=dedent("""\
