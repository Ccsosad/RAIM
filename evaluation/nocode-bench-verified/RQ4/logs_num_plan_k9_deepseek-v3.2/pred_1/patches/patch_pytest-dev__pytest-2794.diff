diff --git a/_pytest/config/__init__.py b/_pytest/config/__init__.py
new file mode 100644
index 0000000..da657ba
--- /dev/null
+++ b/_pytest/config/__init__.py
@@ -0,0 +1,82 @@
+import logging
+import warnings
+
+def pytest_addoption(parser):
+    group = parser.getgroup("logging")
+    group.addoption(
+        "--log-level",
+        dest="log_level",
+        default=None,
+        help="logging level used by the logging module"
+    )
+    group.addoption(
+        "--log-format",
+        dest="log_format",
+        default="%(levelname)-8s %(name)s %(message)s",
+        help="log format as used by the logging module"
+    )
+    group.addoption(
+        "--log-date-format",
+        dest="log_date_format",
+        default=None,
+        help="log date format as used by the logging module"
+    )
+    group.addoption(
+        "--log-cli-level",
+        dest="log_cli_level",
+        default=None,
+        help="cli logging level"
+    )
+    group.addoption(
+        "--log-cli-format",
+        dest="log_cli_format",
+        default=None,
+        help="log format for cli"
+    )
+    group.addoption(
+        "--log-cli-date-format",
+        dest="log_cli_date_format",
+        default=None,
+        help="log date format for cli"
+    )
+    group.addoption(
+        "--log-file",
+        dest="log_file",
+        default=None,
+        help="path to a file when logging will be written to"
+    )
+    group.addoption(
+        "--log-file-level",
+        dest="log_file_level",
+        default=None,
+        help="log file logging level"
+    )
+    group.addoption(
+        "--log-file-format",
+        dest="log_file_format",
+        default=None,
+        help="log format for log file"
+    )
+    group.addoption(
+        "--log-file-date-format",
+        dest="log_file_date_format",
+        default=None,
+        help="log date format for log file"
+    )
+    group.addoption(
+        "--no-print-logs",
+        dest="log_print",
+        action="store_false",
+        default=True,
+        help="disable printing captured logs on failed tests"
+    )
+
+def pytest_configure(config):
+    if config.getoption("log_level") is not None:
+        warnings.warn(
+            "--log-level is deprecated and will be removed in a future release. "
+            "Please use --log-cli-level instead.",
+            DeprecationWarning
+        )
+        if config.getoption("log_cli_level") is None:
+            config.option.log_cli_level = config.getoption("log_level")
diff --git a/_pytest/logging.py b/_pytest/logging.py
new file mode 100644
index 0000000..130b7a5
--- /dev/null
+++ b/_pytest/logging.py
@@ -0,0 +1,136 @@
+import logging
+import io
+import contextlib
+from _pytest import fixtures
+
+class LogCaptureHandler(logging.Handler):
+    def __init__(self):
+        logging.Handler.__init__(self)
+        self.records = []
+        self.stream = io.StringIO()
+
+    def emit(self, record):
+        self.records.append(record)
+        msg = self.format(record)
+        self.stream.write(msg + '\n')
+
+    def reset(self):
+        self.records = []
+        self.stream = io.StringIO()
+
+    def clear(self):
+        self.reset()
+
+    def get_records(self, levelname):
+        return [r for r in self.records if r.levelname == levelname]
+
+    @property
+    def text(self):
+        return self.stream.getvalue()
+
+    @property
+    def record_tuples(self):
+        return [(r.name, r.levelno, r.getMessage()) for r in self.records]
+
+class LogCaptureFixture:
+    def __init__(self, handler):
+        self.handler = handler
+        self._initial_levels = {}
+
+    def set_level(self, level, logger=None):
+        if logger is None:
+            logger = self.handler
+        if isinstance(level, str):
+            level = getattr(logging, level.upper())
+        if isinstance(logger, str):
+            logger = logging.getLogger(logger)
+        self._initial_levels[logger] = logger.level
+        logger.setLevel(level)
+
+    def at_level(self, level, logger=None):
+        return _LogCaptureContextManager(self, level, logger)
+
+    @property
+    def records(self):
+        return self.handler.records
+
+    @property
+    def text(self):
+        return self.handler.text
+
+    @property
+    def record_tuples(self):
+        return self.handler.record_tuples
+
+    def clear(self):
+        self.handler.clear()
+
+    def get_records(self, levelname):
+        return self.handler.get_records(levelname)
+
+class _LogCaptureContextManager:
+    def __init__(self, fixture, level, logger):
+        self.fixture = fixture
+        self.level = level
+        self.logger = logger
+        self.old_level = None
+
+    def __enter__(self):
+        if self.logger is None:
+            self.logger = self.fixture.handler
+        if isinstance(self.logger, str):
+            self.logger = logging.getLogger(self.logger)
+        self.old_level = self.logger.level
+        self.fixture.set_level(self.level, self.logger)
+        return self
+
+    def __exit__(self, *args):
+        self.logger.setLevel(self.old_level)
+
+def pytest_addoption(parser):
+    # This is already defined in config/__init__.py, but we keep it for compatibility
+    pass
+
+def pytest_configure(config):
+    # Setup logging capture
+    if not hasattr(config, 'log_capture_handler'):
+        handler = LogCaptureHandler()
+        config.log_capture_handler = handler
+        logging.root.addHandler(handler)
+        # Set default level to logging.NOTSET to capture all logs
+        handler.setLevel(logging.NOTSET)
+
+def pytest_unconfigure(config):
+    handler = getattr(config, 'log_capture_handler', None)
+    if handler is not None:
+        logging.root.removeHandler(handler)
+        del config.log_capture_handler
+
+@fixtures.fixture
+def caplog(request):
+    handler = request.config.log_capture_handler
+    if handler is None:
+        # This should not happen if plugin is properly configured
+        raise RuntimeError("Log capture handler is not available")
+    fixture = LogCaptureFixture(handler)
+    # Reset the handler for this test
+    handler.reset()
+    return fixture
+
+def pytest_runtest_setup(item):
+    # Reset the log capture handler at the start of each test
+    handler = getattr(item.config, 'log_capture_handler', None)
+    if handler is not None:
+        handler.reset()
+
+def pytest_runtest_makereport(item, call):
+    handler = getattr(item.config, 'log_capture_handler', None)
+    if handler is not None and call.when == 'call' and call.excinfo is not None:
+        # Test failed, capture logs
+        if item.config.getoption("log_print", True):
+            # Add the captured logs to the report
+            log = handler.text
+            if log:
+                # Add a section for captured logs
+                if hasattr(call, 'sections'):
+                    call.sections.append(("Captured stdlog call", log))
