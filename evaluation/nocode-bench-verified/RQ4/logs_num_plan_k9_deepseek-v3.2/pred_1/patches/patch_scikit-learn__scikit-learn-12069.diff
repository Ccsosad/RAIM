diff --git a/sklearn/decomposition/_kernel_pca.py b/sklearn/decomposition/_kernel_pca.py
index 6f0266a..4846b80 100644
--- a/sklearn/decomposition/_kernel_pca.py
+++ b/sklearn/decomposition/_kernel_pca.py
@@ -147,7 +147,8 @@ class KernelPCA(TransformerMixin, BaseEstimator):
                  gamma=None, degree=3, coef0=1, kernel_params=None,
                  alpha=1.0, fit_inverse_transform=False, eigen_solver='auto',
                  tol=0, max_iter=None, remove_zero_eig=False,
-                 random_state=None, copy_X=True, n_jobs=None):
+                 random_state=None, copy_X=True, n_jobs=None,
+                 n_oversamples=10):
         if fit_inverse_transform and kernel == 'precomputed':
             raise ValueError(
                 "Cannot fit_inverse_transform with a precomputed kernel.")
@@ -166,6 +167,7 @@ class KernelPCA(TransformerMixin, BaseEstimator):
         self.random_state = random_state
         self.n_jobs = n_jobs
         self.copy_X = copy_X
+        self.n_oversamples = n_oversamples
 
     # TODO: Remove in 1.1
     # mypy error: Decorated property not supported
@@ -215,6 +217,48 @@ class KernelPCA(TransformerMixin, BaseEstimator):
                                                 tol=self.tol,
                                                 maxiter=self.max_iter,
                                                 v0=v0)
+        elif eigen_solver == 'randomized':
+            from ..utils.extmath import randomized_svd
+            # Note: randomized_svd returns U, S, Vt.
+            # Since K is symmetric and positive semidefinite, we can use U as eigenvectors.
+            # The eigenvalues are S, because K = U @ diag(S) @ U.T.
+            # We need to compute the top n_components eigenvalues and eigenvectors.
+            # The randomized_svd function requires n_components <= min(K.shape) - 1.
+            # But we already have n_components <= K.shape[0].
+            # We add n_oversamples to improve accuracy.
+            n_randomized = min(n_components + self.n_oversamples, K.shape[0] - 1)
+            if n_randomized < n_components:
+                n_randomized = n_components
+            U, S, _ = randomized_svd(K, n_components=n_randomized,
+                                     n_iter='auto',
+                                     random_state=self.random_state)
+            # Truncate to the desired number of components.
+            self.lambdas_ = S[:n_components]
+            self.alphas_ = U[:, :n_components]
+        elif eigen_solver == 'randomized':
+            from ..utils.extmath import randomized_svd
+            # Note: randomized_svd returns U, S, Vt.
+            # Since K is symmetric and positive semidefinite, we can use U as eigenvectors.
+            # The eigenvalues are S, because K = U @ diag(S) @ U.T.
+            # We need to compute the top n_components eigenvalues and eigenvectors.
+            # The randomized_svd function requires n_components <= min(K.shape) - 1.
+            # But we already have n_components <= K.shape[0].
+            # We add n_oversamples to improve accuracy.
+            if n_components >= K.shape[0]:
+                # If n_components is equal to the number of samples, we cannot use randomized.
+                # Fall back to dense.
+                self.lambdas_, self.alphas_ = linalg.eigh(
+                    K, eigvals=(K.shape[0] - n_components, K.shape[0] - 1))
+            else:
+                n_randomized = min(n_components + self.n_oversamples, K.shape[0] - 1)
+                if n_randomized < n_components:
+                    n_randomized = n_components
+                U, S, _ = randomized_svd(K, n_components=n_randomized,
+                                         n_iter='auto',
+                                         random_state=self.random_state)
+                # Truncate to the desired number of components.
+                self.lambdas_ = S[:n_components]
+                self.alphas_ = U[:, :n_components]
 
         # make sure that the eigenvalues are ok and fix numerical issues
         self.lambdas_ = _check_psd_eigenvalues(self.lambdas_,
@@ -388,4 +432,4 @@ class KernelPCA(TransformerMixin, BaseEstimator):
 
     def _more_tags(self):
         return {'preserves_dtype': [np.float64, np.float32],
-                'pairwise': self.kernel == 'precomputed'}
+                'pairwise': self.kernel == 'precomputed'}
