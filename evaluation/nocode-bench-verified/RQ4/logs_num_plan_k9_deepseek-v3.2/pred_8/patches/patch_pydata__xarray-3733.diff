diff --git a/xarray/core/dataarray.py b/xarray/core/dataarray.py
index f1d3d53..ecf66b3 100644
--- a/xarray/core/dataarray.py
+++ b/xarray/core/dataarray.py
@@ -3202,6 +3202,43 @@ class DataArray(AbstractArray, DataWithCoords):
         ds = self._to_temp_dataset().integrate(dim, datetime_unit)
         return self._from_temp_dataset(ds)
 
+    def polyfit(
+        self,
+        dim: Hashable,
+        deg: int,
+        full: bool = False,
+        cov: bool = False,
+        **kwargs,
+    ) -> "Dataset":
+        """
+        Least squares polynomial fit.
+
+        Parameters
+        ----------
+        dim : str
+            Dimension along which to fit the polynomial.
+        deg : int
+            Degree of the polynomial.
+        full : bool, optional
+            Whether to return additional information.
+        cov : bool or str, optional
+            Whether to return the covariance matrix.
+        **kwargs : dict
+            Additional arguments passed to numpy.polyfit.
+
+        Returns
+        -------
+        Dataset
+            Dataset containing the coefficients and optionally additional information.
+
+        See Also
+        --------
+        xarray.polyval
+        numpy.polyfit
+        """
+        from .polyfit import polyfit as _polyfit
+        return _polyfit(self, dim, deg, full=full, cov=cov, **kwargs)
+
     def unify_chunks(self) -> "DataArray":
         """ Unify chunk size along all chunked dimensions of this DataArray.
 
@@ -3449,4 +3486,4 @@ class DataArray(AbstractArray, DataWithCoords):
 
 
 # priority most be higher than Variable to properly work with binary ufuncs
-ops.inject_all_ops_and_reduce_methods(DataArray, priority=60)
+ops.inject_all_ops_and_reduce_methods(DataArray, priority=60)
diff --git a/xarray/core/dataset.py b/xarray/core/dataset.py
index 16f0e97..2a139be 100644
--- a/xarray/core/dataset.py
+++ b/xarray/core/dataset.py
@@ -5483,6 +5483,54 @@ class Dataset(Mapping, ImplementsDatasetReduce, DataWithCoords):
             result = result._integrate_one(c, datetime_unit=datetime_unit)
         return result
 
+    def polyfit(
+        self,
+        dim: Hashable,
+        deg: int,
+        full: bool = False,
+        cov: bool = False,
+        **kwargs,
+    ) -> "Dataset":
+        """
+        Least squares polynomial fit for each variable in the dataset.
+
+        Parameters
+        ----------
+        dim : str
+            Dimension along which to fit the polynomial.
+        deg : int
+            Degree of the polynomial.
+        full : bool, optional
+            Whether to return additional information.
+        cov : bool or str, optional
+            Whether to return the covariance matrix.
+        **kwargs : dict
+            Additional arguments passed to numpy.polyfit.
+
+        Returns
+        -------
+        Dataset
+            Dataset containing the coefficients and optionally additional information
+            for each data variable.
+
+        See Also
+        --------
+        DataArray.polyfit
+        xarray.polyval
+        numpy.polyfit
+        """
+        from .polyfit import polyfit as _polyfit
+        # Apply polyfit to each data variable and combine
+        result_datasets = []
+        for name, var in self.data_vars.items():
+            result = _polyfit(var, dim, deg, full=full, cov=cov, **kwargs)
+            # Rename the coefficient variable to avoid conflicts
+            result = result.rename({list(result.data_vars)[0]: name + '_polyfit_coefficients'})
+            result_datasets.append(result)
+        # Merge all results
+        from .merge import merge
+        return merge(result_datasets)
+
     def _integrate_one(self, coord, datetime_unit=None):
         from .variable import Variable
 
@@ -5915,4 +5963,4 @@ class Dataset(Mapping, ImplementsDatasetReduce, DataWithCoords):
         return self._replace_vars_and_dims(variables)
 
 
-ops.inject_all_ops_and_reduce_methods(Dataset, array_only=False)
+ops.inject_all_ops_and_reduce_methods(Dataset, array_only=False)
diff --git a/xarray/core/polyfit.py b/xarray/core/polyfit.py
new file mode 100644
index 0000000..43b6675
--- /dev/null
+++ b/xarray/core/polyfit.py
@@ -0,0 +1,302 @@
+"""
+Polynomial fitting for xarray objects.
+"""
+import numpy as np
+import pandas as pd
+from . import duck_array_ops
+from .common import _contains_datetime_like_objects
+from .computation import dot
+from .utils import is_scalar
+from .variable import Variable, IndexVariable
+
+def _least_squares(lhs, rhs, rcond=None):
+    """
+    Return the coefficients and additional statistics for a linear least squares
+    fit of rhs to lhs.
+
+    Parameters
+    ----------
+    lhs : array_like
+        Left hand side matrix, 2-D array.
+    rhs : array_like
+        Right hand side vector or matrix.
+    rcond : float, optional
+        Cut-off ratio for small singular values.
+
+    Returns
+    -------
+    coefficients : ndarray
+        Least squares solution.
+    residuals : ndarray
+        Sums of squared residuals.
+    rank : int
+        Rank of lhs.
+    singular_values : ndarray
+        Singular values of lhs.
+    """
+    # Use numpy's lstsq if available
+    return np.linalg.lstsq(lhs, rhs, rcond=rcond)
+
+def _polyfit(x, y, deg, rcond=None, full=False, w=None, cov=False):
+    """
+    Base polynomial fit function similar to numpy.polyfit.
+
+    Parameters
+    ----------
+    x : array_like
+        x-coordinates of the points.
+    y : array_like
+        y-coordinates of the points.
+    deg : int
+        Degree of the polynomial.
+    rcond : float, optional
+        Relative condition number.
+    full : bool, optional
+        Whether to return additional information.
+    w : array_like, optional
+        Weights.
+    cov : bool or str, optional
+        Whether to return the covariance matrix.
+
+    Returns
+    -------
+    coefficients : ndarray
+        Polynomial coefficients.
+    [residuals, rank, singular_values, rcond] : list, optional
+        Additional information if full is True.
+    V : ndarray, optional
+        Covariance matrix if cov is True.
+    """
+    # Check arguments
+    if deg < 0:
+        raise ValueError("expected deg >= 0")
+    if x.ndim != 1:
+        raise TypeError("expected 1D vector for x")
+    if y.ndim < 1 or y.ndim > 2:
+        raise TypeError("expected 1D or 2D array for y")
+    if x.shape[0] != y.shape[0]:
+        raise TypeError("expected x and y to have same length")
+
+    # Set rcond
+    if rcond is None:
+        rcond = len(x) * np.finfo(x.dtype).eps
+
+    # Scale x to improve condition number
+    x = np.asarray(x, dtype=float)
+    y = np.asarray(y, dtype=float)
+
+    # Remove NaNs
+    finite = np.isfinite(x) & np.isfinite(y).all(axis=tuple(range(1, y.ndim)))
+    if not finite.all():
+        x = x[finite]
+        y = y[finite]
+
+    # Check for remaining points
+    if len(x) <= deg:
+        raise ValueError("x must have at least deg+1 non-NaN entries")
+
+    # Build the Vandermonde matrix
+    lhs = np.vander(x, deg + 1)
+    if w is not None:
+        w = np.asarray(w, dtype=float)
+        if w.ndim != 1:
+            raise TypeError("expected 1D vector for w")
+        if w.shape[0] != y.shape[0]:
+            raise TypeError("expected w and y to have same length")
+        lhs = lhs * w[:, np.newaxis]
+        rhs = y * w[:, np.newaxis]
+    else:
+        rhs = y
+
+    # Solve the least squares problem
+    c, res, rank, s = _least_squares(lhs, rhs, rcond)
+
+    # Note: we cannot compute the covariance matrix without the residuals
+    # For now, we skip cov if full is False.
+    if cov:
+        # Compute the covariance matrix
+        V = np.dot(lhs.T, lhs)
+        V = np.linalg.inv(V)
+        if full:
+            return c, res, rank, s, V
+        else:
+            return c, V
+    elif full:
+        return c, res, rank, s
+    else:
+        return c
+
+def polyfit(data_array, dim, deg, full=False, cov=False, **kwargs):
+    """
+    Least squares polynomial fit for DataArray.
+
+    Parameters
+    ----------
+    data_array : DataArray
+        Input data.
+    dim : str
+        Dimension along which to fit.
+    deg : int
+        Degree of the polynomial.
+    full : bool, optional
+        Whether to return additional information.
+    cov : bool or str, optional
+        Whether to return the covariance matrix.
+    **kwargs : dict
+        Additional arguments passed to numpy.polyfit.
+
+    Returns
+    -------
+    Dataset
+        Dataset containing the coefficients and optionally additional information.
+    """
+    from .dataset import Dataset
+
+    # Get the coordinate along the dimension
+    if dim not in data_array.dims:
+        raise ValueError(f"dimension {dim} not found in data_array")
+    x = data_array[dim].variable._to_numeric()
+    y = data_array.variable
+
+    # Check if x is 1D
+    if x.ndim != 1:
+        raise ValueError(f"coordinate {dim} must be 1-dimensional")
+
+    # Align x and y along dim
+    # Since x is a coordinate, it should already be aligned.
+    # But we need to make sure they have the same length.
+    if x.shape[0] != y.shape[y.dims.index(dim)]:
+        raise ValueError("x and y must have the same length along dim")
+
+    # Move the fitting dimension to the first axis for convenience
+    dim_pos = y.dims.index(dim)
+    y_transposed = y.transpose(dim, ...)
+    y_data = y_transposed.data
+    x_data = x.data
+
+    # Handle datetime-like coordinates
+    if _contains_datetime_like_objects(x):
+        x_data = x_data.astype(np.float64)
+
+    # Flatten other dimensions
+    original_shape = y_data.shape
+    if y_data.ndim > 1:
+        y_2d = y_data.reshape(original_shape[0], -1)
+    else:
+        y_2d = y_data[:, np.newaxis]
+
+    # Perform the polynomial fit for each column
+    if full or cov:
+        results = [_polyfit(x_data, y_2d[:, i], deg, full=full, cov=cov, **kwargs)
+                   for i in range(y_2d.shape[1])]
+        if cov:
+            if full:
+                coeffs = np.array([r[0] for r in results])
+                residuals = np.array([r[1] for r in results])
+                rank = np.array([r[2] for r in results])
+                singular_values = np.array([r[3] for r in results])
+                cov_matrix = np.array([r[4] for r in results])
+            else:
+                coeffs = np.array([r[0] for r in results])
+                cov_matrix = np.array([r[1] for r in results])
+        else:
+            coeffs = np.array([r[0] for r in results])
+            residuals = np.array([r[1] for r in results])
+            rank = np.array([r[2] for r in results])
+            singular_values = np.array([r[3] for r in results])
+    else:
+        coeffs = np.array([_polyfit(x_data, y_2d[:, i], deg, full=False, cov=False, **kwargs)
+                           for i in range(y_2d.shape[1])])
+
+    # Reshape the coefficients to have the same other dimensions
+    if y_2d.shape[1] > 1:
+        coeff_shape = (deg + 1,) + original_shape[1:]
+        coeffs = coeffs.reshape(coeff_shape)
+        if full and not cov:
+            residuals = residuals.reshape(original_shape[1:])
+            rank = rank.reshape(original_shape[1:])
+            singular_values = singular_values.reshape((min(x_data.shape[0], deg + 1),) + original_shape[1:])
+        elif cov and not full:
+            cov_shape = (deg + 1, deg + 1) + original_shape[1:]
+            cov_matrix = cov_matrix.reshape(cov_shape)
+        elif cov and full:
+            residuals = residuals.reshape(original_shape[1:])
+            rank = rank.reshape(original_shape[1:])
+            singular_values = singular_values.reshape((min(x_data.shape[0], deg + 1),) + original_shape[1:])
+            cov_shape = (deg + 1, deg + 1) + original_shape[1:]
+            cov_matrix = cov_matrix.reshape(cov_shape)
+    else:
+        coeffs = coeffs.flatten()
+        if full and not cov:
+            residuals = residuals.flatten()
+            rank = rank.flatten()
+            singular_values = singular_values.flatten()
+        elif cov and not full:
+            cov_matrix = cov_matrix.reshape(deg + 1, deg + 1)
+        elif cov and full:
+            residuals = residuals.flatten()
+            rank = rank.flatten()
+            singular_values = singular_values.flatten()
+            cov_matrix = cov_matrix.reshape(deg + 1, deg + 1)
+
+    # Create a Dataset for the results
+    coeff_dims = ('degree',) + y_transposed.dims[1:]
+    coeff_var = Variable(coeff_dims, coeffs)
+    result_vars = {'polyfit_coefficients': coeff_var}
+
+    if full and not cov:
+        result_vars['residuals'] = Variable(coeff_dims[1:], residuals)
+        result_vars['rank'] = Variable(coeff_dims[1:], rank)
+        result_vars['singular_values'] = Variable(('singular_values',) + coeff_dims[1:], singular_values)
+    elif cov and not full:
+        result_vars['cov_matrix'] = Variable(('degree', 'degree') + coeff_dims[1:], cov_matrix)
+    elif cov and full:
+        result_vars['residuals'] = Variable(coeff_dims[1:], residuals)
+        result_vars['rank'] = Variable(coeff_dims[1:], rank)
+        result_vars['singular_values'] = Variable(('singular_values',) + coeff_dims[1:], singular_values)
+        result_vars['cov_matrix'] = Variable(('degree', 'degree') + coeff_dims[1:], cov_matrix)
+
+    return Dataset(result_vars)
+
+def polyval(coord, coeffs):
+    """
+    Evaluate a polynomial at specific coordinates.
+
+    Parameters
+    ----------
+    coord : DataArray or Variable
+        Coordinates at which to evaluate the polynomial.
+    coeffs : DataArray or Variable
+        Polynomial coefficients, with the highest degree first.
+
+    Returns
+    -------
+    DataArray
+        Evaluated polynomial.
+    """
+    from .dataarray import DataArray
+
+    # Convert to Variable if necessary
+    if isinstance(coord, DataArray):
+        coord = coord.variable
+    if isinstance(coeffs, DataArray):
+        coeffs = coeffs.variable
+
+    # Check dimensions
+    if 'degree' not in coeffs.dims:
+        raise ValueError("coefficients must have a dimension named 'degree'")
+
+    # Get the degree dimension
+    degree_dim = coeffs.dims.index('degree')
+    degree = coeffs.shape[degree_dim] - 1
+
+    # Convert coord to numeric if it is datetime-like
+    if _contains_datetime_like_objects(coord):
+        coord = coord._to_numeric()
+
+    # Use Horner's method to evaluate the polynomial
+    result = coeffs.isel(degree=0)
+    for i in range(1, degree + 1):
+        result = result * coord + coeffs.isel(degree=i)
+
+    return DataArray(result)
