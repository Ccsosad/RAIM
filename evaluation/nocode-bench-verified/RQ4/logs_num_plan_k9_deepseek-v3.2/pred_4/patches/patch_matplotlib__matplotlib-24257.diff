diff --git a/lib/matplotlib/style/core.py b/lib/matplotlib/style/core.py
index 7b59d49..d26fa9a 100644
--- a/lib/matplotlib/style/core.py
+++ b/lib/matplotlib/style/core.py
@@ -212,6 +212,65 @@ def read_style_directory(style_dir):
     return styles
 
 
+def _load_style_from_package(name):
+    """Load a style sheet from a package.
+
+    Parameters
+    ----------
+    name : str
+        The dotted name of the style, e.g., "mypackage.presentation".
+
+    Returns
+    -------
+    dict
+        The rc parameters.
+
+    Raises
+    ------
+    KeyError
+        If the style cannot be found.
+    """
+    import sys
+    # Split the dotted name into package and style name.
+    parts = name.split('.')
+    if len(parts) < 2:
+        raise KeyError(f"Invalid package style name: {name}")
+    package_name = '.'.join(parts[:-1])
+    style_name = parts[-1]
+
+    # Use importlib.resources to access the file.
+    try:
+        # For Python 3.9+, we use importlib.resources from the standard library.
+        # For older Python, we use the backport (importlib_resources).
+        if sys.version_info >= (3, 9):
+            from importlib.resources import files
+        else:
+            from importlib_resources import files
+    except ImportError:
+        raise KeyError(
+            f"Cannot load style {name!r} because importlib.resources "
+            "is not available. On Python < 3.10, you need to install "
+            "importlib-resources>=3.2.0."
+        ) from None
+
+    try:
+        package = files(package_name)
+    except Exception as e:
+        raise KeyError(
+            f"Cannot find package {package_name!r} for style {name!r}"
+        ) from e
+
+    # Construct the resource path for the style file.
+    resource_path = f"{style_name}.{STYLE_EXTENSION}"
+    try:
+        with package.joinpath(resource_path).open('r', encoding='utf-8') as f:
+            return rc_params_from_file(f, use_default_template=False)
+    except Exception as e:
+        raise KeyError(
+            f"Cannot load style {name!r} from package {package_name!r}"
+        ) from e
+
+
 def update_nested_dict(main_dict, new_dict):
     """
     Update nested dict (only level of nesting) with new values.
