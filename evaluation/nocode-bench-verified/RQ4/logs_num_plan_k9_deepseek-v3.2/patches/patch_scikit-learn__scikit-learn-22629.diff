diff --git a/sklearn/utils/_encode.py b/sklearn/utils/_encode.py
index 38b5c3a..bc961d4 100644
--- a/sklearn/utils/_encode.py
+++ b/sklearn/utils/_encode.py
@@ -1,3 +1,4 @@
+
 from contextlib import suppress
 from collections import Counter
 from typing import NamedTuple
@@ -225,11 +226,36 @@ def _encode(values, *, uniques, check_unknown=True):
         except KeyError as e:
             raise ValueError(f"y contains previously unseen labels: {str(e)}")
     else:
-        if check_unknown:
-            diff = _check_unknown(values, uniques)
-            if diff:
-                raise ValueError(f"y contains previously unseen labels: {str(diff)}")
-        return np.searchsorted(uniques, values)
+        # Special handling for float dtypes with NaN
+        if values.dtype.kind == 'f' and np.any(np.isnan(uniques)):
+            # uniques is sorted with NaN at the end
+            nan_idx = np.where(np.isnan(uniques))[0]
+            if len(nan_idx) > 0:
+                nan_idx = nan_idx[0]
+            else:
+                nan_idx = None
+            # Mask for NaN in values
+            nan_mask = np.isnan(values)
+            # Non-NaN values and uniques
+            non_nan_uniques = uniques[~np.isnan(uniques)]
+            # Check for unknowns in non-NaN values
+            if check_unknown:
+                diff = _check_unknown(values[~nan_mask], non_nan_uniques)
+                if diff:
+                    raise ValueError(f"y contains previously unseen labels: {str(diff)}")
+            # Encode
+            encoded = np.zeros(values.shape, dtype=int)
+            if non_nan_uniques.size > 0:
+                encoded[~nan_mask] = np.searchsorted(non_nan_uniques, values[~nan_mask])
+            if nan_idx is not None:
+                encoded[nan_mask] = nan_idx
+            return encoded
+        else:
+            if check_unknown:
+                diff = _check_unknown(values, uniques)
+                if diff:
+                    raise ValueError(f"y contains previously unseen labels: {str(diff)}")
+            return np.searchsorted(uniques, values)
 
 
 def _check_unknown(values, known_values, return_mask=False):
