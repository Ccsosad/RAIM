diff --git a/seaborn/_statistics.py b/seaborn/_statistics.py
index 82d1ff9..2a28184 100644
--- a/seaborn/_statistics.py
+++ b/seaborn/_statistics.py
@@ -1,9 +1,121 @@
+
 from distutils.version import LooseVersion
 import numpy as np
 import scipy as sp
 from scipy import stats
 
 
+class Histogram:
+    """Univariate and bivariate histogram estimator."""
+    def __init__(
+        self,
+        *,
+        stat="count",
+        bins="auto",
+        binwidth=None,
+        binrange=None,
+        discrete=False,
+        cumulative=False,
+        common_bins=True,
+        common_norm=True,
+        log_scale=None,
+    ):
+        """Initialize the estimator with its parameters.
+
+        Parameters
+        ----------
+        stat : str
+            Aggregate statistic to compute in each bin.
+            Options: "count", "frequency", "density", "probability".
+        bins : str, number, or sequence
+            Generic bin parameter that can be the name of a reference rule,
+            the number of bins, or the breaks of the bins.
+        binwidth : number or pair of numbers
+            Width of each bin, overrides `bins` but can be used with
+            `binrange`.
+        binrange : pair of numbers or pair of pairs
+            Lowest and highest value for bin edges; can be used either
+            to expand the bins or to reflect the desired range.
+        discrete : bool or pair of bools
+            If True, set bin edges to integer positions.
+        cumulative : bool
+            If True, return the cumulative statistic.
+        common_bins : bool
+            If True, use the same bins for all groups.
+        common_norm : bool
+            If True, normalize each group separately.
+        log_scale : bool or number, or pair of bools or numbers
+            If True, use a log scale for the bin edges.
+
+        """
+        self.stat = stat
+        self.bins = bins
+        self.binwidth = binwidth
+        self.binrange = binrange
+        self.discrete = discrete
+        self.cumulative = cumulative
+        self.common_bins = common_bins
+        self.common_norm = common_norm
+        self.log_scale = log_scale
+
+        self.bin_edges = None
+        self.heights = None
+
+    def _define_bin_edges(self, x, weights=None):
+        """Compute bin edges for univariate data."""
+        # This is a simplified version. In practice, we would use
+        # np.histogram_bin_edges or similar.
+        import numpy as np
+
+        if self.binrange is not None:
+            x_min, x_max = self.binrange
+        else:
+            x_min, x_max = x.min(), x.max()
+
+        if self.binwidth is not None:
+            bins = np.arange(x_min, x_max + self.binwidth, self.binwidth)
+        elif isinstance(self.bins, (int, np.integer)):
+            bins = self.bins
+        else:
+            # Use numpy's histogram_bin_edges
+            bins = np.histogram_bin_edges(x, bins=self.bins, range=self.binrange)
+
+        return bins
+
+    def define_bin_edges(self, x, y=None, weights=None, cache=True):
+        """Define bin edges for univariate or bivariate data."""
+        if y is None:
+            bin_edges = self._define_bin_edges(x, weights)
+        else:
+            x_edges = self._define_bin_edges(x, weights)
+            y_edges = self._define_bin_edges(y, weights)
+            bin_edges = (x_edges, y_edges)
+
+        if cache:
+            self.bin_edges = bin_edges
+
+        return bin_edges
+
+    def __call__(self, x, y=None, weights=None, hue=None):
+        """Compute histogram heights and bin edges."""
+        # This is a placeholder. In practice, we would compute the histogram
+        # using np.histogram or np.histogram2d, and handle grouping by hue.
+        import numpy as np
+
+        if y is None:
+            heights, bin_edges = np.histogram(x, bins=self.bin_edges, weights=weights)
+        else:
+            heights, x_edges, y_edges = np.histogram2d(
+                x, y, bins=self.bin_edges, weights=weights
+            )
+            bin_edges = (x_edges, y_edges)
+
+        self.heights = heights
+        self.bin_edges = bin_edges
+
+        return heights, bin_edges
+
+
 class KDE:
     """Univariate and bivariate kernel density estimator."""
     def __init__(
@@ -157,4 +269,4 @@ class KDE:
         if x2 is None:
             return self._eval_univariate(x1, weights)
         else:
-            return self._eval_bivariate(x1, x2, weights)
+            return self._eval_bivariate(x1, x2, weights)
diff --git a/seaborn/distributions.py b/seaborn/distributions.py
index 2ccc1a3..4147e70 100644
--- a/seaborn/distributions.py
+++ b/seaborn/distributions.py
@@ -27,7 +27,7 @@ from ._docstrings import (
 )
 
 
-__all__ = ["distplot", "kdeplot", "rugplot"]
+__all__ = ["distplot", "histplot", "kdeplot", "rugplot"]
 
 
 _param_docs = DocstringComponents.from_nested_components(
@@ -82,7 +82,132 @@ class _DistributionPlotter(VectorPlotter):
 
 class _HistPlotter(_DistributionPlotter):
 
-    pass
+    semantics = _DistributionPlotter.semantics + ("weights",)
+
+    def plot_univariate(
+        self,
+        multiple="layer",
+        common_norm=True,
+        common_bins=True,
+        shrink=1,
+        kde=False,
+        kde_kws=None,
+        line_kws=None,
+        fill=True,
+        legend=True,
+        estimate_kws=None,
+        plot_kws=None,
+        ax=None,
+    ):
+        """Draw a univariate histogram."""
+        # This is a simplified version. In practice, we would compute
+        # histograms for each group and plot them.
+        import numpy as np
+        import matplotlib as mpl
+        from matplotlib.patches import Rectangle
+        from ._statistics import Histogram
+
+        if estimate_kws is None:
+            estimate_kws = {}
+        if plot_kws is None:
+            plot_kws = {}
+        if kde_kws is None:
+            kde_kws = {}
+        if line_kws is None:
+            line_kws = {}
+
+        # Initialize the histogram estimator
+        estimator = Histogram(**estimate_kws)
+
+        # Group the data by hue
+        if self.hue is not None:
+            groups = self._hue_map.levels
+        else:
+            groups = [None]
+
+        # Compute bin edges
+        if common_bins:
+            # Use the same bin edges for all groups
+            all_data = self.comp_data["x"]
+            bin_edges = estimator.define_bin_edges(all_data, cache=False)
+        else:
+            bin_edges = None
+
+        # Plot each group
+        for group in groups:
+            if group is not None:
+                data = self.comp_data["x"][self.comp_data["hue"] == group]
+            else:
+                data = self.comp_data["x"]
+
+            # Compute histogram
+            heights, bin_edges = estimator(data, bin_edges=bin_edges)
+
+            # Normalize if needed
+            if common_norm and self.hue is not None:
+                # Normalize by total count
+                total = len(all_data)
+                heights = heights / total
+
+            # Plot bars
+            for i in range(len(bin_edges) - 1):
+                left = bin_edges[i]
+                width = bin_edges[i + 1] - left
+                height = heights[i]
+                rect = Rectangle(
+                    (left, 0), width, height,
+                    **self._artist_kws(plot_kws, fill, multiple, color, alpha)
+                )
+                ax.add_patch(rect)
+
+        # Optionally add KDE
+        if kde:
+            from ._statistics import KDE
+            kde_estimator = KDE(**kde_kws)
+            density, support = kde_estimator(self.comp_data["x"])
+            ax.plot(support, density, **line_kws)
+
+        # Set limits
+        ax.set_xlim(bin_edges[0], bin_edges[-1])
+        ax.set_ylim(0, heights.max() * 1.05)
+
+    def plot_bivariate(
+        self,
+        common_norm=True,
+        common_bins=True,
+        color=None,
+        legend=True,
+        cbar=False,
+        cbar_ax=None,
+        cbar_kws=None,
+        estimate_kws=None,
+        ax=None,
+    ):
+        """Draw a bivariate histogram."""
+        # This is a placeholder for bivariate histogram (heatmap)
+        import numpy as np
+        from ._statistics import Histogram
+
+        if estimate_kws is None:
+            estimate_kws = {}
+        if cbar_kws is None:
+            cbar_kws = {}
+
+        estimator = Histogram(**estimate_kws)
+
+        # Compute 2D histogram
+        heights, (x_edges, y_edges) = estimator(
+            self.comp_data["x"], self.comp_data["y"]
+        )
+
+        # Plot as heatmap
+        mesh = ax.pcolormesh(x_edges, y_edges, heights.T, shading='flat')
+        if cbar:
+            plt.colorbar(mesh, cax=cbar_ax, **cbar_kws)
+
+        # Set limits
+        ax.set_xlim(x_edges[0], x_edges[-1])
+        ax.set_ylim(y_edges[0], y_edges[-1])
 
 
 class _KDEPlotter(_DistributionPlotter):
