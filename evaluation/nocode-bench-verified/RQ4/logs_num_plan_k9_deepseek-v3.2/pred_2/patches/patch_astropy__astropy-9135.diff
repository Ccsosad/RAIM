diff --git a/astropy/modeling/core.py b/astropy/modeling/core.py
index bb1fcca..b01feb9 100644
--- a/astropy/modeling/core.py
+++ b/astropy/modeling/core.py
@@ -2290,6 +2290,204 @@ def _add_special_operator(sop_name, sop):
     SPECIAL_OPERATORS[sop_name] = sop
 
 
+def fix_inputs(model, fixed_inputs):
+    """
+    Fix the value of one or more inputs of a model.
+
+    Parameters
+    ----------
+    model : `~astropy.modeling.Model`
+        The model for which to fix inputs.
+    fixed_inputs : dict
+        A dictionary mapping input names or indices to fixed values.
+
+    Returns
+    -------
+    fixed_model : `~astropy.modeling.Model`
+        A new model with fewer inputs, corresponding to the inputs of the
+        original model that were not fixed.
+
+    Examples
+    --------
+    >>> from astropy.modeling.models import Polynomial2D
+    >>> poly = Polynomial2D(degree=2)
+    >>> fixed_poly = fix_inputs(poly, {'x': 0})
+    >>> fixed_poly.n_inputs
+    1
+    >>> fixed_poly(1)  # evaluates poly at x=0, y=1
+    ...
+    """
+    # Convert fixed_inputs to a mapping from input index to value
+    fixed = {}
+    for key, value in fixed_inputs.items():
+        if isinstance(key, str):
+            if key not in model.inputs:
+                raise ValueError(f"Input {key} is not an input of the model.")
+            idx = model.inputs.index(key)
+        else:
+            idx = key
+        if idx < 0 or idx >= model.n_inputs:
+            raise ValueError(f"Input index {idx} is out of range.")
+        fixed[idx] = value
+
+    # Create a new model class that wraps the original model
+    class _FixedInputModel(Model):
+        def __init__(self, model, fixed):
+            self._model = model
+            self._fixed = fixed
+            # Determine the new inputs
+            self._free_inputs = [i for i in range(model.n_inputs) if i not in fixed]
+            self._input_names = [model.inputs[i] for i in self._free_inputs]
+            self._output_names = model.outputs
+            # Set up the model
+            self._n_inputs = len(self._free_inputs)
+            self._n_outputs = model.n_outputs
+            self._inputs = tuple(self._input_names)
+            self._outputs = tuple(self._output_names)
+            self._param_names = model.param_names
+            # Copy parameters
+            for param_name in self._param_names:
+                setattr(self, param_name, getattr(model, param_name))
+            # Copy other attributes
+            self.linear = model.linear
+            self.fittable = model.fittable
+            # Handle bounding box
+            self._bounding_box = None
+            if model.bounding_box is not None:
+                # Remove the fixed dimensions from the bounding box
+                bbox = model.bounding_box
+                if model.n_inputs == 1:
+                    if 0 in fixed:
+                        # The only input is fixed, so no bounding box
+                        self._bounding_box = None
+                    else:
+                        self._bounding_box = bbox
+                else:
+                    new_bbox = []
+                    for i in range(model.n_inputs):
+                        if i not in fixed:
+                            new_bbox.append(bbox[i])
+                    if new_bbox:
+                        self._bounding_box = tuple(new_bbox)
+                    else:
+                        self._bounding_box = None
+            # Call the parent initializer
+            super().__init__()
+
+        def evaluate(self, *args):
+            # Map the free inputs to the original inputs
+            full_args = [None] * self._model.n_inputs
+            for i, val in zip(self._free_inputs, args):
+                full_args[i] = val
+            for i, val in self._fixed.items():
+                full_args[i] = val
+            # Call the original model
+            return self._model(*full_args)
+
+    return _FixedInputModel(model, fixed)
+
+
+def fix_inputs(model, fixed_inputs):
+    """
+    Fix the value of one or more inputs of a model.
+
+    Parameters
+    ----------
+    model : `~astropy.modeling.Model`
+        The model for which to fix inputs.
+    fixed_inputs : dict
+        A dictionary mapping input names or indices to fixed values.
+
+    Returns
+    -------
+    fixed_model : `~astropy.modeling.Model`
+        A new model with fewer inputs, corresponding to the inputs of the
+        original model that were not fixed.
+
+    Examples
+    --------
+    >>> from astropy.modeling.models import Polynomial2D
+    >>> poly = Polynomial2D(degree=2)
+    >>> fixed_poly = fix_inputs(poly, {'x': 0})
+    >>> fixed_poly.n_inputs
+    1
+    >>> fixed_poly(1)  # evaluates poly at x=0, y=1
+    ...
+    """
+    # Convert fixed_inputs to a mapping from input index to value
+    fixed = {}
+    for key, value in fixed_inputs.items():
+        if isinstance(key, str):
+            if key not in model.inputs:
+                raise ValueError(f"Input {key} is not an input of the model.")
+            idx = model.inputs.index(key)
+        else:
+            idx = key
+        if idx < 0 or idx >= model.n_inputs:
+            raise ValueError(f"Input index {idx} is out of range.")
+        fixed[idx] = value
+
+    # Create a new model class that wraps the original model
+    class _FixedInputModel(Model):
+        def __init__(self, model, fixed):
+            self._model = model
+            self._fixed = fixed
+            # Determine the new inputs
+            self._free_inputs = [i for i in range(model.n_inputs) if i not in fixed]
+            self._input_names = [model.inputs[i] for i in self._free_inputs]
+            self._output_names = model.outputs
+            # Set up the model
+            self._n_inputs = len(self._free_inputs)
+            self._n_outputs = model.n_outputs
+            self._inputs = tuple(self._input_names)
+            self._outputs = tuple(self._output_names)
+            self._param_names = model.param_names
+            # Copy parameters
+            for param_name in self._param_names:
+                setattr(self, param_name, getattr(model, param_name))
+            # Copy other attributes
+            self.linear = model.linear
+            self.fittable = model.fittable
+            # Handle bounding box
+            self._bounding_box = None
+            if model.bounding_box is not None:
+                # Remove the fixed dimensions from the bounding box
+                bbox = model.bounding_box
+                if model.n_inputs == 1:
+                    if 0 in fixed:
+                        # The only input is fixed, so no bounding box
+                        self._bounding_box = None
+                    else:
+                        self._bounding_box = bbox
+                else:
+                    new_bbox = []
+                    for i in range(model.n_inputs):
+                        if i not in fixed:
+                            # Map to bounding box index
+                            bbox_idx = model.n_inputs - 1 - i
+                            new_bbox.append(bbox[bbox_idx])
+                    if new_bbox:
+                        # Reverse back to the bounding box order
+                        new_bbox.reverse()
+                        self._bounding_box = tuple(new_bbox)
+                    else:
+                        self._bounding_box = None
+            # Call the parent initializer
+            super().__init__()
+
+        def evaluate(self, *args):
+            # Map the free inputs to the original inputs
+            full_args = [None] * self._model.n_inputs
+            for i, val in zip(self._free_inputs, args):
+                full_args[i] = val
+            for i, val in self._fixed.items():
+                full_args[i] = val
+            # Call the original model
+            return self._model(*full_args)
+
+    return _FixedInputModel(model, fixed)
+
+
 class CompoundModel(Model):
     '''
     Base class for compound models.
