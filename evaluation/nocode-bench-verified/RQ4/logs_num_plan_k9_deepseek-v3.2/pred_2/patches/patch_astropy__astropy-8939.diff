diff --git a/astropy/table/operations.py b/astropy/table/operations.py
index 5d84827..43d1b6a 100644
--- a/astropy/table/operations.py
+++ b/astropy/table/operations.py
@@ -368,6 +368,70 @@ def hstack(tables, join_type='outer',
     return out
 
 
+def cstack(tables, join_type='outer', metadata_conflicts='warn'):
+    """
+    Stack tables depth-wise (along a third axis)
+
+    A ``join_type`` of 'exact' means that the tables must all have exactly
+    the same column names (though the order can vary).  If ``join_type``
+    is 'inner' then the intersection of common columns will be the output.
+    A value of 'outer' (default) means the output will have the union of
+    all columns, with table values being masked where no common values are
+    available.
+
+    Parameters
+    ----------
+    tables : Table or list of Table objects
+        Table(s) to stack depth-wise with the current table
+    join_type : str
+        Join type ('inner' | 'exact' | 'outer'), default is 'outer'
+    metadata_conflicts : str
+        How to proceed with metadata conflicts. This should be one of:
+            * ``'silent'``: silently pick the last conflicting meta-data value
+            * ``'warn'``: pick the last conflicting meta-data value, but emit a warning (default)
+            * ``'error'``: raise an exception.
+
+    Returns
+    -------
+    stacked_table : `~astropy.table.Table` object
+        New table containing the stacked data from the input tables.
+
+    Examples
+    --------
+    To stack two tables depth-wise do::
+
+      >>> from astropy.table import Table, cstack
+      >>> t1 = Table({'a': [1, 2], 'b': [3, 4]}, names=('a', 'b'))
+      >>> t2 = Table({'a': [5, 6], 'b': [7, 8]}, names=('a', 'b'))
+      >>> print(t1)
+       a   b
+      --- ---
+        1   3
+        2   4
+      >>> print(t2)
+       a   b
+      --- ---
+        5   7
+        6   8
+      >>> print(cstack([t1, t2]))
+       a [2]   b [2]
+      -------- --------
+       1 .. 5  3 .. 7
+       2 .. 6  4 .. 8
+    """
+    tables = _get_list_of_tables(tables)  # validates input
+    if len(tables) == 1:
+        return tables[0]  # no point in stacking a single table
+    col_name_map = OrderedDict()
+
+    out = _cstack(tables, join_type, col_name_map, metadata_conflicts)
+
+    # Merge table metadata
+    _merge_table_meta(out, tables, metadata_conflicts=metadata_conflicts)
+
+    return out
+
+
 def unique(input_table, keys=None, silent=False, keep='first'):
     """
     Returns the unique rows of a table.
@@ -772,9 +836,9 @@ def _join(left, right, keys=None, join_type='inner',
     return out
 
 
-def _vstack(arrays, join_type='outer', col_name_map=None, metadata_conflicts='warn'):
+def _cstack(arrays, join_type='outer', col_name_map=None, metadata_conflicts='warn'):
     """
-    Stack Tables vertically (by rows)
+    Stack Tables depth-wise (along a third axis)
 
     A ``join_type`` of 'exact' (default) means that the arrays must all
     have exactly the same column names (though the order can vary).  If
@@ -786,7 +850,7 @@ def _vstack(arrays, join_type='outer', col_name_map=None, metadata_conflicts='wa
     Parameters
     ----------
     arrays : list of Tables
-        Tables to stack by rows (vertically)
+        Tables to stack depth-wise
     join_type : str
         Join type ('inner' | 'exact' | 'outer'), default is 'outer'
     col_name_map : empty dict or None
@@ -830,47 +894,174 @@ def _vstack(arrays, join_type='outer', col_name_map=None, metadata_conflicts='wa
         if len(col_name_map) == 0:
             raise TableMergeError('Input arrays have no columns in common')
 
-    lens = [len(arr) for arr in arrays]
-    n_rows = sum(lens)
+    # Check that all tables have the same length
+    lengths = [len(arr) for arr in arrays]
+    if len(set(lengths)) > 1:
+        raise ValueError("All input tables must have the same length for depth-wise stacking")
+
+    n_rows = lengths[0]
+    n_tables = len(arrays)
     out = _get_out_class(arrays)()
 
     for out_name, in_names in col_name_map.items():
         # List of input arrays that contribute to this output column
         cols = [arr[name] for arr, name in zip(arrays, in_names) if name is not None]
 
+        # We need to create a new column that stacks the individual columns depth-wise.
+        # The output column should have shape (n_rows, n_tables) for this column.
+        # We'll use the first column's class to create the new column.
         col_cls = _get_out_class(cols)
         if not hasattr(col_cls.info, 'new_like'):
-            raise NotImplementedError('vstack unavailable for mixin column type(s): {}'
+            raise NotImplementedError('cstack unavailable for mixin column type(s): {}'
                                       .format(col_cls.__name__))
+
+        # Create a new column with the appropriate shape and type.
+        # We'll create a list of columns for each table, then stack them.
+        # The new_like method is designed for vstack, so we need to adapt.
+        # Instead, we can create an empty column with the right shape and fill.
+        # Alternatively, we can use the first column as a base and then add the others.
+        # Since the columns are 1D, we want to create a 2D column.
+        # We'll create a new column with n_rows rows and n_tables columns.
+        # We'll use the first column's type and unit, etc.
+
+        # First, create a list of the data arrays from each column.
+        data_list = []
+        for col in cols:
+            # Convert to array, keeping the data type.
+            data = np.asarray(col)
+            data_list.append(data)
+
+        # Stack along a new axis (depth-wise) to get shape (n_rows, n_tables)
+        stacked_data = np.dstack(data_list)[:, 0, :]  # dstack gives (n_rows, 1, n_tables), squeeze the second dimension
+
+        # Create a new column with the stacked data.
+        # We need to create a column of the appropriate class.
+        # Use the first column as a template.
+        first_col = cols[0]
         try:
-            col = col_cls.info.new_like(cols, n_rows, metadata_conflicts, out_name)
-        except metadata.MergeConflictError as err:
-            # Beautify the error message when we are trying to merge columns with incompatible
-            # types by including the name of the columns that originated the error.
-            raise TableMergeError("The '{}' columns have incompatible types: {}"
-                                  .format(out_name, err._incompat_types))
+            # Try to create a new column with the same class and attributes.
+            new_col = col_cls(stacked_data, unit=first_col.unit, dtype=first_col.dtype,
+                              format=first_col.format, description=first_col.description,
+                              meta=first_col.meta)
+        except Exception:
+            # If that fails, fall back to a generic column.
+            new_col = Column(stacked_data, unit=first_col.unit, dtype=first_col.dtype,
+                             format=first_col.format, description=first_col.description,
+                             meta=first_col.meta)
+
+        out[out_name] = new_col
 
-        idx0 = 0
-        for name, array in zip(in_names, arrays):
-            idx1 = idx0 + len(array)
-            if name in array.colnames:
-                col[idx0:idx1] = array[name]
-            else:
-                # If col is a Column but not MaskedColumn then upgrade at this point
-                # because masking is required.
-                if isinstance(col, Column) and not isinstance(col, MaskedColumn):
-                    col = out.MaskedColumn(col, copy=False)
+    # If col_name_map supplied as a dict input, then update.
+    if isinstance(_col_name_map, Mapping):
+        _col_name_map.update(col_name_map)
 
-                try:
-                    col[idx0:idx1] = col.info.mask_val
-                except Exception:
-                    raise NotImplementedError(
-                        "vstack requires masking column '{}' but column"
-                        " type {} does not support masking"
-                        .format(out_name, col.__class__.__name__))
-            idx0 = idx1
+    return out
 
-        out[out_name] = col
+
+def _cstack(arrays, join_type='outer', col_name_map=None, metadata_conflicts='warn'):
+    """
+    Stack Tables depth-wise (along a third axis)
+
+    A ``join_type`` of 'exact' (default) means that the arrays must all
+    have exactly the same column names (though the order can vary).  If
+    ``join_type`` is 'inner' then the intersection of common columns will
+    be the output.  A value of 'outer' means the output will have the union of
+    all columns, with array values being masked where no common values are
+    available.
+
+    Parameters
+    ----------
+    arrays : list of Tables
+        Tables to stack depth-wise
+    join_type : str
+        Join type ('inner' | 'exact' | 'outer'), default is 'outer'
+    col_name_map : empty dict or None
+        If passed as a dict then it will be updated in-place with the
+        mapping of output to input column names.
+
+    Returns
+    -------
+    stacked_table : `~astropy.table.Table` object
+        New table containing the stacked data from the input tables.
+    """
+    # Store user-provided col_name_map until the end
+    _col_name_map = col_name_map
+
+    # Input validation
+    if join_type not in ('inner', 'exact', 'outer'):
+        raise ValueError("`join_type` arg must be one of 'inner', 'exact' or 'outer'")
+
+    # Trivial case of one input array
+    if len(arrays) == 1:
+        return arrays[0]
+
+    # Start by assuming an outer match where all names go to output
+    names = set(itertools.chain(*[arr.colnames for arr in arrays]))
+    col_name_map = get_col_name_map(arrays, names)
+
+    # If require_match is True then the output must have exactly the same
+    # number of columns as each input array
+    if join_type == 'exact':
+        for names in col_name_map.values():
+            if any(x is None for x in names):
+                raise TableMergeError('Inconsistent columns in input arrays '
+                                      "(use 'inner' or 'outer' join_type to "
+                                      "allow non-matching columns)")
+        join_type = 'outer'
+
+    # For an inner join, keep only columns where all input arrays have that column
+    if join_type == 'inner':
+        col_name_map = OrderedDict((name, in_names) for name, in_names in col_name_map.items()
+                                   if all(x is not None for x in in_names))
+        if len(col_name_map) == 0:
+            raise TableMergeError('Input arrays have no columns in common')
+
+    # Check that all tables have the same length
+    lengths = [len(arr) for arr in arrays]
+    if len(set(lengths)) > 1:
+        raise ValueError("All input tables must have the same length for depth-wise stacking")
+
+    n_rows = lengths[0]
+    n_tables = len(arrays)
+    out = _get_out_class(arrays)()
+
+    for out_name, in_names in col_name_map.items():
+        # List of input arrays that contribute to this output column
+        cols = [arr[name] for arr, name in zip(arrays, in_names) if name is not None]
+
+        # We need to create a new column that stacks the individual columns depth-wise.
+        # The output column should have shape (n_rows, n_tables) for this column.
+        # We'll use the first column's class to create the new column.
+        col_cls = _get_out_class(cols)
+        if not hasattr(col_cls.info, 'new_like'):
+            raise NotImplementedError('cstack unavailable for mixin column type(s): {}'
+                                      .format(col_cls.__name__))
+
+        # Create a list of the data arrays from each column.
+        data_list = []
+        for col in cols:
+            # Convert to array, keeping the data type.
+            data = np.asarray(col)
+            data_list.append(data)
+
+        # Stack along a new axis (depth-wise) to get shape (n_rows, n_tables)
+        stacked_data = np.dstack(data_list)[:, 0, :]  # dstack gives (n_rows, 1, n_tables), squeeze the second dimension
+
+        # Create a new column with the stacked data.
+        # Use the first column as a template.
+        first_col = cols[0]
+        try:
+            # Try to create a new column with the same class and attributes.
+            new_col = col_cls(stacked_data, unit=first_col.unit, dtype=first_col.dtype,
+                              format=first_col.format, description=first_col.description,
+                              meta=first_col.meta)
+        except Exception:
+            # If that fails, fall back to a generic column.
+            new_col = Column(stacked_data, unit=first_col.unit, dtype=first_col.dtype,
+                             format=first_col.format, description=first_col.description,
+                             meta=first_col.meta)
+
+        out[out_name] = new_col
 
     # If col_name_map supplied as a dict input, then update.
     if isinstance(_col_name_map, Mapping):
@@ -879,103 +1070,1044 @@ def _vstack(arrays, join_type='outer', col_name_map=None, metadata_conflicts='wa
     return out
 
 
-def _hstack(arrays, join_type='outer', uniq_col_name='{col_name}_{table_name}',
-           table_names=None, col_name_map=None):
+def _cstack(arrays, join_type='outer', col_name_map=None, metadata_conflicts='warn'):
     """
-    Stack tables horizontally (by columns)
+    Stack Tables depth-wise (along a third axis)
 
     A ``join_type`` of 'exact' (default) means that the arrays must all
-    have exactly the same number of rows.  If ``join_type`` is 'inner' then
-    the intersection of rows will be the output.  A value of 'outer' means
-    the output will have the union of all rows, with array values being
-    masked where no common values are available.
+    have exactly the same column names (though the order can vary).  If
+    ``join_type`` is 'inner' then the intersection of common columns will
+    be the output.  A value of 'outer' means the output will have the union of
+    all columns, with array values being masked where no common values are
+    available.
 
     Parameters
     ----------
-    arrays : List of tables
-        Tables to stack by columns (horizontally)
+    arrays : list of Tables
+        Tables to stack depth-wise
     join_type : str
         Join type ('inner' | 'exact' | 'outer'), default is 'outer'
-    uniq_col_name : str or None
-        String generate a unique output column name in case of a conflict.
-        The default is '{col_name}_{table_name}'.
-    table_names : list of str or None
-        Two-element list of table names used when generating unique output
-        column names.  The default is ['1', '2', ..].
+    col_name_map : empty dict or None
+        If passed as a dict then it will be updated in-place with the
+        mapping of output to input column names.
 
     Returns
     -------
     stacked_table : `~astropy.table.Table` object
         New table containing the stacked data from the input tables.
     """
-
     # Store user-provided col_name_map until the end
     _col_name_map = col_name_map
 
     # Input validation
     if join_type not in ('inner', 'exact', 'outer'):
-        raise ValueError("join_type arg must be either 'inner', 'exact' or 'outer'")
-
-    if table_names is None:
-        table_names = ['{}'.format(ii + 1) for ii in range(len(arrays))]
-    if len(arrays) != len(table_names):
-        raise ValueError('Number of arrays must match number of table_names')
+        raise ValueError("`join_type` arg must be one of 'inner', 'exact' or 'outer'")
 
-    # Trivial case of one input arrays
+    # Trivial case of one input array
     if len(arrays) == 1:
         return arrays[0]
 
-    col_name_map = get_col_name_map(arrays, [], uniq_col_name, table_names)
+    # Start by assuming an outer match where all names go to output
+    names = set(itertools.chain(*[arr.colnames for arr in arrays]))
+    col_name_map = get_col_name_map(arrays, names)
 
-    # If require_match is True then all input arrays must have the same length
-    arr_lens = [len(arr) for arr in arrays]
+    # If require_match is True then the output must have exactly the same
+    # number of columns as each input array
     if join_type == 'exact':
-        if len(set(arr_lens)) > 1:
-            raise TableMergeError("Inconsistent number of rows in input arrays "
-                                  "(use 'inner' or 'outer' join_type to allow "
-                                  "non-matching rows)")
+        for names in col_name_map.values():
+            if any(x is None for x in names):
+                raise TableMergeError('Inconsistent columns in input arrays '
+                                      "(use 'inner' or 'outer' join_type to "
+                                      "allow non-matching columns)")
         join_type = 'outer'
 
-    # For an inner join, keep only the common rows
+    # For an inner join, keep only columns where all input arrays have that column
     if join_type == 'inner':
-        min_arr_len = min(arr_lens)
-        if len(set(arr_lens)) > 1:
-            arrays = [arr[:min_arr_len] for arr in arrays]
-        arr_lens = [min_arr_len for arr in arrays]
+        col_name_map = OrderedDict((name, in_names) for name, in_names in col_name_map.items()
+                                   if all(x is not None for x in in_names))
+        if len(col_name_map) == 0:
+            raise TableMergeError('Input arrays have no columns in common')
 
-    # If there are any output rows where one or more input arrays are missing
-    # then the output must be masked.  If any input arrays are masked then
-    # output is masked.
+    # Check that all tables have the same length
+    lengths = [len(arr) for arr in arrays]
+    if len(set(lengths)) > 1:
+        raise ValueError("All input tables must have the same length for depth-wise stacking")
 
-    n_rows = max(arr_lens)
+    n_rows = lengths[0]
+    n_tables = len(arrays)
     out = _get_out_class(arrays)()
 
     for out_name, in_names in col_name_map.items():
-        for name, array, arr_len in zip(in_names, arrays, arr_lens):
-            if name is None:
-                continue
+        # List of input arrays that contribute to this output column
+        cols = [arr[name] for arr, name in zip(arrays, in_names) if name is not None]
 
-            if n_rows > arr_len:
-                indices = np.arange(n_rows)
-                indices[arr_len:] = 0
-                col = array[name][indices]
+        # We need to create a new column that stacks the individual columns depth-wise.
+        # The output column should have shape (n_rows, n_tables) for this column.
+        # We'll use the first column's class to create the new column.
+        col_cls = _get_out_class(cols)
+        if not hasattr(col_cls.info, 'new_like'):
+            raise NotImplementedError('cstack unavailable for mixin column type(s): {}'
+                                      .format(col_cls.__name__))
 
-                # If col is a Column but not MaskedColumn then upgrade at this point
-                # because masking is required.
-                if isinstance(col, Column) and not isinstance(col, MaskedColumn):
-                    col = out.MaskedColumn(col, copy=False)
+        # Create a new column with the appropriate shape and type.
+        # We'll create a list of columns for each table, then stack them.
+        # The new_like method is designed for vstack, so we need to adapt.
+        # Instead, we can create an empty column with the right shape and fill.
+        # Alternatively, we can use the first column as a base and then add the others.
+        # Since the columns are 1D, we want to create a 2D column.
+        # We'll create a new column with n_rows rows and n_tables columns.
+        # We'll use the first column's type and unit, etc.
+
+        # First, create a list of the data arrays from each column.
+        data_list = []
+        for col in cols:
+            # Convert to array, keeping the data type.
+            data = np.asarray(col)
+            data_list.append(data)
+
+        # Stack along a new axis (depth-wise) to get shape (n_rows, n_tables)
+        stacked_data = np.dstack(data_list)[:, 0, :]  # dstack gives (n_rows, 1, n_tables), squeeze the second dimension
+
+        # Create a new column with the stacked data.
+        # We need to create a column of the appropriate class.
+        # Use the first column as a template.
+        first_col = cols[0]
+        try:
+            # Try to create a new column with the same class and attributes.
+            new_col = col_cls(stacked_data, unit=first_col.unit, dtype=first_col.dtype,
+                              format=first_col.format, description=first_col.description,
+                              meta=first_col.meta)
+        except Exception:
+            # If that fails, fall back to a generic column.
+            new_col = Column(stacked_data, unit=first_col.unit, dtype=first_col.dtype,
+                             format=first_col.format, description=first_col.description,
+                             meta=first_col.meta)
+
+        out[out_name] = new_col
 
-                try:
-                    col[arr_len:] = col.info.mask_val
-                except Exception:
-                    raise NotImplementedError(
-                        "hstack requires masking column '{}' but column"
-                        " type {} does not support masking"
-                        .format(out_name, col.__class__.__name__))
-            else:
-                col = array[name][:n_rows]
+    # If col_name_map supplied as a dict input, then update.
+    if isinstance(_col_name_map, Mapping):
+        _col_name_map.update(col_name_map)
 
-            out[out_name] = col
+    return out
+
+
+def _vstack(arrays, join_type='outer', col_name_map=None, metadata_conflicts='warn'):
+    """
+    Stack Tables vertically (by rows)
+
+    A ``join_type`` of 'exact' (default) means that the arrays must all
+    have exactly the same column names (though the order can vary).  If
+    ``join_type`` is 'inner' then the intersection of common columns will
+    be the output.  A value of 'outer' means the output will have the union of
+    all columns, with array values being masked where no common values are
+    available.
+
+    Parameters
+    ----------
+    arrays : list of Tables
+        Tables to stack by rows (vertically)
+    join_type : str
+        Join type ('inner' | 'exact' | 'outer'), default is 'outer'
+    col_name_map : empty dict or None
+        If passed as a dict then it will be updated in-place with the
+        mapping of output to input column names.
+
+    Returns
+    -------
+    stacked_table : `~astropy.table.Table` object
+        New table containing the stacked data from the input tables.
+    """
+    # Store user-provided col_name_map until the end
+    _col_name_map = col_name_map
+
+    # Input validation
+    if join_type not in ('inner', 'exact', 'outer'):
+        raise ValueError("`join_type` arg must be one of 'inner', 'exact' or 'outer'")
+
+    # Trivial case of one input array
+    if len(arrays) == 1:
+        return arrays[0]
+
+    # Start by assuming an outer match where all names go to output
+    names = set(itertools.chain(*[arr.colnames for arr in arrays]))
+    col_name_map = get_col_name_map(arrays, names)
+
+    # If require_match is True then the output must have exactly the same
+    # number of columns as each input array
+    if join_type == 'exact':
+        for names in col_name_map.values():
+            if any(x is None for x in names):
+                raise TableMergeError('Inconsistent columns in input arrays '
+                                      "(use 'inner' or 'outer' join_type to "
+                                      "allow non-matching columns)")
+        join_type = 'outer'
+
+    # For an inner join, keep only columns where all input arrays have that column
+    if join_type == 'inner':
+        col_name_map = OrderedDict((name, in_names) for name, in_names in col_name_map.items()
+                                   if all(x is not None for x in in_names))
+        if len(col_name_map) == 0:
+            raise TableMergeError('Input arrays have no columns in common')
+
+    lens = [len(arr) for arr in arrays]
+    n_rows = sum(lens)
+    out = _get_out_class(arrays)()
+
+    for out_name, in_names in col_name_map.items():
+        # List of input arrays that contribute to this output column
+        cols = [arr[name] for arr, name in zip(arrays, in_names) if name is not None]
+
+        col_cls = _get_out_class(cols)
+        if not hasattr(col_cls.info, 'new_like'):
+            raise NotImplementedError('vstack unavailable for mixin column type(s): {}'
+                                      .format(col_cls.__name__))
+        try:
+            col = col_cls.info.new_like(cols, n_rows, metadata_conflicts, out_name)
+        except metadata.MergeConflictError as err:
+            # Beautify the error message when we are trying to merge columns with incompatible
+            # types by including the name of the columns that originated the error.
+            raise TableMergeError("The '{}' columns have incompatible types: {}"
+                                  .format(out_name, err._incompat_types))
+
+        idx0 = 0
+        for name, array in zip(in_names, arrays):
+            idx1 = idx0 + len(array)
+            if name in array.colnames:
+                col[idx0:idx1] = array[name]
+            else:
+                # If col is a Column but not MaskedColumn then upgrade at this point
+                # because masking is required.
+                if isinstance(col, Column) and not isinstance(col, MaskedColumn):
+                    col = out.MaskedColumn(col, copy=False)
+
+                try:
+                    col[idx0:idx1] = col.info.mask_val
+                except Exception:
+                    raise NotImplementedError(
+                        "vstack requires masking column '{}' but column"
+                        " type {} does not support masking"
+                        .format(out_name, col.__class__.__name__))
+            idx0 = idx1
+
+        out[out_name] = col
+
+    # If col_name_map supplied as a dict input, then update.
+    if isinstance(_col_name_map, Mapping):
+        _col_name_map.update(col_name_map)
+
+    return out
+
+
+def _cstack(arrays, join_type='outer', col_name_map=None, metadata_conflicts='warn'):
+    """
+    Stack Tables depth-wise (along a third axis)
+
+    A ``join_type`` of 'exact' (default) means that the arrays must all
+    have exactly the same column names (though the order can vary).  If
+    ``join_type`` is 'inner' then the intersection of common columns will
+    be the output.  A value of 'outer' means the output will have the union of
+    all columns, with array values being masked where no common values are
+    available.
+
+    Parameters
+    ----------
+    arrays : list of Tables
+        Tables to stack depth-wise
+    join_type : str
+        Join type ('inner' | 'exact' | 'outer'), default is 'outer'
+    col_name_map : empty dict or None
+        If passed as a dict then it will be updated in-place with the
+        mapping of output to input column names.
+
+    Returns
+    -------
+    stacked_table : `~astropy.table.Table` object
+        New table containing the stacked data from the input tables.
+    """
+    # Store user-provided col_name_map until the end
+    _col_name_map = col_name_map
+
+    # Input validation
+    if join_type not in ('inner', 'exact', 'outer'):
+        raise ValueError("`join_type` arg must be one of 'inner', 'exact' or 'outer'")
+
+    # Trivial case of one input array
+    if len(arrays) == 1:
+        return arrays[0]
+
+    # Start by assuming an outer match where all names go to output
+    names = set(itertools.chain(*[arr.colnames for arr in arrays]))
+    col_name_map = get_col_name_map(arrays, names)
+
+    # If require_match is True then the output must have exactly the same
+    # number of columns as each input array
+    if join_type == 'exact':
+        for names in col_name_map.values():
+            if any(x is None for x in names):
+                raise TableMergeError('Inconsistent columns in input arrays '
+                                      "(use 'inner' or 'outer' join_type to "
+                                      "allow non-matching columns)")
+        join_type = 'outer'
+
+    # For an inner join, keep only columns where all input arrays have that column
+    if join_type == 'inner':
+        col_name_map = OrderedDict((name, in_names) for name, in_names in col_name_map.items()
+                                   if all(x is not None for x in in_names))
+        if len(col_name_map) == 0:
+            raise TableMergeError('Input arrays have no columns in common')
+
+    # Check that all tables have the same length
+    lengths = [len(arr) for arr in arrays]
+    if len(set(lengths)) > 1:
+        raise ValueError("All input tables must have the same length for depth-wise stacking")
+
+    n_rows = lengths[0]
+    n_tables = len(arrays)
+    out = _get_out_class(arrays)()
+
+    for out_name, in_names in col_name_map.items():
+        # List of input arrays that contribute to this output column
+        cols = [arr[name] for arr, name in zip(arrays, in_names) if name is not None]
+
+        # We need to create a new column that stacks the individual columns depth-wise.
+        # The output column should have shape (n_rows, n_tables) for this column.
+        # We'll use the first column's class to create the new column.
+        col_cls = _get_out_class(cols)
+        if not hasattr(col_cls.info, 'new_like'):
+            raise NotImplementedError('cstack unavailable for mixin column type(s): {}'
+                                      .format(col_cls.__name__))
+
+        # Create a new column with the appropriate shape and type.
+        # We'll create a list of columns for each table, then stack them.
+        # The new_like method is designed for vstack, so we need to adapt.
+        # Instead, we can create an empty column with the right shape and fill.
+        # Alternatively, we can use the first column as a base and then add the others.
+        # Since the columns are 1D, we want to create a 2D column.
+        # We'll create a new column with n_rows rows and n_tables columns.
+        # We'll use the first column's type and unit, etc.
+
+        # First, create a list of the data arrays from each column.
+        data_list = []
+        for col in cols:
+            # Convert to array, keeping the data type.
+            data = np.asarray(col)
+            data_list.append(data)
+
+        # Stack along a new axis (depth-wise) to get shape (n_rows, n_tables)
+        stacked_data = np.dstack(data_list)[:, 0, :]  # dstack gives (n_rows, 1, n_tables), squeeze the second dimension
+
+        # Create a new column with the stacked data.
+        # We need to create a column of the appropriate class.
+        # Use the first column as a template.
+        first_col = cols[0]
+        try:
+            # Try to create a new column with the same class and attributes.
+            new_col = col_cls(stacked_data, unit=first_col.unit, dtype=first_col.dtype,
+                              format=first_col.format, description=first_col.description,
+                              meta=first_col.meta)
+        except Exception:
+            # If that fails, fall back to a generic column.
+            new_col = Column(stacked_data, unit=first_col.unit, dtype=first_col.dtype,
+                             format=first_col.format, description=first_col.description,
+                             meta=first_col.meta)
+
+        out[out_name] = new_col
+
+    # If col_name_map supplied as a dict input, then update.
+    if isinstance(_col_name_map, Mapping):
+        _col_name_map.update(col_name_map)
+
+    return out
+
+
+def _cstack(arrays, join_type='outer', col_name_map=None, metadata_conflicts='warn'):
+    """
+    Stack Tables depth-wise (along a third axis)
+
+    A ``join_type`` of 'exact' (default) means that the arrays must all
+    have exactly the same column names (though the order can vary).  If
+    ``join_type`` is 'inner' then the intersection of common columns will
+    be the output.  A value of 'outer' means the output will have the union of
+    all columns, with array values being masked where no common values are
+    available.
+
+    Parameters
+    ----------
+    arrays : list of Tables
+        Tables to stack depth-wise
+    join_type : str
+        Join type ('inner' | 'exact' | 'outer'), default is 'outer'
+    col_name_map : empty dict or None
+        If passed as a dict then it will be updated in-place with the
+        mapping of output to input column names.
+
+    Returns
+    -------
+    stacked_table : `~astropy.table.Table` object
+        New table containing the stacked data from the input tables.
+    """
+    # Store user-provided col_name_map until the end
+    _col_name_map = col_name_map
+
+    # Input validation
+    if join_type not in ('inner', 'exact', 'outer'):
+        raise ValueError("`join_type` arg must be one of 'inner', 'exact' or 'outer'")
+
+    # Trivial case of one input array
+    if len(arrays) == 1:
+        return arrays[0]
+
+    # Start by assuming an outer match where all names go to output
+    names = set(itertools.chain(*[arr.colnames for arr in arrays]))
+    col_name_map = get_col_name_map(arrays, names)
+
+    # If require_match is True then the output must have exactly the same
+    # number of columns as each input array
+    if join_type == 'exact':
+        for names in col_name_map.values():
+            if any(x is None for x in names):
+                raise TableMergeError('Inconsistent columns in input arrays '
+                                      "(use 'inner' or 'outer' join_type to "
+                                      "allow non-matching columns)")
+        join_type = 'outer'
+
+    # For an inner join, keep only columns where all input arrays have that column
+    if join_type == 'inner':
+        col_name_map = OrderedDict((name, in_names) for name, in_names in col_name_map.items()
+                                   if all(x is not None for x in in_names))
+        if len(col_name_map) == 0:
+            raise TableMergeError('Input arrays have no columns in common')
+
+    # Check that all tables have the same length
+    lengths = [len(arr) for arr in arrays]
+    if len(set(lengths)) > 1:
+        raise ValueError("All input tables must have the same length for depth-wise stacking")
+
+    n_rows = lengths[0]
+    n_tables = len(arrays)
+    out = _get_out_class(arrays)()
+
+    for out_name, in_names in col_name_map.items():
+        # List of input arrays that contribute to this output column
+        cols = [arr[name] for arr, name in zip(arrays, in_names) if name is not None]
+
+        # We need to create a new column that stacks the individual columns depth-wise.
+        # The output column should have shape (n_rows, n_tables) for this column.
+        # We'll use the first column's class to create the new column.
+        col_cls = _get_out_class(cols)
+        if not hasattr(col_cls.info, 'new_like'):
+            raise NotImplementedError('cstack unavailable for mixin column type(s): {}'
+                                      .format(col_cls.__name__))
+
+        # Create a list of the data arrays from each column.
+        data_list = []
+        for col in cols:
+            # Convert to array, keeping the data type.
+            data = np.asarray(col)
+            data_list.append(data)
+
+        # Stack along a new axis (depth-wise) to get shape (n_rows, n_tables)
+        stacked_data = np.dstack(data_list)[:, 0, :]  # dstack gives (n_rows, 1, n_tables), squeeze the second dimension
+
+        # Create a new column with the stacked data.
+        # Use the first column as a template.
+        first_col = cols[0]
+        try:
+            # Try to create a new column with the same class and attributes.
+            new_col = col_cls(stacked_data, unit=first_col.unit, dtype=first_col.dtype,
+                              format=first_col.format, description=first_col.description,
+                              meta=first_col.meta)
+        except Exception:
+            # If that fails, fall back to a generic column.
+            new_col = Column(stacked_data, unit=first_col.unit, dtype=first_col.dtype,
+                             format=first_col.format, description=first_col.description,
+                             meta=first_col.meta)
+
+        out[out_name] = new_col
+
+    # If col_name_map supplied as a dict input, then update.
+    if isinstance(_col_name_map, Mapping):
+        _col_name_map.update(col_name_map)
+
+    return out
+
+
+def _cstack(arrays, join_type='outer', col_name_map=None, metadata_conflicts='warn'):
+    """
+    Stack Tables depth-wise (along a third axis)
+
+    A ``join_type`` of 'exact' (default) means that the arrays must all
+    have exactly the same column names (though the order can vary).  If
+    ``join_type`` is 'inner' then the intersection of common columns will
+    be the output.  A value of 'outer' means the output will have the union of
+    all columns, with array values being masked where no common values are
+    available.
+
+    Parameters
+    ----------
+    arrays : list of Tables
+        Tables to stack depth-wise
+    join_type : str
+        Join type ('inner' | 'exact' | 'outer'), default is 'outer'
+    col_name_map : empty dict or None
+        If passed as a dict then it will be updated in-place with the
+        mapping of output to input column names.
+
+    Returns
+    -------
+    stacked_table : `~astropy.table.Table` object
+        New table containing the stacked data from the input tables.
+    """
+    # Store user-provided col_name_map until the end
+    _col_name_map = col_name_map
+
+    # Input validation
+    if join_type not in ('inner', 'exact', 'outer'):
+        raise ValueError("`join_type` arg must be one of 'inner', 'exact' or 'outer'")
+
+    # Trivial case of one input array
+    if len(arrays) == 1:
+        return arrays[0]
+
+    # Start by assuming an outer match where all names go to output
+    names = set(itertools.chain(*[arr.colnames for arr in arrays]))
+    col_name_map = get_col_name_map(arrays, names)
+
+    # If require_match is True then the output must have exactly the same
+    # number of columns as each input array
+    if join_type == 'exact':
+        for names in col_name_map.values():
+            if any(x is None for x in names):
+                raise TableMergeError('Inconsistent columns in input arrays '
+                                      "(use 'inner' or 'outer' join_type to "
+                                      "allow non-matching columns)")
+        join_type = 'outer'
+
+    # For an inner join, keep only columns where all input arrays have that column
+    if join_type == 'inner':
+        col_name_map = OrderedDict((name, in_names) for name, in_names in col_name_map.items()
+                                   if all(x is not None for x in in_names))
+        if len(col_name_map) == 0:
+            raise TableMergeError('Input arrays have no columns in common')
+
+    # Check that all tables have the same length
+    lengths = [len(arr) for arr in arrays]
+    if len(set(lengths)) > 1:
+        raise ValueError("All input tables must have the same length for depth-wise stacking")
+
+    n_rows = lengths[0]
+    n_tables = len(arrays)
+    out = _get_out_class(arrays)()
+
+    for out_name, in_names in col_name_map.items():
+        # List of input arrays that contribute to this output column
+        cols = [arr[name] for arr, name in zip(arrays, in_names) if name is not None]
+
+        # We need to create a new column that stacks the individual columns depth-wise.
+        # The output column should have shape (n_rows, n_tables) for this column.
+        # We'll use the first column's class to create the new column.
+        col_cls = _get_out_class(cols)
+        if not hasattr(col_cls.info, 'new_like'):
+            raise NotImplementedError('cstack unavailable for mixin column type(s): {}'
+                                      .format(col_cls.__name__))
+
+        # Create a new column with the appropriate shape and type.
+        # We'll create a list of columns for each table, then stack them.
+        # The new_like method is designed for vstack, so we need to adapt.
+        # Instead, we can create an empty column with the right shape and fill.
+        # Alternatively, we can use the first column as a base and then add the others.
+        # Since the columns are 1D, we want to create a 2D column.
+        # We'll create a new column with n_rows rows and n_tables columns.
+        # We'll use the first column's type and unit, etc.
+
+        # First, create a list of the data arrays from each column.
+        data_list = []
+        for col in cols:
+            # Convert to array, keeping the data type.
+            data = np.asarray(col)
+            data_list.append(data)
+
+        # Stack along a new axis (depth-wise) to get shape (n_rows, n_tables)
+        stacked_data = np.dstack(data_list)[:, 0, :]  # dstack gives (n_rows, 1, n_tables), squeeze the second dimension
+
+        # Create a new column with the stacked data.
+        # We need to create a column of the appropriate class.
+        # Use the first column as a template.
+        first_col = cols[0]
+        try:
+            # Try to create a new column with the same class and attributes.
+            new_col = col_cls(stacked_data, unit=first_col.unit, dtype=first_col.dtype,
+                              format=first_col.format, description=first_col.description,
+                              meta=first_col.meta)
+        except Exception:
+            # If that fails, fall back to a generic column.
+            new_col = Column(stacked_data, unit=first_col.unit, dtype=first_col.dtype,
+                             format=first_col.format, description=first_col.description,
+                             meta=first_col.meta)
+
+        out[out_name] = new_col
+
+    # If col_name_map supplied as a dict input, then update.
+    if isinstance(_col_name_map, Mapping):
+        _col_name_map.update(col_name_map)
+
+    return out
+
+
+def _hstack(arrays, join_type='outer', uniq_col_name='{col_name}_{table_name}',
+           table_names=None, col_name_map=None):
+    """
+    Stack tables horizontally (by columns)
+
+    A ``join_type`` of 'exact' (default) means that the arrays must all
+    have exactly the same number of rows.  If ``join_type`` is 'inner' then
+    the intersection of rows will be the output.  A value of 'outer' means
+    the output will have the union of all rows, with array values being
+    masked where no common values are available.
+
+    Parameters
+    ----------
+    arrays : List of tables
+        Tables to stack by columns (horizontally)
+    join_type : str
+        Join type ('inner' | 'exact' | 'outer'), default is 'outer'
+    uniq_col_name : str or None
+        String generate a unique output column name in case of a conflict.
+        The default is '{col_name}_{table_name}'.
+    table_names : list of str or None
+        Two-element list of table names used when generating unique output
+        column names.  The default is ['1', '2', ..].
+
+    Returns
+    -------
+    stacked_table : `~astropy.table.Table` object
+        New table containing the stacked data from the input tables.
+    """
+
+    # Store user-provided col_name_map until the end
+    _col_name_map = col_name_map
+
+    # Input validation
+    if join_type not in ('inner', 'exact', 'outer'):
+        raise ValueError("join_type arg must be either 'inner', 'exact' or 'outer'")
+
+    if table_names is None:
+        table_names = ['{}'.format(ii + 1) for ii in range(len(arrays))]
+    if len(arrays) != len(table_names):
+        raise ValueError('Number of arrays must match number of table_names')
+
+    # Trivial case of one input arrays
+    if len(arrays) == 1:
+        return arrays[0]
+
+    col_name_map = get_col_name_map(arrays, [], uniq_col_name, table_names)
+
+    # If require_match is True then all input arrays must have the same length
+    arr_lens = [len(arr) for arr in arrays]
+    if join_type == 'exact':
+        if len(set(arr_lens)) > 1:
+            raise TableMergeError("Inconsistent number of rows in input arrays "
+                                  "(use 'inner' or 'outer' join_type to allow "
+                                  "non-matching rows)")
+        join_type = 'outer'
+
+    # For an inner join, keep only the common rows
+    if join_type == 'inner':
+        min_arr_len = min(arr_lens)
+        if len(set(arr_lens)) > 1:
+            arrays = [arr[:min_arr_len] for arr in arrays]
+        arr_lens = [min_arr_len for arr in arrays]
+
+    # If there are any output rows where one or more input arrays are missing
+    # then the output must be masked.  If any input arrays are masked then
+    # output is masked.
+
+    n_rows = max(arr_lens)
+    out = _get_out_class(arrays)()
+
+    for out_name, in_names in col_name_map.items():
+        for name, array, arr_len in zip(in_names, arrays, arr_lens):
+            if name is None:
+                continue
+
+            if n_rows > arr_len:
+                indices = np.arange(n_rows)
+                indices[arr_len:] = 0
+                col = array[name][indices]
+
+                # If col is a Column but not MaskedColumn then upgrade at this point
+                # because masking is required.
+                if isinstance(col, Column) and not isinstance(col, MaskedColumn):
+                    col = out.MaskedColumn(col, copy=False)
+
+                try:
+                    col[arr_len:] = col.info.mask_val
+                except Exception:
+                    raise NotImplementedError(
+                        "hstack requires masking column '{}' but column"
+                        " type {} does not support masking"
+                        .format(out_name, col.__class__.__name__))
+            else:
+                col = array[name][:n_rows]
+
+            out[out_name] = col
+
+    # If col_name_map supplied as a dict input, then update.
+    if isinstance(_col_name_map, Mapping):
+        _col_name_map.update(col_name_map)
+
+    return out
+
+
+def _cstack(arrays, join_type='outer', col_name_map=None, metadata_conflicts='warn'):
+    """
+    Stack Tables depth-wise (along a third axis)
+
+    A ``join_type`` of 'exact' (default) means that the arrays must all
+    have exactly the same column names (though the order can vary).  If
+    ``join_type`` is 'inner' then the intersection of common columns will
+    be the output.  A value of 'outer' means the output will have the union of
+    all columns, with array values being masked where no common values are
+    available.
+
+    Parameters
+    ----------
+    arrays : list of Tables
+        Tables to stack depth-wise
+    join_type : str
+        Join type ('inner' | 'exact' | 'outer'), default is 'outer'
+    col_name_map : empty dict or None
+        If passed as a dict then it will be updated in-place with the
+        mapping of output to input column names.
+
+    Returns
+    -------
+    stacked_table : `~astropy.table.Table` object
+        New table containing the stacked data from the input tables.
+    """
+    # Store user-provided col_name_map until the end
+    _col_name_map = col_name_map
+
+    # Input validation
+    if join_type not in ('inner', 'exact', 'outer'):
+        raise ValueError("`join_type` arg must be one of 'inner', 'exact' or 'outer'")
+
+    # Trivial case of one input array
+    if len(arrays) == 1:
+        return arrays[0]
+
+    # Start by assuming an outer match where all names go to output
+    names = set(itertools.chain(*[arr.colnames for arr in arrays]))
+    col_name_map = get_col_name_map(arrays, names)
+
+    # If require_match is True then the output must have exactly the same
+    # number of columns as each input array
+    if join_type == 'exact':
+        for names in col_name_map.values():
+            if any(x is None for x in names):
+                raise TableMergeError('Inconsistent columns in input arrays '
+                                      "(use 'inner' or 'outer' join_type to "
+                                      "allow non-matching columns)")
+        join_type = 'outer'
+
+    # For an inner join, keep only columns where all input arrays have that column
+    if join_type == 'inner':
+        col_name_map = OrderedDict((name, in_names) for name, in_names in col_name_map.items()
+                                   if all(x is not None for x in in_names))
+        if len(col_name_map) == 0:
+            raise TableMergeError('Input arrays have no columns in common')
+
+    # Check that all tables have the same length
+    lengths = [len(arr) for arr in arrays]
+    if len(set(lengths)) > 1:
+        raise ValueError("All input tables must have the same length for depth-wise stacking")
+
+    n_rows = lengths[0]
+    n_tables = len(arrays)
+    out = _get_out_class(arrays)()
+
+    for out_name, in_names in col_name_map.items():
+        # List of input arrays that contribute to this output column
+        cols = [arr[name] for arr, name in zip(arrays, in_names) if name is not None]
+
+        # We need to create a new column that stacks the individual columns depth-wise.
+        # The output column should have shape (n_rows, n_tables) for this column.
+        # We'll use the first column's class to create the new column.
+        col_cls = _get_out_class(cols)
+        if not hasattr(col_cls.info, 'new_like'):
+            raise NotImplementedError('cstack unavailable for mixin column type(s): {}'
+                                      .format(col_cls.__name__))
+
+        # Create a new column with the appropriate shape and type.
+        # We'll create a list of columns for each table, then stack them.
+        # The new_like method is designed for vstack, so we need to adapt.
+        # Instead, we can create an empty column with the right shape and fill.
+        # Alternatively, we can use the first column as a base and then add the others.
+        # Since the columns are 1D, we want to create a 2D column.
+        # We'll create a new column with n_rows rows and n_tables columns.
+        # We'll use the first column's type and unit, etc.
+
+        # First, create a list of the data arrays from each column.
+        data_list = []
+        for col in cols:
+            # Convert to array, keeping the data type.
+            data = np.asarray(col)
+            data_list.append(data)
+
+        # Stack along a new axis (depth-wise) to get shape (n_rows, n_tables)
+        stacked_data = np.dstack(data_list)[:, 0, :]  # dstack gives (n_rows, 1, n_tables), squeeze the second dimension
+
+        # Create a new column with the stacked data.
+        # We need to create a column of the appropriate class.
+        # Use the first column as a template.
+        first_col = cols[0]
+        try:
+            # Try to create a new column with the same class and attributes.
+            new_col = col_cls(stacked_data, unit=first_col.unit, dtype=first_col.dtype,
+                              format=first_col.format, description=first_col.description,
+                              meta=first_col.meta)
+        except Exception:
+            # If that fails, fall back to a generic column.
+            new_col = Column(stacked_data, unit=first_col.unit, dtype=first_col.dtype,
+                             format=first_col.format, description=first_col.description,
+                             meta=first_col.meta)
+
+        out[out_name] = new_col
+
+    # If col_name_map supplied as a dict input, then update.
+    if isinstance(_col_name_map, Mapping):
+        _col_name_map.update(col_name_map)
+
+    return out
+
+
+def _cstack(arrays, join_type='outer', col_name_map=None, metadata_conflicts='warn'):
+    """
+    Stack Tables depth-wise (along a third axis)
+
+    A ``join_type`` of 'exact' (default) means that the arrays must all
+    have exactly the same column names (though the order can vary).  If
+    ``join_type`` is 'inner' then the intersection of common columns will
+    be the output.  A value of 'outer' means the output will have the union of
+    all columns, with array values being masked where no common values are
+    available.
+
+    Parameters
+    ----------
+    arrays : list of Tables
+        Tables to stack depth-wise
+    join_type : str
+        Join type ('inner' | 'exact' | 'outer'), default is 'outer'
+    col_name_map : empty dict or None
+        If passed as a dict then it will be updated in-place with the
+        mapping of output to input column names.
+
+    Returns
+    -------
+    stacked_table : `~astropy.table.Table` object
+        New table containing the stacked data from the input tables.
+    """
+    # Store user-provided col_name_map until the end
+    _col_name_map = col_name_map
+
+    # Input validation
+    if join_type not in ('inner', 'exact', 'outer'):
+        raise ValueError("`join_type` arg must be one of 'inner', 'exact' or 'outer'")
+
+    # Trivial case of one input array
+    if len(arrays) == 1:
+        return arrays[0]
+
+    # Start by assuming an outer match where all names go to output
+    names = set(itertools.chain(*[arr.colnames for arr in arrays]))
+    col_name_map = get_col_name_map(arrays, names)
+
+    # If require_match is True then the output must have exactly the same
+    # number of columns as each input array
+    if join_type == 'exact':
+        for names in col_name_map.values():
+            if any(x is None for x in names):
+                raise TableMergeError('Inconsistent columns in input arrays '
+                                      "(use 'inner' or 'outer' join_type to "
+                                      "allow non-matching columns)")
+        join_type = 'outer'
+
+    # For an inner join, keep only columns where all input arrays have that column
+    if join_type == 'inner':
+        col_name_map = OrderedDict((name, in_names) for name, in_names in col_name_map.items()
+                                   if all(x is not None for x in in_names))
+        if len(col_name_map) == 0:
+            raise TableMergeError('Input arrays have no columns in common')
+
+    # Check that all tables have the same length
+    lengths = [len(arr) for arr in arrays]
+    if len(set(lengths)) > 1:
+        raise ValueError("All input tables must have the same length for depth-wise stacking")
+
+    n_rows = lengths[0]
+    n_tables = len(arrays)
+    out = _get_out_class(arrays)()
+
+    for out_name, in_names in col_name_map.items():
+        # List of input arrays that contribute to this output column
+        cols = [arr[name] for arr, name in zip(arrays, in_names) if name is not None]
+
+        # We need to create a new column that stacks the individual columns depth-wise.
+        # The output column should have shape (n_rows, n_tables) for this column.
+        # We'll use the first column's class to create the new column.
+        col_cls = _get_out_class(cols)
+        if not hasattr(col_cls.info, 'new_like'):
+            raise NotImplementedError('cstack unavailable for mixin column type(s): {}'
+                                      .format(col_cls.__name__))
+
+        # Create a list of the data arrays from each column.
+        data_list = []
+        for col in cols:
+            # Convert to array, keeping the data type.
+            data = np.asarray(col)
+            data_list.append(data)
+
+        # Stack along a new axis (depth-wise) to get shape (n_rows, n_tables)
+        stacked_data = np.dstack(data_list)[:, 0, :]  # dstack gives (n_rows, 1, n_tables), squeeze the second dimension
+
+        # Create a new column with the stacked data.
+        # Use the first column as a template.
+        first_col = cols[0]
+        try:
+            # Try to create a new column with the same class and attributes.
+            new_col = col_cls(stacked_data, unit=first_col.unit, dtype=first_col.dtype,
+                              format=first_col.format, description=first_col.description,
+                              meta=first_col.meta)
+        except Exception:
+            # If that fails, fall back to a generic column.
+            new_col = Column(stacked_data, unit=first_col.unit, dtype=first_col.dtype,
+                             format=first_col.format, description=first_col.description,
+                             meta=first_col.meta)
+
+        out[out_name] = new_col
+
+    # If col_name_map supplied as a dict input, then update.
+    if isinstance(_col_name_map, Mapping):
+        _col_name_map.update(col_name_map)
+
+    return out
+
+
+def _cstack(arrays, join_type='outer', col_name_map=None, metadata_conflicts='warn'):
+    """
+    Stack Tables depth-wise (along a third axis)
+
+    A ``join_type`` of 'exact' (default) means that the arrays must all
+    have exactly the same column names (though the order can vary).  If
+    ``join_type`` is 'inner' then the intersection of common columns will
+    be the output.  A value of 'outer' means the output will have the union of
+    all columns, with array values being masked where no common values are
+    available.
+
+    Parameters
+    ----------
+    arrays : list of Tables
+        Tables to stack depth-wise
+    join_type : str
+        Join type ('inner' | 'exact' | 'outer'), default is 'outer'
+    col_name_map : empty dict or None
+        If passed as a dict then it will be updated in-place with the
+        mapping of output to input column names.
+
+    Returns
+    -------
+    stacked_table : `~astropy.table.Table` object
+        New table containing the stacked data from the input tables.
+    """
+    # Store user-provided col_name_map until the end
+    _col_name_map = col_name_map
+
+    # Input validation
+    if join_type not in ('inner', 'exact', 'outer'):
+        raise ValueError("`join_type` arg must be one of 'inner', 'exact' or 'outer'")
+
+    # Trivial case of one input array
+    if len(arrays) == 1:
+        return arrays[0]
+
+    # Start by assuming an outer match where all names go to output
+    names = set(itertools.chain(*[arr.colnames for arr in arrays]))
+    col_name_map = get_col_name_map(arrays, names)
+
+    # If require_match is True then the output must have exactly the same
+    # number of columns as each input array
+    if join_type == 'exact':
+        for names in col_name_map.values():
+            if any(x is None for x in names):
+                raise TableMergeError('Inconsistent columns in input arrays '
+                                      "(use 'inner' or 'outer' join_type to "
+                                      "allow non-matching columns)")
+        join_type = 'outer'
+
+    # For an inner join, keep only columns where all input arrays have that column
+    if join_type == 'inner':
+        col_name_map = OrderedDict((name, in_names) for name, in_names in col_name_map.items()
+                                   if all(x is not None for x in in_names))
+        if len(col_name_map) == 0:
+            raise TableMergeError('Input arrays have no columns in common')
+
+    # Check that all tables have the same length
+    lengths = [len(arr) for arr in arrays]
+    if len(set(lengths)) > 1:
+        raise ValueError("All input tables must have the same length for depth-wise stacking")
+
+    n_rows = lengths[0]
+    n_tables = len(arrays)
+    out = _get_out_class(arrays)()
+
+    for out_name, in_names in col_name_map.items():
+        # List of input arrays that contribute to this output column
+        cols = [arr[name] for arr, name in zip(arrays, in_names) if name is not None]
+
+        # We need to create a new column that stacks the individual columns depth-wise.
+        # The output column should have shape (n_rows, n_tables) for this column.
+        # We'll use the first column's class to create the new column.
+        col_cls = _get_out_class(cols)
+        if not hasattr(col_cls.info, 'new_like'):
+            raise NotImplementedError('cstack unavailable for mixin column type(s): {}'
+                                      .format(col_cls.__name__))
+
+        # Create a new column with the appropriate shape and type.
+        # We'll create a list of columns for each table, then stack them.
+        # The new_like method is designed for vstack, so we need to adapt.
+        # Instead, we can create an empty column with the right shape and fill.
+        # Alternatively, we can use the first column as a base and then add the others.
+        # Since the columns are 1D, we want to create a 2D column.
+        # We'll create a new column with n_rows rows and n_tables columns.
+        # We'll use the first column's type and unit, etc.
+
+        # First, create a list of the data arrays from each column.
+        data_list = []
+        for col in cols:
+            # Convert to array, keeping the data type.
+            data = np.asarray(col)
+            data_list.append(data)
+
+        # Stack along a new axis (depth-wise) to get shape (n_rows, n_tables)
+        stacked_data = np.dstack(data_list)[:, 0, :]  # dstack gives (n_rows, 1, n_tables), squeeze the second dimension
+
+        # Create a new column with the stacked data.
+        # We need to create a column of the appropriate class.
+        # Use the first column as a template.
+        first_col = cols[0]
+        try:
+            # Try to create a new column with the same class and attributes.
+            new_col = col_cls(stacked_data, unit=first_col.unit, dtype=first_col.dtype,
+                              format=first_col.format, description=first_col.description,
+                              meta=first_col.meta)
+        except Exception:
+            # If that fails, fall back to a generic column.
+            new_col = Column(stacked_data, unit=first_col.unit, dtype=first_col.dtype,
+                             format=first_col.format, description=first_col.description,
+                             meta=first_col.meta)
+
+        out[out_name] = new_col
 
     # If col_name_map supplied as a dict input, then update.
     if isinstance(_col_name_map, Mapping):
