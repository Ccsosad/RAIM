diff --git a/_pytest/capture.py b/_pytest/capture.py
index 2a7dde5..f1e951e 100644
--- a/_pytest/capture.py
+++ b/_pytest/capture.py
@@ -29,6 +29,65 @@ def pytest_addoption(parser):
     group._addoption(
         '-s', action="store_const", const="no", dest="capture",
         help="shortcut for --capture=no.")
+    
+    # Add logging options
+    group = parser.getgroup("logging")
+    group.addoption(
+        '--no-print-logs',
+        dest='log_print',
+        action='store_false',
+        default=True,
+        help='Disable printing captured logs on failed tests.')
+    group.addoption(
+        '--log-level',
+        dest='log_level',
+        default=None,
+        help='Global logging level (default: not set).')
+    group.addoption(
+        '--log-format',
+        dest='log_format',
+        default='%(levelname)-8s %(name)s %(message)s',
+        help='Log format used by the logging module.')
+    group.addoption(
+        '--log-date-format',
+        dest='log_date_format',
+        default='%H:%M:%S',
+        help='Log date format used by the logging module.')
+    group.addoption(
+        '--log-cli-level',
+        dest='log_cli_level',
+        default=None,
+        help='Log level for the console logging.')
+    group.addoption(
+        '--log-cli-format',
+        dest='log_cli_format',
+        default=None,
+        help='Log format for the console logging.')
+    group.addoption(
+        '--log-cli-date-format',
+        dest='log_cli_date_format',
+        default=None,
+        help='Log date format for the console logging.')
+    group.addoption(
+        '--log-file',
+        dest='log_file',
+        default=None,
+        help='Path to a file when logging will be written to.')
+    group.addoption(
+        '--log-file-level',
+        dest='log_file_level',
+        default=None,
+        help='Log level for the file logging.')
+    group.addoption(
+        '--log-file-format',
+        dest='log_file_format',
+        default=None,
+        help='Log format for the file logging.')
+    group.addoption(
+        '--log-file-date-format',
+        dest='log_file_date_format',
+        default=None,
+        help='Log date format for the file logging.')
 
 
 @pytest.hookimpl(hookwrapper=True)
@@ -51,6 +110,12 @@ def pytest_load_initial_conftests(early_config, parser, args):
             sys.modules["logging"].raiseExceptions = False
     early_config.add_cleanup(silence_logging_at_shutdown)
 
+    # Register logging plugin if not disabled
+    if not hasattr(ns, 'log_print') or ns.log_print:
+        from _pytest.logging import LoggingPlugin
+        logging_plugin = LoggingPlugin(ns)
+        pluginmanager.register(logging_plugin, "logging-plugin")
+
     # finally trigger conftest loading but while capturing (issue93)
     capman.start_global_capturing()
     outcome = yield
diff --git a/_pytest/logging.py b/_pytest/logging.py
new file mode 100644
index 0000000..0ed78de
--- /dev/null
+++ b/_pytest/logging.py
@@ -0,0 +1,163 @@
+"""Logging plugin for pytest."""
+import logging
+import sys
+import warnings
+from contextlib import contextmanager
+
+import pytest
+
+
+class LogCaptureHandler(logging.StreamHandler):
+    """A logging handler that stores log records and the log text."""
+
+    def __init__(self):
+        super().__init__()
+        self.records = []
+        self.stream = None
+
+    def emit(self, record):
+        self.records.append(record)
+        super().emit(record)
+
+    def reset(self):
+        self.records = []
+
+
+class LoggingPlugin:
+    """Logging plugin for pytest that captures log messages and provides a fixture."""
+
+    def __init__(self, config):
+        self.config = config
+        self.log_capture_handler = None
+        self.original_log_levels = {}
+        self.original_handlers = {}
+
+    @pytest.hookimpl
+    def pytest_configure(self, config):
+        """Setup logging capture."""
+        if not hasattr(config, 'log_print') or config.log_print:
+            self._setup_log_capture()
+
+    def _setup_log_capture(self):
+        root_logger = logging.getLogger()
+        self.log_capture_handler = LogCaptureHandler()
+        self.log_capture_handler.setFormatter(
+            logging.Formatter(
+                fmt=self.config.log_format,
+                datefmt=self.config.log_date_format
+            )
+        )
+        root_logger.addHandler(self.log_capture_handler)
+        self.original_handlers['root'] = root_logger.handlers[:]
+        if self.config.log_level:
+            self.original_log_levels['root'] = root_logger.level
+            root_logger.setLevel(self.config.log_level)
+
+    @pytest.hookimpl
+    def pytest_unconfigure(self):
+        """Cleanup logging capture."""
+        if self.log_capture_handler:
+            root_logger = logging.getLogger()
+            root_logger.removeHandler(self.log_capture_handler)
+            if 'root' in self.original_log_levels:
+                root_logger.setLevel(self.original_log_levels['root'])
+
+    @pytest.hookimpl
+    def pytest_runtest_setup(self, item):
+        """Reset log capture before each test."""
+        if self.log_capture_handler:
+            self.log_capture_handler.reset()
+
+    @pytest.hookimpl
+    def pytest_runtest_teardown(self, item, nextitem):
+        """Reset log capture after each test."""
+        if self.log_capture_handler:
+            self.log_capture_handler.reset()
+
+    @pytest.hookimpl
+    def pytest_runtest_makereport(self, item, call):
+        """Add captured log messages to test report."""
+        if not hasattr(self.config, 'log_print') or not self.config.log_print:
+            return
+        if call.when == 'call' and self.log_capture_handler:
+            if call.excinfo is not None:  # test failed
+                if self.log_capture_handler.records:
+                    longrepr = getattr(call, 'longrepr', None)
+                    if longrepr is not None:
+                        longrepr.addsection('Captured stdlog call',
+                                            '\n'.join(self.log_capture_handler.stream.getvalue()
+                                                      if hasattr(self.log_capture_handler.stream, 'getvalue')
+                                                      else ''))
+
+    @pytest.fixture
+    def caplog(self, request):
+        """Fixture to capture log messages."""
+        return LogCaptureFixture(self.log_capture_handler, request.node)
+
+
+class LogCaptureFixture:
+    """Fixture to capture log messages in tests."""
+
+    def __init__(self, handler, node):
+        self.handler = handler
+        self.node = node
+        self._initial_records = []
+        self._initial_handler_level = None
+
+    @property
+    def records(self):
+        """Get captured log records."""
+        if self.handler:
+            return self.handler.records
+        return []
+
+    @property
+    def text(self):
+        """Get formatted log text."""
+        if self.handler and hasattr(self.handler.stream, 'getvalue'):
+            return self.handler.stream.getvalue()
+        return ''
+
+    @property
+    def record_tuples(self):
+        """Get captured log records as tuples of (logger_name, level, message)."""
+        return [(record.name, record.levelno, record.getMessage()) 
+                for record in self.records]
+
+    def set_level(self, level, logger=None):
+        """Set log level for the specified logger (or the capture handler)."""
+        if logger is None:
+            if self.handler:
+                self._initial_handler_level = self.handler.level
+                self.handler.setLevel(level)
+        else:
+            logger_obj = logging.getLogger(logger)
+            self._initial_records.append((logger_obj, logger_obj.level))
+            logger_obj.setLevel(level)
+
+    @contextmanager
+    def at_level(self, level, logger=None):
+        """Context manager to temporarily set log level."""
+        if logger is None:
+            if self.handler:
+                original_level = self.handler.level
+                self.handler.setLevel(level)
+                try:
+                    yield
+                finally:
+                    self.handler.setLevel(original_level)
+            else:
+                yield
+        else:
+            logger_obj = logging.getLogger(logger)
+            original_level = logger_obj.level
+            logger_obj.setLevel(level)
+            try:
+                yield
+            finally:
+                logger_obj.setLevel(original_level)
+
+    def clear(self):
+        """Clear captured log records."""
+        if self.handler:
+            self.handler.reset()
