diff --git a/astropy/table/operations.py b/astropy/table/operations.py
index 5d84827..1b13230 100644
--- a/astropy/table/operations.py
+++ b/astropy/table/operations.py
@@ -368,6 +368,59 @@ def hstack(tables, join_type='outer',
     return out
 
 
+def cstack(tables, join_type='outer', metadata_conflicts='warn'):
+    """
+    Stack tables depth-wise (along columns).
+
+    This corresponds roughly to running `numpy.dstack` on the individual
+    columns matched by name.
+
+    Parameters
+    ----------
+    tables : list of `~astropy.table.Table` objects
+        Tables to stack depth-wise.
+    join_type : str
+        Join type ('inner' | 'exact' | 'outer'), default is 'outer'.
+        If 'exact', then all tables must have exactly the same columns.
+        If 'inner', then the output table will contain only the columns
+        that are common to all tables.
+        If 'outer', then the output table will contain all columns from
+        all tables, with missing values filled with masked values.
+    metadata_conflicts : str
+        How to proceed with metadata conflicts. This should be one of:
+            * ``'silent'``: silently pick the last conflicting meta-data value
+            * ``'warn'``: pick the last conflicting meta-data value, but emit a warning (default)
+            * ``'error'``: raise an exception.
+
+    Returns
+    -------
+    stacked_table : `~astropy.table.Table` object
+        New table containing the stacked data from the input tables.
+
+    Examples
+    --------
+    >>> from astropy.table import Table, cstack
+    >>> t1 = Table({'a': [1, 2], 'b': [3, 4]})
+    >>> t2 = Table({'a': [5, 6], 'b': [7, 8]})
+    >>> print(cstack([t1, t2]))
+     a [2]   b [2]
+    ---------------
+    1 .. 5  3 .. 7
+    2 .. 6  4 .. 8
+    """
+    tables = _get_list_of_tables(tables)  # validates input
+    if len(tables) == 1:
+        return tables[0]  # no point in stacking a single table
+    col_name_map = OrderedDict()
+
+    out = _cstack(tables, join_type, col_name_map, metadata_conflicts)
+
+    # Merge table metadata
+    _merge_table_meta(out, tables, metadata_conflicts=metadata_conflicts)
+
+    return out
+
+
 def unique(input_table, keys=None, silent=False, keep='first'):
     """
     Returns the unique rows of a table.
