diff --git a/sklearn/decomposition/_kernel_pca.py b/sklearn/decomposition/_kernel_pca.py
index 6f0266a..0f8ea05 100644
--- a/sklearn/decomposition/_kernel_pca.py
+++ b/sklearn/decomposition/_kernel_pca.py
@@ -8,7 +8,7 @@ from scipy import linalg
 from scipy.sparse.linalg import eigsh
 
 from ..utils._arpack import _init_arpack_v0
-from ..utils.extmath import svd_flip
+from ..utils.extmath import svd_flip, randomized_svd
 from ..utils.validation import check_is_fitted, _check_psd_eigenvalues
 from ..utils.deprecation import deprecated
 from ..exceptions import NotFittedError
@@ -215,19 +215,31 @@ class KernelPCA(TransformerMixin, BaseEstimator):
                                                 tol=self.tol,
                                                 maxiter=self.max_iter,
                                                 v0=v0)
+        elif eigen_solver == 'randomized':
+            # Use randomized SVD to approximate the eigendecomposition
+            # Note: K is symmetric and positive semidefinite
+            U, s, _ = randomized_svd(K, n_components=n_components,
+                                     n_iter='auto',
+                                     random_state=self.random_state)
+            self.lambdas_ = s
+            self.alphas_ = U
 
         # make sure that the eigenvalues are ok and fix numerical issues
         self.lambdas_ = _check_psd_eigenvalues(self.lambdas_,
                                                enable_warnings=False)
 
         # flip eigenvectors' sign to enforce deterministic output
-        self.alphas_, _ = svd_flip(self.alphas_,
-                                   np.zeros_like(self.alphas_).T)
+        # Note: randomized_svd already flips the signs, so skip for randomized
+        if eigen_solver in ['dense', 'arpack']:
+            self.alphas_, _ = svd_flip(self.alphas_,
+                                       np.zeros_like(self.alphas_).T)
 
         # sort eigenvectors in descending order
-        indices = self.lambdas_.argsort()[::-1]
-        self.lambdas_ = self.lambdas_[indices]
-        self.alphas_ = self.alphas_[:, indices]
+        # Note: randomized_svd returns sorted singular values, so skip for randomized
+        if eigen_solver in ['dense', 'arpack']:
+            indices = self.lambdas_.argsort()[::-1]
+            self.lambdas_ = self.lambdas_[indices]
+            self.alphas_ = self.alphas_[:, indices]
 
         # remove eigenvectors with a zero eigenvalue (null space) if required
         if self.remove_zero_eig or self.n_components is None:
@@ -388,4 +400,4 @@ class KernelPCA(TransformerMixin, BaseEstimator):
 
     def _more_tags(self):
         return {'preserves_dtype': [np.float64, np.float32],
-                'pairwise': self.kernel == 'precomputed'}
+                'pairwise': self.kernel == 'precomputed'}
