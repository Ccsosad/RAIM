diff --git a/_pytest/capture.py b/_pytest/capture.py
index 2a7dde5..2e3c13e 100644
--- a/_pytest/capture.py
+++ b/_pytest/capture.py
@@ -29,6 +29,65 @@ def pytest_addoption(parser):
     group._addoption(
         '-s', action="store_const", const="no", dest="capture",
         help="shortcut for --capture=no.")
+    
+    # Add logging options
+    group = parser.getgroup("logging")
+    group.addoption(
+        '--no-print-logs',
+        dest='log_print',
+        action='store_false',
+        default=True,
+        help='Disable printing captured logs on failed tests.')
+    group.addoption(
+        '--log-level',
+        dest='log_level',
+        default=None,
+        help='Global logging level (overrides --log-cli-level and --log-file-level).')
+    group.addoption(
+        '--log-format',
+        dest='log_format',
+        default='%(levelname)-8s %(name)s %(message)s',
+        help='Log format used by the logging module.')
+    group.addoption(
+        '--log-date-format',
+        dest='log_date_format',
+        default=None,
+        help='Log date format used by the logging module.')
+    group.addoption(
+        '--log-cli-level',
+        dest='log_cli_level',
+        default=None,
+        help='Cli logging level.')
+    group.addoption(
+        '--log-cli-format',
+        dest='log_cli_format',
+        default=None,
+        help='Log format used by the cli logging handler.')
+    group.addoption(
+        '--log-cli-date-format',
+        dest='log_cli_date_format',
+        default=None,
+        help='Log date format used by the cli logging handler.')
+    group.addoption(
+        '--log-file',
+        dest='log_file',
+        default=None,
+        help='Path to a file when logging will be written to.')
+    group.addoption(
+        '--log-file-level',
+        dest='log_file_level',
+        default=None,
+        help='Log file logging level.')
+    group.addoption(
+        '--log-file-format',
+        dest='log_file_format',
+        default=None,
+        help='Log format used by the log file logging handler.')
+    group.addoption(
+        '--log-file-date-format',
+        dest='log_file_date_format',
+        default=None,
+        help='Log date format used by the log file logging handler.')
 
 
 @pytest.hookimpl(hookwrapper=True)
@@ -51,6 +110,12 @@ def pytest_load_initial_conftests(early_config, parser, args):
             sys.modules["logging"].raiseExceptions = False
     early_config.add_cleanup(silence_logging_at_shutdown)
 
+    # Register logging plugin if not disabled
+    if not hasattr(ns, 'log_print') or ns.log_print:
+        from _pytest.logging import LoggingPlugin
+        logging_plugin = LoggingPlugin(ns)
+        pluginmanager.register(logging_plugin, "logging-plugin")
+
     # finally trigger conftest loading but while capturing (issue93)
     capman.start_global_capturing()
     outcome = yield
diff --git a/_pytest/logging.py b/_pytest/logging.py
new file mode 100644
index 0000000..5c9dc89
--- /dev/null
+++ b/_pytest/logging.py
@@ -0,0 +1,163 @@
+import logging
+import sys
+import os
+from contextlib import contextmanager
+
+import pytest
+
+
+class LogCaptureHandler(logging.Handler):
+    """A logging handler that stores log records and the log text."""
+
+    def __init__(self):
+        super().__init__()
+        self.records = []
+        self.stream = None
+
+    def emit(self, record):
+        self.records.append(record)
+        if self.stream is not None:
+            self.stream.write(self.format(record) + '\n')
+
+    def reset(self):
+        self.records = []
+        if self.stream is not None:
+            self.stream.truncate(0)
+            self.stream.seek(0)
+
+
+class LoggingPlugin:
+    """Captures log messages and provides the caplog fixture."""
+
+    def __init__(self, config):
+        self.config = config
+        self.handler = None
+        self._caplog_fixture = None
+
+    @pytest.hookimpl(tryfirst=True)
+    def pytest_sessionstart(self, session):
+        """Setup logging capture."""
+        root_logger = logging.getLogger()
+        self.handler = LogCaptureHandler()
+        self.handler.setLevel(logging.NOTSET)
+        formatter = logging.Formatter(
+            fmt=self.config.option.log_format,
+            datefmt=self.config.option.log_date_format
+        )
+        self.handler.setFormatter(formatter)
+        root_logger.addHandler(self.handler)
+
+    @pytest.hookimpl(trylast=True)
+    def pytest_sessionfinish(self, session):
+        """Teardown logging capture."""
+        if self.handler is not None:
+            root_logger = logging.getLogger()
+            root_logger.removeHandler(self.handler)
+            self.handler = None
+
+    @pytest.hookimpl(hookwrapper=True)
+    def pytest_runtest_setup(self, item):
+        """Clear captured log records at the start of each test."""
+        if self.handler is not None:
+            self.handler.reset()
+        yield
+
+    @pytest.hookimpl(hookwrapper=True)
+    def pytest_runtest_call(self, item):
+        """Clear captured log records before test execution."""
+        if self.handler is not None:
+            self.handler.reset()
+        yield
+
+    @pytest.hookimpl(hookwrapper=True)
+    def pytest_runtest_teardown(self, item):
+        """Clear captured log records after test execution."""
+        if self.handler is not None:
+            self.handler.reset()
+        yield
+
+    @pytest.hookimpl(tryfirst=True)
+    def pytest_report_teststatus(self, report):
+        """Add captured log to report if test failed."""
+        if (report.when == 'call' and report.failed and 
+            self.handler is not None and 
+            self.config.option.log_print and
+            self.handler.records):
+            if not hasattr(report, 'sections'):
+                report.sections = []
+            report.sections.append(('Captured stdlog call', self._get_log_text()))
+
+    def _get_log_text(self):
+        """Return formatted log text from captured records."""
+        if self.handler is None:
+            return ''
+        return '\n'.join(self.handler.format(record) for record in self.handler.records)
+
+    @pytest.fixture
+    def caplog(self, request):
+        """Fixture to capture log messages."""
+        if self._caplog_fixture is None:
+            self._caplog_fixture = LogCaptureFixture(self.handler, request.node)
+        return self._caplog_fixture
+
+
+class LogCaptureFixture:
+    """Fixture to capture log messages in tests."""
+
+    def __init__(self, handler, node):
+        self.handler = handler
+        self.node = node
+        self._initial_records = []
+
+    @property
+    def records(self):
+        """List of log records captured so far."""
+        if self.handler is None:
+            return []
+        return self.handler.records
+
+    @property
+    def record_tuples(self):
+        """List of captured log records as tuples (logger_name, level, message)."""
+        return [(record.name, record.levelno, record.getMessage()) 
+                for record in self.records]
+
+    @property
+    def text(self):
+        """Formatted log text captured so far."""
+        if self.handler is None:
+            return ''
+        return '\n'.join(self.handler.format(record) for record in self.records)
+
+    def clear(self):
+        """Clear captured log records."""
+        if self.handler is not None:
+            self.handler.reset()
+
+    def set_level(self, level, logger=None):
+        """Set level for the handler or a specific logger."""
+        if logger is None:
+            if self.handler is not None:
+                self.handler.setLevel(level)
+        else:
+            logging.getLogger(logger).setLevel(level)
+
+    @contextmanager
+    def at_level(self, level, logger=None):
+        """Context manager to temporarily set log level."""
+        if logger is None:
+            if self.handler is not None:
+                old_level = self.handler.level
+                self.handler.setLevel(level)
+                try:
+                    yield
+                finally:
+                    self.handler.setLevel(old_level)
+        else:
+            logger_obj = logging.getLogger(logger)
+            old_level = logger_obj.level
+            logger_obj.setLevel(level)
+            try:
+                yield
+            finally:
+                logger_obj.setLevel(old_level)
