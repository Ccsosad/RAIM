diff --git a/sklearn/random_projection.py b/sklearn/random_projection.py
index d06dfcd..00ce6fb 100644
--- a/sklearn/random_projection.py
+++ b/sklearn/random_projection.py
@@ -302,12 +302,19 @@ class BaseRandomProjection(
 
     @abstractmethod
     def __init__(
-        self, n_components="auto", *, eps=0.1, dense_output=False, random_state=None
+        self,
+        n_components="auto",
+        *,
+        eps=0.1,
+        dense_output=False,
+        random_state=None,
+        compute_inverse_components=False,
     ):
         self.n_components = n_components
         self.eps = eps
         self.dense_output = dense_output
         self.random_state = random_state
+        self.compute_inverse_components = compute_inverse_components
 
     @abstractmethod
     def _make_random_matrix(self, n_components, n_features):
@@ -399,6 +406,16 @@ class BaseRandomProjection(
             " not the proper shape."
         )
 
+        # Compute inverse components if requested
+        if self.compute_inverse_components:
+            # Compute the pseudo-inverse of the components matrix
+            # Note: components_ is (n_components, n_features)
+            # We want inverse_components_ of shape (n_features, n_components)
+            # Using pinv for the pseudo-inverse
+            self.inverse_components_ = np.linalg.pinv(self.components_.T)
+        else:
+            self.inverse_components_ = None
+
         return self
 
     def transform(self, X):
@@ -437,6 +454,95 @@ class BaseRandomProjection(
         """
         return self.n_components
 
+    def inverse_transform(self, X):
+        """Project data back to its original space.
+
+        Parameters
+        ----------
+        X : {ndarray, sparse matrix} of shape (n_samples, n_components)
+            Data to be transformed back.
+
+        Returns
+        ----------
+        X_original : ndarray of shape (n_samples, n_features)
+            Data in the original feature space. Note that the output is always
+            dense, even if the input is sparse.
+        """
+        check_is_fitted(self)
+        X = self._validate_data(
+            X,
+            accept_sparse=["csr", "csc"],
+            reset=False,
+            dtype=[np.float64, np.float32],
+        )
+
+        if X.shape[1] != self.n_components_:
+            raise ValueError(
+                "Impossible to perform inverse transform:"
+                "X has a different number of components than the fitted data. "
+                "(%s != %s)" % (X.shape[1], self.n_components_)
+            )
+
+        # If inverse_components_ is not precomputed, compute it on the fly
+        if self.inverse_components_ is None:
+            # Compute the pseudo-inverse of the components matrix
+            inv_comp = np.linalg.pinv(self.components_.T)
+        else:
+            inv_comp = self.inverse_components_
+
+        # The inverse transform is X @ inv_comp.T
+        X_original = safe_sparse_dot(X, inv_comp.T, dense_output=True)
+        return X_original
+
+    def inverse_transform(self, X):
+        """Project data back to its original space.
+
+        Parameters
+        ----------
+        X : {ndarray, sparse matrix} of shape (n_samples, n_components)
+            Data to be transformed back.
+
+        Returns
+        -------
+        X_original : ndarray of shape (n_samples, n_features)
+            Data in the original feature space. Note that the output is always
+            dense, even if the input is sparse.
+        """
+        check_is_fitted(self)
+        X = self._validate_data(
+            X,
+            accept_sparse=["csr", "csc"],
+            reset=False,
+            dtype=[np.float64, np.float32],
+        )
+
+        if X.shape[1] != self.n_components_:
+            raise ValueError(
+                "Impossible to perform inverse transform:"
+                "X has a different number of components than the fitted data. "
+                "(%s != %s)" % (X.shape[1], self.n_components_)
+            )
+
+        # If inverse_components_ is not precomputed, compute it on the fly
+        if self.inverse_components_ is None:
+            # Compute the pseudo-inverse of the components matrix
+            inv_comp = np.linalg.pinv(self.components_.T)
+        else:
+            inv_comp = self.inverse_components_
+
+        # The inverse transform is X @ inv_comp.T
+        # But note: inv_comp is (n_features, n_components)
+        # So we do X @ inv_comp.T = X @ components_? Actually, we want to get back to n_features.
+        # The inverse components are the pseudo-inverse of components_.T.
+        # So the reconstruction is X @ inv_comp.T.
+        # However, the documentation says: "it computes the product of the input X and the transpose of the inverse components."
+        # So if inverse_components_ is (n_features, n_components), then its transpose is (n_components, n_features).
+        # Therefore, we should compute X @ inverse_components_.T.
+        # But note: we stored inverse_components_ as the pseudo-inverse of components_.T, which is exactly what we need.
+        # So we can do:
+        X_original = safe_sparse_dot(X, inv_comp.T, dense_output=True)
+        return X_original
+
     def _more_tags(self):
         return {
             "preserves_dtype": [np.float64, np.float32],
@@ -516,12 +622,20 @@ class GaussianRandomProjection(BaseRandomProjection):
     (25, 2759)
     """
 
-    def __init__(self, n_components="auto", *, eps=0.1, random_state=None):
+    def __init__(
+        self,
+        n_components="auto",
+        *,
+        eps=0.1,
+        random_state=None,
+        compute_inverse_components=False,
+    ):
         super().__init__(
             n_components=n_components,
             eps=eps,
             dense_output=True,
             random_state=random_state,
+            compute_inverse_components=compute_inverse_components,
         )
 
     def _make_random_matrix(self, n_components, n_features):
@@ -677,12 +791,14 @@ class SparseRandomProjection(BaseRandomProjection):
         eps=0.1,
         dense_output=False,
         random_state=None,
+        compute_inverse_components=False,
     ):
         super().__init__(
             n_components=n_components,
             eps=eps,
             dense_output=dense_output,
             random_state=random_state,
+            compute_inverse_components=compute_inverse_components,
         )
 
         self.density = density
@@ -709,4 +825,4 @@ class SparseRandomProjection(BaseRandomProjection):
         self.density_ = _check_density(self.density, n_features)
         return _sparse_random_matrix(
             n_components, n_features, density=self.density_, random_state=random_state
-        )
+        )
