diff --git a/astropy/table/operations.py b/astropy/table/operations.py
index 5d84827..b98524d 100644
--- a/astropy/table/operations.py
+++ b/astropy/table/operations.py
@@ -297,6 +297,70 @@ def vstack(tables, join_type='outer', metadata_conflicts='warn'):
     return out
 
 
+def cstack(tables, join_type='outer', metadata_conflicts='warn'):
+    """
+    Stack tables depth-wise (along the third axis)
+
+    A ``join_type`` of 'exact' means that the tables must all have exactly
+    the same column names (though the order can vary).  If ``join_type``
+    is 'inner' then the intersection of common columns will be the output.
+    A value of 'outer' (default) means the output will have the union of
+    all columns, with table values being masked where no common values are
+    available.
+
+    Parameters
+    ----------
+    tables : Table or list of Table objects
+        Table(s) to stack along the third axis (depth) with the current table
+    join_type : str
+        Join type ('inner' | 'exact' | 'outer'), default is 'outer'
+    metadata_conflicts : str
+        How to proceed with metadata conflicts. This should be one of:
+            * ``'silent'``: silently pick the last conflicting meta-data value
+            * ``'warn'``: pick the last conflicting meta-data value, but emit a warning (default)
+            * ``'error'``: raise an exception.
+
+    Returns
+    -------
+    stacked_table : `~astropy.table.Table` object
+        New table containing the stacked data from the input tables.
+
+    Examples
+    --------
+    To stack two tables depth-wise do::
+
+      >>> from astropy.table import Table, cstack
+      >>> t1 = Table({'a': [1, 2], 'b': [3, 4]}, names=('a', 'b'))
+      >>> t2 = Table({'a': [5, 6], 'b': [7, 8]}, names=('a', 'b'))
+      >>> print(t1)
+       a   b
+      --- ---
+        1   3
+        2   4
+      >>> print(t2)
+       a   b
+      --- ---
+        5   7
+        6   8
+      >>> print(cstack([t1, t2]))
+       a [2]   b [2]
+      -------- --------
+       1 .. 5  3 .. 7
+       2 .. 6  4 .. 8
+    """
+    tables = _get_list_of_tables(tables)  # validates input
+    if len(tables) == 1:
+        return tables[0]  # no point in stacking a single table
+    col_name_map = OrderedDict()
+
+    out = _cstack(tables, join_type, col_name_map, metadata_conflicts)
+
+    # Merge table metadata
+    _merge_table_meta(out, tables, metadata_conflicts=metadata_conflicts)
+
+    return out
+
+
 def hstack(tables, join_type='outer',
            uniq_col_name='{col_name}_{table_name}', table_names=None,
            metadata_conflicts='warn'):
@@ -368,6 +432,70 @@ def hstack(tables, join_type='outer',
     return out
 
 
+def cstack(tables, join_type='outer', metadata_conflicts='warn'):
+    """
+    Stack tables depth-wise (along the third axis)
+
+    A ``join_type`` of 'exact' means that the tables must all have exactly
+    the same column names (though the order can vary).  If ``join_type``
+    is 'inner' then the intersection of common columns will be the output.
+    A value of 'outer' (default) means the output will have the union of
+    all columns, with table values being masked where no common values are
+    available.
+
+    Parameters
+    ----------
+    tables : Table or list of Table objects
+        Table(s) to stack along the third axis (depth) with the current table
+    join_type : str
+        Join type ('inner' | 'exact' | 'outer'), default is 'outer'
+    metadata_conflicts : str
+        How to proceed with metadata conflicts. This should be one of:
+            * ``'silent'``: silently pick the last conflicting meta-data value
+            * ``'warn'``: pick the last conflicting meta-data value, but emit a warning (default)
+            * ``'error'``: raise an exception.
+
+    Returns
+    -------
+    stacked_table : `~astropy.table.Table` object
+        New table containing the stacked data from the input tables.
+
+    Examples
+    --------
+    To stack two tables depth-wise do::
+
+      >>> from astropy.table import Table, cstack
+      >>> t1 = Table({'a': [1, 2], 'b': [3, 4]}, names=('a', 'b'))
+      >>> t2 = Table({'a': [5, 6], 'b': [7, 8]}, names=('a', 'b'))
+      >>> print(t1)
+       a   b
+      --- ---
+        1   3
+        2   4
+      >>> print(t2)
+       a   b
+      --- ---
+        5   7
+        6   8
+      >>> print(cstack([t1, t2]))
+       a [2]   b [2]
+      -------- --------
+       1 .. 5  3 .. 7
+       2 .. 6  4 .. 8
+    """
+    tables = _get_list_of_tables(tables)  # validates input
+    if len(tables) == 1:
+        return tables[0]  # no point in stacking a single table
+    col_name_map = OrderedDict()
+
+    out = _cstack(tables, join_type, col_name_map, metadata_conflicts)
+
+    # Merge table metadata
+    _merge_table_meta(out, tables, metadata_conflicts=metadata_conflicts)
+
+    return out
+
+
 def unique(input_table, keys=None, silent=False, keep='first'):
     """
     Returns the unique rows of a table.
@@ -879,6 +1007,264 @@ def _vstack(arrays, join_type='outer', col_name_map=None, metadata_conflicts='wa
     return out
 
 
+def _cstack(arrays, join_type='outer', col_name_map=None, metadata_conflicts='warn'):
+    """
+    Stack Tables depth-wise (along the third axis)
+
+    A ``join_type`` of 'exact' (default) means that the arrays must all
+    have exactly the same column names (though the order can vary).  If
+    ``join_type`` is 'inner' then the intersection of common columns will
+    be the output.  A value of 'outer' means the output will have the union of
+    all columns, with array values being masked where no common values are
+    available.
+
+    Parameters
+    ----------
+    arrays : list of Tables
+        Tables to stack by depth (third axis)
+    join_type : str
+        Join type ('inner' | 'exact' | 'outer'), default is 'outer'
+    col_name_map : empty dict or None
+        If passed as a dict then it will be updated in-place with the
+        mapping of output to input column names.
+
+    Returns
+    -------
+    stacked_table : `~astropy.table.Table` object
+        New table containing the stacked data from the input tables.
+    """
+    # Store user-provided col_name_map until the end
+    _col_name_map = col_name_map
+
+    # Input validation
+    if join_type not in ('inner', 'exact', 'outer'):
+        raise ValueError("`join_type` arg must be one of 'inner', 'exact' or 'outer'")
+
+    # Trivial case of one input array
+    if len(arrays) == 1:
+        return arrays[0]
+
+    # Start by assuming an outer match where all names go to output
+    names = set(itertools.chain(*[arr.colnames for arr in arrays]))
+    col_name_map = get_col_name_map(arrays, names)
+
+    # If require_match is True then the output must have exactly the same
+    # number of columns as each input array
+    if join_type == 'exact':
+        for names in col_name_map.values():
+            if any(x is None for x in names):
+                raise TableMergeError('Inconsistent columns in input arrays '
+                                      "(use 'inner' or 'outer' join_type to "
+                                      "allow non-matching columns)")
+        join_type = 'outer'
+
+    # For an inner join, keep only columns where all input arrays have that column
+    if join_type == 'inner':
+        col_name_map = OrderedDict((name, in_names) for name, in_names in col_name_map.items()
+                                   if all(x is not None for x in in_names))
+        if len(col_name_map) == 0:
+            raise TableMergeError('Input arrays have no columns in common')
+
+    # Check that all tables have the same number of rows
+    n_rows = [len(arr) for arr in arrays]
+    if len(set(n_rows)) != 1:
+        raise TableMergeError("All input arrays must have same length for depth-wise stacking")
+    n_rows = n_rows[0]
+
+    out = _get_out_class(arrays)()
+
+    for out_name, in_names in col_name_map.items():
+        # List of input arrays that contribute to this output column
+        cols = []
+        for arr, name in zip(arrays, in_names):
+            if name is not None:
+                cols.append(arr[name])
+            else:
+                # Create a masked column with the same length and dtype as the first existing column.
+                # First, find the first existing column to get the dtype.
+                first_existing = None
+                for arr2, name2 in zip(arrays, in_names):
+                    if name2 is not None:
+                        first_existing = arr2[name2]
+                        break
+                if first_existing is None:
+                    # This should not happen because we are in the outer loop for a column that exists in at least one table.
+                    continue
+                # Create a masked array with the same shape as a single column (n_rows,)
+                # and fill with the mask value.
+                try:
+                    mask_val = first_existing.info.mask_val
+                except AttributeError:
+                    mask_val = np.ma.masked
+                # We need to create a column of the same type as the first_existing.
+                if isinstance(first_existing, MaskedColumn):
+                    masked_col = MaskedColumn(data=np.full(n_rows, mask_val),
+                                              mask=True,
+                                              dtype=first_existing.dtype)
+                else:
+                    # If the first column is not masked, we still need a masked column for the output.
+                    masked_col = MaskedColumn(data=np.full(n_rows, mask_val),
+                                              mask=True,
+                                              dtype=first_existing.dtype)
+                cols.append(masked_col)
+
+        # For depth-wise stacking, we need to stack the columns along a new axis.
+        # We'll create a new column that is a 2D array with shape (n_rows, n_arrays)
+        # First, get the base column class from the first column.
+        col_cls = _get_out_class(cols)
+        if not hasattr(col_cls.info, 'new_like'):
+            raise NotImplementedError('cstack unavailable for mixin column type(s): {}'
+                                      .format(col_cls.__name__))
+
+        # We want to create a column that can hold a 2D array.
+        # Convert each column to a 2D column vector (n_rows, 1)
+        col_arrays = []
+        for col in cols:
+            # Convert to numpy array, preserving masks
+            if isinstance(col, np.ma.MaskedArray):
+                col_data = np.ma.asarray(col).reshape(n_rows, 1)
+            else:
+                col_data = np.asarray(col).reshape(n_rows, 1)
+            col_arrays.append(col_data)
+
+        # Stack horizontally to get (n_rows, n_cols)
+        try:
+            if any(isinstance(col, np.ma.MaskedArray) for col in col_arrays):
+                stacked_array = np.ma.hstack(col_arrays)
+            else:
+                stacked_array = np.hstack(col_arrays)
+        except Exception as err:
+            raise TableMergeError("Cannot depth-wise stack column '{}' due to: {}"
+                                  .format(out_name, err))
+
+        # Now create the output column. We need to create a column of the appropriate type.
+        # Use the first column as a template.
+        first_col = cols[0]
+        # Check if the column is a MaskedColumn or regular Column.
+        if isinstance(stacked_array, np.ma.MaskedArray):
+            out_col = out.MaskedColumn(stacked_array, name=out_name)
+        else:
+            out_col = Column(stacked_array, name=out_name)
+
+        out[out_name] = out_col
+
+    # If col_name_map supplied as a dict input, then update.
+    if isinstance(_col_name_map, Mapping):
+        _col_name_map.update(col_name_map)
+
+    return out
+
+
+def _cstack(arrays, join_type='outer', col_name_map=None, metadata_conflicts='warn'):
+    """
+    Stack Tables depth-wise (along the third axis)
+
+    A ``join_type`` of 'exact' (default) means that the arrays must all
+    have exactly the same column names (though the order can vary).  If
+    ``join_type`` is 'inner' then the intersection of common columns will
+    be the output.  A value of 'outer' means the output will have the union of
+    all columns, with array values being masked where no common values are
+    available.
+
+    Parameters
+    ----------
+    arrays : list of Tables
+        Tables to stack by depth (third axis)
+    join_type : str
+        Join type ('inner' | 'exact' | 'outer'), default is 'outer'
+    col_name_map : empty dict or None
+        If passed as a dict then it will be updated in-place with the
+        mapping of output to input column names.
+
+    Returns
+    -------
+    stacked_table : `~astropy.table.Table` object
+        New table containing the stacked data from the input tables.
+    """
+    # Store user-provided col_name_map until the end
+    _col_name_map = col_name_map
+
+    # Input validation
+    if join_type not in ('inner', 'exact', 'outer'):
+        raise ValueError("`join_type` arg must be one of 'inner', 'exact' or 'outer'")
+
+    # Trivial case of one input array
+    if len(arrays) == 1:
+        return arrays[0]
+
+    # Start by assuming an outer match where all names go to output
+    names = set(itertools.chain(*[arr.colnames for arr in arrays]))
+    col_name_map = get_col_name_map(arrays, names)
+
+    # If require_match is True then the output must have exactly the same
+    # number of columns as each input array
+    if join_type == 'exact':
+        for names in col_name_map.values():
+            if any(x is None for x in names):
+                raise TableMergeError('Inconsistent columns in input arrays '
+                                      "(use 'inner' or 'outer' join_type to "
+                                      "allow non-matching columns)")
+        join_type = 'outer'
+
+    # For an inner join, keep only columns where all input arrays have that column
+    if join_type == 'inner':
+        col_name_map = OrderedDict((name, in_names) for name, in_names in col_name_map.items()
+                                   if all(x is not None for x in in_names))
+        if len(col_name_map) == 0:
+            raise TableMergeError('Input arrays have no columns in common')
+
+    # Check that all tables have the same number of rows
+    n_rows = [len(arr) for arr in arrays]
+    if len(set(n_rows)) != 1:
+        raise TableMergeError("All input arrays must have same length for depth-wise stacking")
+    n_rows = n_rows[0]
+
+    out = _get_out_class(arrays)()
+
+    for out_name, in_names in col_name_map.items():
+        # List of input arrays that contribute to this output column
+        cols = [arr[name] for arr, name in zip(arrays, in_names) if name is not None]
+
+        # For depth-wise stacking, we need to stack the columns along a new axis.
+        # We'll create a new column that is a 2D array with shape (n_rows, n_arrays)
+        # First, get the base column class from the first column that exists.
+        col_cls = _get_out_class(cols)
+        if not hasattr(col_cls.info, 'new_like'):
+            raise NotImplementedError('cstack unavailable for mixin column type(s): {}'
+                                      .format(col_cls.__name__))
+
+        # We want to create a column that can hold a 2D array.
+        # The new_like method is designed for vstack, so we need to adapt.
+        # Instead, we can create a new column by concatenating the columns depth-wise.
+        # We'll use numpy.dstack if possible.
+        try:
+            # Convert each column to a 2D column vector (n_rows, 1)
+            col_arrays = [np.asarray(col).reshape(n_rows, 1) for col in cols]
+            # Stack horizontally to get (n_rows, n_cols)
+            stacked_array = np.hstack(col_arrays)
+        except Exception as err:
+            raise TableMergeError("Cannot depth-wise stack column '{}' due to: {}"
+                                  .format(out_name, err))
+
+        # Now create the output column. We need to create a column of the appropriate type.
+        # Use the first column as a template.
+        first_col = cols[0]
+        # Check if the column is a MaskedColumn or regular Column.
+        if isinstance(first_col, MaskedColumn) or any(isinstance(col, MaskedColumn) for col in cols):
+            # If any input column is masked, the output should be masked.
+            out_col = out.MaskedColumn(stacked_array, name=out_name)
+        else:
+            out_col = Column(stacked_array, name=out_name)
+
+        out[out_name] = out_col
+
+    # If col_name_map supplied as a dict input, then update.
+    if isinstance(_col_name_map, Mapping):
+        _col_name_map.update(col_name_map)
+
+    return out
+
+
 def _hstack(arrays, join_type='outer', uniq_col_name='{col_name}_{table_name}',
            table_names=None, col_name_map=None):
     """
