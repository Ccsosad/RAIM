diff --git a/seaborn/categorical.py b/seaborn/categorical.py
index 27d5801..451868f 100644
--- a/seaborn/categorical.py
+++ b/seaborn/categorical.py
@@ -1358,6 +1358,56 @@ class _CategoricalScatterPlotter(_CategoricalPlotter):
 
 class _SwarmPlotter(_CategoricalScatterPlotter):
 
+    class Beeswarm:
+        def __init__(self, artist, orig_xy, sorted_xy, sorter, center, width, s, kws, orient, plotter):
+            self.artist = artist
+            self.orig_xy = orig_xy
+            self.sorted_xy = sorted_xy
+            self.sorter = sorter
+            self.center = center
+            self.width = width
+            self.s = s
+            self.kws = kws
+            self.orient = orient
+            self.plotter = plotter
+
+        def update(self, ax):
+            # Transform the sorted data to point coordinates
+            if self.orient == "h":
+                points = self.sorted_xy[:, [1, 0]]
+            else:
+                points = self.sorted_xy
+            orig_xy = ax.transData.transform(points)
+
+            # Compute the point diameter
+            default_lw = mpl.rcParams["patch.linewidth"]
+            lw = self.kws.get("linewidth", self.kws.get("lw", default_lw))
+            dpi = ax.figure.dpi
+            d = (np.sqrt(self.s) + lw) * (dpi / 72)
+
+            # Do the beeswarm in point coordinates
+            if self.orient == "h":
+                orig_xy = orig_xy[:, [1, 0]]
+            new_xy = self.plotter.beeswarm(orig_xy, d)
+            if self.orient == "h":
+                new_xy = new_xy[:, [1, 0]]
+
+            # Transform back to data coordinates
+            new_x, new_y = ax.transData.inverted().transform(new_xy).T
+
+            # Add gutters
+            if self.orient == "v":
+                self.plotter.add_gutters(new_x, self.center, self.width)
+            else:
+                self.plotter.add_gutters(new_y, self.center, self.width)
+
+            # Reorder to original order
+            offsets = np.c_[new_x, new_y]
+            # offsets are for sorted data, so we need to reorder
+            orig_offsets = np.empty_like(offsets)
+            orig_offsets[self.sorter] = offsets
+            self.artist.set_offsets(orig_offsets)
+
     def __init__(self, x, y, hue, data, order, hue_order,
                  dodge, orient, color, palette):
         """Initialize the plotter."""
@@ -1558,10 +1608,10 @@ class _SwarmPlotter(_CategoricalScatterPlotter):
 
                 # Sort the points for the beeswarm algorithm
                 sorter = np.argsort(swarm_data)
-                swarm_data = swarm_data[sorter]
-                point_colors = point_colors[sorter]
+                sorted_swarm_data = swarm_data[sorter]
+                sorted_point_colors = point_colors[sorter]
 
-                # Plot the points in centered positions
+                # Plot the points in centered positions with original data
                 cat_pos = np.ones(swarm_data.size) * i
                 kws.update(c=palette[point_colors])
                 if self.orient == "v":
@@ -1569,6 +1619,20 @@ class _SwarmPlotter(_CategoricalScatterPlotter):
                 else:
                     points = ax.scatter(swarm_data, cat_pos, s=s, **kws)
 
+                # Store the original and sorted data for the callback
+                if self.orient == "v":
+                    orig_xy = np.c_[cat_pos, swarm_data]
+                    sorted_xy = np.c_[cat_pos[sorter], sorted_swarm_data]
+                else:
+                    orig_xy = np.c_[swarm_data, cat_pos]
+                    sorted_xy = np.c_[sorted_swarm_data, cat_pos[sorter]]
+
+                beeswarm = self.Beeswarm(points, orig_xy, sorted_xy, sorter,
+                                         i, self.width, s, kws, self.orient, self)
+                if not hasattr(ax, '_seaborn_beeswarms'):
+                    ax._seaborn_beeswarms = []
+                ax._seaborn_beeswarms.append(beeswarm)
+
                 centers.append(i)
                 swarms.append(points)
 
@@ -1601,11 +1665,17 @@ class _SwarmPlotter(_CategoricalScatterPlotter):
         # Autoscale the valus axis to set the data/axes transforms properly
         ax.autoscale_view(scalex=self.orient == "h", scaley=self.orient == "v")
 
-        # Update the position of each point on the categorical axis
-        # Do this after plotting so that the numerical axis limits are correct
-        for center, swarm in zip(centers, swarms):
-            if swarm.get_offsets().size:
-                self.swarm_points(ax, swarm, center, width, s, **kws)
+        # Define a callback to update the swarms at draw time
+        def update_swarms(ax):
+            if hasattr(ax, '_seaborn_beeswarms'):
+                for beeswarm in ax._seaborn_beeswarms:
+                    beeswarm.update(ax)
+
+        # Connect the callback
+        ax.callbacks.connect('draw_event', lambda event: update_swarms(ax))
+
+        # Update the swarms once initially
+        update_swarms(ax)
 
     def plot(self, ax, kws):
         """Make the full plot."""
