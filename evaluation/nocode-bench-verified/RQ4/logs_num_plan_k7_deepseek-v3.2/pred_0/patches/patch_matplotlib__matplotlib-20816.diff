diff --git a/lib/matplotlib/cbook/__init__.py b/lib/matplotlib/cbook/__init__.py
index 5c3e852..ac81a68 100644
--- a/lib/matplotlib/cbook/__init__.py
+++ b/lib/matplotlib/cbook/__init__.py
@@ -175,6 +175,9 @@ class CallbackRegistry:
         self._func_cid_map = {}
         # A hidden variable that marks cids that need to be pickled.
         self._pickled_cids = set()
+        # Blocking state
+        self._blocked = False
+        self._blocked_signals = set()
 
     def __getstate__(self):
         return {
@@ -267,6 +270,9 @@ class CallbackRegistry:
         All of the functions registered to receive callbacks on *s* will be
         called with ``*args`` and ``**kwargs``.
         """
+        # Skip if all signals are blocked or this specific signal is blocked.
+        if self._blocked or s in self._blocked_signals:
+            return
         for cid, ref in list(self.callbacks.get(s, {}).items()):
             func = ref()
             if func is not None:
@@ -281,6 +287,87 @@ class CallbackRegistry:
                         raise
 
 
+    def blocked(self, *, signal=None):
+        """
+        Context manager to temporarily block callback signals.
+
+        Parameters
+        ----------
+        signal : str, optional
+            If provided, only block the given signal. Otherwise, block all
+            signals.
+
+        Examples
+        --------
+        >>> with callbacks.blocked():
+        ...     # All signals are blocked
+        ...     pass
+        >>> with callbacks.blocked(signal="key_press_event"):
+        ...     # Only "key_press_event" is blocked
+        ...     pass
+        """
+        class _BlockContextManager:
+            def __init__(self, registry, signal):
+                self.registry = registry
+                self.signal = signal
+                self.old_blocked = None
+                self.old_state = None
+
+            def __enter__(self):
+                if self.signal is None:
+                    self.old_blocked = self.registry._blocked
+                    self.registry._blocked = True
+                else:
+                    self.old_state = self.signal in self.registry._blocked_signals
+                    self.registry._blocked_signals.add(self.signal)
+
+            def __exit__(self, *args):
+                if self.signal is None:
+                    self.registry._blocked = self.old_blocked
+                else:
+                    if not self.old_state:
+                        self.registry._blocked_signals.discard(self.signal)
+
+        return _BlockContextManager(self, signal)
+
+    @contextlib.contextmanager
+    def blocked(self, *, signal=None):
+        """
+        Context manager to temporarily block callback signals.
+
+        Parameters
+        ----------
+        signal : str, optional
+            If provided, only block the given signal. Otherwise, block all
+            signals.
+
+        Examples
+        --------
+        >>> with callbacks.blocked():
+        ...     # All signals are blocked
+        ...     pass
+        >>> with callbacks.blocked(signal="key_press_event"):
+        ...     # Only "key_press_event" is blocked
+        ...     pass
+        """
+        if signal is None:
+            # Block all signals
+            old_blocked = self._blocked
+            self._blocked = True
+            try:
+                yield
+            finally:
+                self._blocked = old_blocked
+        else:
+            # Block a specific signal
+            old_state = signal in self._blocked_signals
+            self._blocked_signals.add(signal)
+            try:
+                yield
+            finally:
+                if not old_state:
+                    self._blocked_signals.remove(signal)
+
 class silent_list(list):
     """
     A list with a short ``repr()``.
