diff --git a/lib/matplotlib/axes/_axes.py b/lib/matplotlib/axes/_axes.py
index eed9d35..0c2f5d3 100644
--- a/lib/matplotlib/axes/_axes.py
+++ b/lib/matplotlib/axes/_axes.py
@@ -8400,6 +8400,112 @@ such objects
 
         return artists
 
+    @_preprocess_data(replace_names=["x", "y", "z"])
+    @_docstring.dedent_interpd
+    def contour(self, *args, clip_path=None, **kwargs):
+        """
+        Plot contour lines.
+
+        Call signature::
+
+            contour([X, Y,] Z, [levels], **kwargs)
+
+        Parameters
+        ----------
+        X, Y : array-like, optional
+            The coordinates of the values in *Z*.
+
+            *X* and *Y* must both be 2D with the same shape as *Z* (e.g.
+            created via `numpy.meshgrid`), or they must both be 1-D such
+            that ``len(X) == M`` is the number of columns in *Z* and
+            ``len(Y) == N`` is the number of rows in *Z*.
+
+            If not given, they are assumed to be integer indices, i.e.
+            ``X = range(M)``, ``Y = range(N)``.
+
+        Z : (M, N) array-like
+            The height values over which the contour is drawn.
+
+        levels : int or array-like, optional
+            Determines the number and positions of the contour lines / regions.
+
+            If an int *n*, use *n* data intervals; i.e. draw *n+1* contour
+            lines. The level heights are automatically chosen.
+
+            If array-like, draw contour lines at the specified levels.
+            The values must be in increasing order.
+
+        clip_path : `~matplotlib.patches.Patch` or None, optional
+            If not None, clip the contour lines or filled regions to the given
+            patch. The patch must be in the same axes.
+
+        Returns
+        -------
+        `~matplotlib.contour.QuadContourSet`
+
+        Other Parameters
+        ----------------
+        %(contour_doc)s
+        """
+        kwargs['filled'] = False
+        kwargs['clip_path'] = clip_path
+        contours = QuadContourSet(self, *args, **kwargs)
+        self._request_autoscale_view()
+        return contours
+
+    @_preprocess_data(replace_names=["x", "y", "z"])
+    @_docstring.dedent_interpd
+    def contourf(self, *args, clip_path=None, **kwargs):
+        """
+        Plot filled contours.
+
+        Call signature::
+
+            contourf([X, Y,] Z, [levels], **kwargs)
+
+        Parameters
+        ----------
+        X, Y : array-like, optional
+            The coordinates of the values in *Z*.
+
+            *X* and *Y* must both be 2D with the same shape as *Z* (e.g.
+            created via `numpy.meshgrid`), or they must both be 1-D such
+            that ``len(X) == M`` is the number of columns in *Z* and
+            ``len(Y) == N`` is the number of rows in *Z*.
+
+            If not given, they are assumed to be integer indices, i.e.
+            ``X = range(M)``, ``Y = range(N)``.
+
+        Z : (M, N) array-like
+            The height values over which the contour is drawn.
+
+        levels : int or array-like, optional
+            Determines the number and positions of the contour lines / regions.
+
+            If an int *n*, use *n* data intervals; i.e. draw *n+1* contour
+            lines. The level heights are automatically chosen.
+
+            If array-like, draw contour lines at the specified levels.
+            The values must be in increasing order.
+
+        clip_path : `~matplotlib.patches.Patch` or None, optional
+            If not None, clip the contour lines or filled regions to the given
+            patch. The patch must be in the same axes.
+
+        Returns
+        -------
+        `~matplotlib.contour.QuadContourSet`
+
+        Other Parameters
+        ----------------
+        %(contour_doc)s
+        """
+        kwargs['filled'] = True
+        kwargs['clip_path'] = clip_path
+        contours = QuadContourSet(self, *args, **kwargs)
+        self._request_autoscale_view()
+        return contours
+
     # Methods that are entirely implemented in other modules.
 
     table = mtable.table
@@ -8423,4 +8529,4 @@ such objects
         figure_size = self.get_figure().get_size_inches()
         ll, ur = self.get_position() * figure_size
         width, height = ur - ll
-        return height / (width * self.get_data_ratio())
+        return height / (width * self.get_data_ratio())
