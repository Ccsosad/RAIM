diff --git a/sklearn/random_projection.py b/sklearn/random_projection.py
index d06dfcd..6c82d0f 100644
--- a/sklearn/random_projection.py
+++ b/sklearn/random_projection.py
@@ -302,11 +302,18 @@ class BaseRandomProjection(
 
     @abstractmethod
     def __init__(
-        self, n_components="auto", *, eps=0.1, dense_output=False, random_state=None
+        self,
+        n_components="auto",
+        *,
+        eps=0.1,
+        dense_output=False,
+        compute_inverse_components=False,
+        random_state=None,
     ):
         self.n_components = n_components
         self.eps = eps
         self.dense_output = dense_output
+        self.compute_inverse_components = compute_inverse_components
         self.random_state = random_state
 
     @abstractmethod
@@ -399,6 +406,22 @@ class BaseRandomProjection(
             " not the proper shape."
         )
 
+        # Compute inverse components if requested
+        if self.compute_inverse_components:
+            # Compute the pseudo-inverse of components_
+            # components_ is (n_components, n_features)
+            # We want inverse_components_ of shape (n_features, n_components)
+            # Use pinv for dense or sparse? We convert to dense for pinv.
+            # The result should be dense.
+            from scipy.linalg import pinv
+
+            components = self.components_
+            if sp.issparse(components):
+                components = components.toarray()
+            self.inverse_components_ = pinv(components, rcond=1e-15, hermitian=False)
+        else:
+            self.inverse_components_ = None
+
         return self
 
     def transform(self, X):
@@ -429,6 +452,89 @@ class BaseRandomProjection(
         X_new = safe_sparse_dot(X, self.components_.T, dense_output=self.dense_output)
         return X_new
 
+    def inverse_transform(self, X):
+        """Project data back to its original space.
+
+        Parameters
+        ----------
+        X : {ndarray, sparse matrix} of shape (n_samples, n_components)
+            Data to be transformed back.
+
+        Returns
+        ----------
+        X_original : ndarray of shape (n_samples, n_features)
+            Reconstructed data.
+        """
+        check_is_fitted(self)
+        from sklearn.utils.validation import check_array
+        X = check_array(X, accept_sparse=False, dtype=[np.float64, np.float32])
+
+        if X.shape[1] != self.n_components_:
+            raise ValueError(
+                "X should have %d features, but got %d"
+                % (self.n_components_, X.shape[1])
+            )
+
+        # If inverse_components_ is precomputed, use it
+        if hasattr(self, "inverse_components_") and self.inverse_components_ is not None:
+            inv_comp = self.inverse_components_
+        else:
+            # Otherwise compute the pseudo-inverse on the fly
+            from scipy.linalg import pinv
+
+            components = self.components_
+            if sp.issparse(components):
+                components = components.toarray()
+            inv_comp = pinv(components, rcond=1e-15, hermitian=False)
+
+        # The inverse transform is X * inv_comp.T
+        # inv_comp is (n_features, n_components)
+        # So we do X (n_samples, n_components) * inv_comp.T (n_components, n_features)
+        # Result is (n_samples, n_features)
+        X_original = X @ inv_comp.T
+        return X_original
+
+    def inverse_transform(self, X):
+        """Project data back to its original space.
+
+        Parameters
+        ----------
+        X : {ndarray, sparse matrix} of shape (n_samples, n_components)
+            Data to be transformed back.
+
+        Returns
+        -------
+        X_original : ndarray of shape (n_samples, n_features)
+            Reconstructed data.
+        """
+        check_is_fitted(self)
+        X = check_array(X, accept_sparse=False, dtype=[np.float64, np.float32])
+
+        if X.shape[1] != self.n_components_:
+            raise ValueError(
+                "X should have %d features, but got %d"
+                % (self.n_components_, X.shape[1])
+            )
+
+        # If inverse_components_ is precomputed, use it
+        if hasattr(self, "inverse_components_") and self.inverse_components_ is not None:
+            inv_comp = self.inverse_components_
+        else:
+            # Otherwise compute the pseudo-inverse on the fly
+            from scipy.linalg import pinv
+
+            components = self.components_
+            if sp.issparse(components):
+                components = components.toarray()
+            inv_comp = pinv(components, rcond=1e-15, hermitian=False)
+
+        # The inverse transform is X * inv_comp.T
+        # inv_comp is (n_features, n_components)
+        # So we do X (n_samples, n_components) * inv_comp.T (n_components, n_features)
+        # Result is (n_samples, n_features)
+        X_original = X @ inv_comp.T
+        return X_original
+
     @property
     def _n_features_out(self):
         """Number of transformed output features.
