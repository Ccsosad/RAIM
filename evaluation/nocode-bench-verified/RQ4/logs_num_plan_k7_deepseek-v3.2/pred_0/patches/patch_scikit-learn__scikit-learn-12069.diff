diff --git a/sklearn/decomposition/_kernel_pca.py b/sklearn/decomposition/_kernel_pca.py
index 6f0266a..5434e33 100644
--- a/sklearn/decomposition/_kernel_pca.py
+++ b/sklearn/decomposition/_kernel_pca.py
@@ -59,10 +59,12 @@ class KernelPCA(TransformerMixin, BaseEstimator):
         Learn the inverse transform for non-precomputed kernels.
         (i.e. learn to find the pre-image of a point)
 
-    eigen_solver : {'auto', 'dense', 'arpack'}, default='auto'
+    eigen_solver : {'auto', 'dense', 'arpack', 'randomized'}, default='auto'
         Select eigensolver to use. If n_components is much less than
         the number of training samples, arpack may be more efficient
-        than the dense eigensolver.
+        than the dense eigensolver. The randomized solver can be
+        significantly faster when the number of components is small
+        compared to the number of samples.
 
     tol : float, default=0
         Convergence tolerance for arpack.
@@ -80,12 +82,18 @@ class KernelPCA(TransformerMixin, BaseEstimator):
         with zero eigenvalues are removed regardless.
 
     random_state : int, RandomState instance or None, default=None
-        Used when ``eigen_solver`` == 'arpack'. Pass an int for reproducible
-        results across multiple function calls.
+        Used when ``eigen_solver`` == 'arpack' or 'randomized'. Pass an int
+        for reproducible results across multiple function calls.
         See :term:`Glossary <random_state>`.
 
         .. versionadded:: 0.18
 
+    n_oversamples : int, default=10
+        Number of oversamples for the randomized solver. See
+        :func:`~sklearn.utils.extmath.randomized_svd` for more details.
+
+        .. versionadded:: 1.0
+
     copy_X : bool, default=True
         If True, input X is copied and stored by the model in the `X_fit_`
         attribute. If no further changes will be done to X, setting
@@ -147,7 +155,8 @@ class KernelPCA(TransformerMixin, BaseEstimator):
                  gamma=None, degree=3, coef0=1, kernel_params=None,
                  alpha=1.0, fit_inverse_transform=False, eigen_solver='auto',
                  tol=0, max_iter=None, remove_zero_eig=False,
-                 random_state=None, copy_X=True, n_jobs=None):
+                 random_state=None, copy_X=True, n_jobs=None,
+                 n_oversamples=10):
         if fit_inverse_transform and kernel == 'precomputed':
             raise ValueError(
                 "Cannot fit_inverse_transform with a precomputed kernel.")
@@ -166,6 +175,7 @@ class KernelPCA(TransformerMixin, BaseEstimator):
         self.random_state = random_state
         self.n_jobs = n_jobs
         self.copy_X = copy_X
+        self.n_oversamples = n_oversamples
 
     # TODO: Remove in 1.1
     # mypy error: Decorated property not supported
@@ -215,6 +225,19 @@ class KernelPCA(TransformerMixin, BaseEstimator):
                                                 tol=self.tol,
                                                 maxiter=self.max_iter,
                                                 v0=v0)
+        elif eigen_solver == 'randomized':
+            from ..utils.extmath import randomized_svd
+            # Note: randomized_svd returns U, S, Vt. We need U and S.
+            # Since K is symmetric, the left singular vectors are the same as the right.
+            # We compute the SVD of K to get the eigenvectors and eigenvalues.
+            n_components_rand = min(n_components, K.shape[0] - 1)
+            U, S, _ = randomized_svd(K, n_components=n_components_rand,
+                                     n_oversamples=self.n_oversamples,
+                                     random_state=self.random_state)
+            self.lambdas_ = S
+            self.alphas_ = U
+        else:
+            raise ValueError("Unsupported eigen solver: %s" % eigen_solver)
 
         # make sure that the eigenvalues are ok and fix numerical issues
         self.lambdas_ = _check_psd_eigenvalues(self.lambdas_,
@@ -388,4 +411,4 @@ class KernelPCA(TransformerMixin, BaseEstimator):
 
     def _more_tags(self):
         return {'preserves_dtype': [np.float64, np.float32],
-                'pairwise': self.kernel == 'precomputed'}
+                'pairwise': self.kernel == 'precomputed'}
