diff --git a/astropy/modeling/core.py b/astropy/modeling/core.py
index bb1fcca..d7bffb7 100644
--- a/astropy/modeling/core.py
+++ b/astropy/modeling/core.py
@@ -3369,6 +3369,253 @@ def binary_operation(binoperator, left, right):
         return binoperator(left, right)
 
 
+def fix_inputs(model, fixed_inputs):
+    """
+    Create a new model by fixing one or more inputs of the given model.
+
+    Parameters
+    ----------
+    model : `~astropy.modeling.Model`
+        The model to fix inputs of.
+    fixed_inputs : dict
+        A dictionary mapping input names or indices to constant values.
+
+    Returns
+    -------
+    fixed_model : `~astropy.modeling.Model`
+        A new model with the specified inputs fixed.
+
+    Examples
+    --------
+    >>> from astropy.modeling.models import Polynomial2D
+    >>> poly = Polynomial2D(degree=2)
+    >>> fixed = fix_inputs(poly, {'x': 0})
+    >>> fixed(1)  # evaluates poly at x=0, y=1
+    """
+    from .core import Model
+    return _FixedInputsModel(model, fixed_inputs)
+
+
+class _FixedInputsModel(Model):
+    """
+    A model that wraps another model with some inputs fixed to constant values.
+
+    This is not meant to be instantiated directly; use `fix_inputs` instead.
+    """
+
+    def __init__(self, model, fixed_inputs):
+        # Determine the mapping from new input indices to old input indices
+        # and the constants for fixed inputs.
+        old_inputs = list(model.inputs)
+        new_inputs = []
+        self._fixed_values = []
+        self._fixed_indices = []  # indices in the old model that are fixed
+        self._free_indices = []   # indices in the old model that are free
+
+        # Process fixed_inputs: they can be given by name or index
+        for key, value in fixed_inputs.items():
+            if isinstance(key, str):
+                try:
+                    idx = old_inputs.index(key)
+                except ValueError:
+                    raise ValueError(f"Input {key} not found in model inputs.")
+            else:
+                idx = key
+                if idx < 0 or idx >= model.n_inputs:
+                    raise IndexError(f"Input index {idx} out of range.")
+            self._fixed_indices.append(idx)
+            self._fixed_values.append(value)
+
+        # Build the list of free inputs
+        for i in range(model.n_inputs):
+            if i not in self._fixed_indices:
+                self._free_indices.append(i)
+                new_inputs.append(old_inputs[i])
+
+        # Initialize the base Model
+        super().__init__()
+        self._model = model
+        self._n_inputs = len(new_inputs)
+        self._n_outputs = model.n_outputs
+        self.inputs = tuple(new_inputs)
+        self.outputs = model.outputs
+
+        # Copy other properties
+        self.linear = model.linear
+        self.fittable = model.fittable
+
+        # Handle bounding box
+        if hasattr(model, 'bounding_box') and model.bounding_box is not None:
+            # Remove the fixed dimensions from the bounding box
+            bbox = model.bounding_box
+            if model.n_inputs == 1:
+                # 1D bounding box is a tuple
+                if 0 in self._fixed_indices:
+                    # The only input is fixed, so no bounding box
+                    self._bounding_box = None
+                else:
+                    self._bounding_box = bbox
+            else:
+                # Multi-dimensional bounding box is a tuple of tuples
+                new_bbox = []
+                for i in range(model.n_inputs):
+                    if i not in self._fixed_indices:
+                        new_bbox.append(bbox[i])
+                if len(new_bbox) == 1:
+                    self._bounding_box = new_bbox[0]
+                else:
+                    self._bounding_box = tuple(new_bbox)
+        else:
+            self._bounding_box = None
+
+    def __call__(self, *args, **kwargs):
+        # Build the full input list for the original model
+        full_args = [None] * self._model.n_inputs
+        # Set the fixed values
+        for idx, val in zip(self._fixed_indices, self._fixed_values):
+            full_args[idx] = val
+        # Set the free values from args
+        for i, arg in enumerate(args):
+            full_args[self._free_indices[i]] = arg
+        # Call the original model
+        return self._model(*full_args, **kwargs)
+
+    @property
+    def bounding_box(self):
+        return self._bounding_box
+
+    @bounding_box.setter
+    def bounding_box(self, value):
+        self._bounding_box = value
+
+    @bounding_box.deleter
+    def bounding_box(self):
+        self._bounding_box = None
+
+
+def fix_inputs(model, fixed_inputs):
+    """
+    Create a new model by fixing one or more inputs of the given model.
+
+    Parameters
+    ----------
+    model : `~astropy.modeling.Model`
+        The model to fix inputs of.
+    fixed_inputs : dict
+        A dictionary mapping input names or indices to constant values.
+
+    Returns
+    -------
+    fixed_model : `~astropy.modeling.Model`
+        A new model with the specified inputs fixed.
+
+    Examples
+    --------
+    >>> from astropy.modeling.models import Polynomial2D
+    >>> poly = Polynomial2D(degree=2)
+    >>> fixed = fix_inputs(poly, {'x': 0})
+    >>> fixed(1)  # evaluates poly at x=0, y=1
+    """
+    return _FixedInputsModel(model, fixed_inputs)
+
+
+class _FixedInputsModel(Model):
+    """
+    A model that wraps another model with some inputs fixed to constant values.
+
+    This is not meant to be instantiated directly; use `fix_inputs` instead.
+    """
+
+    def __init__(self, model, fixed_inputs):
+        # Determine the mapping from new input indices to old input indices
+        # and the constants for fixed inputs.
+        old_inputs = list(model.inputs)
+        new_inputs = []
+        self._fixed_values = []
+        self._fixed_indices = []  # indices in the old model that are fixed
+        self._free_indices = []   # indices in the old model that are free
+
+        # Process fixed_inputs: they can be given by name or index
+        for key, value in fixed_inputs.items():
+            if isinstance(key, str):
+                try:
+                    idx = old_inputs.index(key)
+                except ValueError:
+                    raise ValueError(f"Input {key} not found in model inputs.")
+            else:
+                idx = key
+                if idx < 0 or idx >= model.n_inputs:
+                    raise IndexError(f"Input index {idx} out of range.")
+            self._fixed_indices.append(idx)
+            self._fixed_values.append(value)
+
+        # Build the list of free inputs
+        for i in range(model.n_inputs):
+            if i not in self._fixed_indices:
+                self._free_indices.append(i)
+                new_inputs.append(old_inputs[i])
+
+        # Initialize the base Model
+        super().__init__()
+        self._model = model
+        self._n_inputs = len(new_inputs)
+        self._n_outputs = model.n_outputs
+        self.inputs = tuple(new_inputs)
+        self.outputs = model.outputs
+
+        # Copy other properties
+        self.linear = model.linear
+        self.fittable = model.fittable
+
+        # Handle bounding box
+        if hasattr(model, 'bounding_box') and model.bounding_box is not None:
+            # Remove the fixed dimensions from the bounding box
+            bbox = model.bounding_box
+            if model.n_inputs == 1:
+                # 1D bounding box is a tuple
+                if 0 in self._fixed_indices:
+                    # The only input is fixed, so no bounding box
+                    self._bounding_box = None
+                else:
+                    self._bounding_box = bbox
+            else:
+                # Multi-dimensional bounding box is a tuple of tuples
+                new_bbox = []
+                for i in range(model.n_inputs):
+                    if i not in self._fixed_indices:
+                        new_bbox.append(bbox[i])
+                if len(new_bbox) == 1:
+                    self._bounding_box = new_bbox[0]
+                else:
+                    self._bounding_box = tuple(new_bbox)
+        else:
+            self._bounding_box = None
+
+    def __call__(self, *args, **kwargs):
+        # Build the full input list for the original model
+        full_args = [None] * self._model.n_inputs
+        # Set the fixed values
+        for idx, val in zip(self._fixed_indices, self._fixed_values):
+            full_args[idx] = val
+        # Set the free values from args
+        for i, arg in enumerate(args):
+            full_args[self._free_indices[i]] = arg
+        # Call the original model
+        return self._model(*full_args, **kwargs)
+
+    @property
+    def bounding_box(self):
+        return self._bounding_box
+
+    @bounding_box.setter
+    def bounding_box(self, value):
+        self._bounding_box = value
+
+    @bounding_box.deleter
+    def bounding_box(self):
+        self._bounding_box = None
+
+
 def get_ops(tree, opset):
     """
     Recursive function to collect operators used.
