diff --git a/astropy/table/table.py b/astropy/table/table.py
index dbde177..ced57ef 100644
--- a/astropy/table/table.py
+++ b/astropy/table/table.py
@@ -818,17 +818,25 @@ class Table:
         # exception later, so NO need to catch here.
 
         cols = {}
+        has_missing = False
         for name in names_from_data:
             cols[name] = []
             for i, row in enumerate(data):
                 try:
                     cols[name].append(row[name])
                 except KeyError:
-                    raise ValueError(f'Row {i} has no value for column {name}')
+                    # Instead of raising an error, we will create a masked value.
+                    # We append None as a placeholder and later will mask it.
+                    cols[name].append(None)
+                    has_missing = True
 
         if all(name is None for name in names):
             names = names_from_data
 
+        # If there are missing values, we need to create a masked table.
+        if has_missing and not self.masked:
+            self._set_masked(True)
+
         self._init_from_dict(cols, names, dtype, n_cols, copy)
         return
 
@@ -950,25 +958,34 @@ class Table:
             # Then check if there were any masked elements.  This logic is handling
             # normal lists like [1, 2] but also odd-ball cases like a list of masked
             # arrays (see #8977).  Use np.ma.array() to do the heavy lifting.
-            try:
-                np_data = np.ma.array(data, dtype=dtype)
-            except Exception:
-                # Conversion failed for some reason, e.g. [2, 1*u.m] gives TypeError in Quantity
-                np_data = np.ma.array(data, dtype=object)
-
-            if np_data.ndim > 0 and len(np_data) == 0:
-                # Implies input was an empty list (e.g. initializing an empty table
-                # with pre-declared names and dtypes but no data).  Here we need to
-                # fall through to initializing with the original data=[].
-                col_cls = self.ColumnClass
+            # First, check if there are any None values in the list.
+            if isinstance(data, (list, tuple)) and any(val is None for val in data):
+                # Create a masked array with None values masked.
+                # We'll create an array of objects and mask the None values.
+                np_data = np.ma.array(data, dtype=object, mask=[val is None for val in data])
+                data = np_data
+                col_cls = masked_col_cls
+                copy = False
             else:
-                if np_data.mask is np.ma.nomask:
-                    data = np_data.data
+                try:
+                    np_data = np.ma.array(data, dtype=dtype)
+                except Exception:
+                    # Conversion failed for some reason, e.g. [2, 1*u.m] gives TypeError in Quantity
+                    np_data = np.ma.array(data, dtype=object)
+
+                if np_data.ndim > 0 and len(np_data) == 0:
+                    # Implies input was an empty list (e.g. initializing an empty table
+                    # with pre-declared names and dtypes but no data).  Here we need to
+                    # fall through to initializing with the original data=[].
                     col_cls = self.ColumnClass
                 else:
-                    data = np_data
-                    col_cls = masked_col_cls
-                copy = False
+                    if np_data.mask is np.ma.nomask:
+                        data = np_data.data
+                        col_cls = self.ColumnClass
+                    else:
+                        data = np_data
+                        col_cls = masked_col_cls
+                    copy = False
 
         else:
             # `data` is none of the above, so just go for it and try init'ing Column
