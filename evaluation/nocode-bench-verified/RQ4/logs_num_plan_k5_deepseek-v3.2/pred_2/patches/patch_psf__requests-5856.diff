diff --git a/requests/__init__.py b/requests/__init__.py
new file mode 100644
index 0000000..34bbb3e
--- /dev/null
+++ b/requests/__init__.py
@@ -0,0 +1,5 @@
+from .exceptions import (
+    RequestException, Timeout, URLRequired,
+    TooManyRedirects, HTTPError, ConnectionError,
+    FileModeWarning, ConnectTimeout, ReadTimeout, JSONDecodeError
+)
diff --git a/requests/exceptions.py b/requests/exceptions.py
new file mode 100644
index 0000000..96f4f46
--- /dev/null
+++ b/requests/exceptions.py
@@ -0,0 +1,6 @@
+class InvalidJSONError(RequestException):
+    """A JSON error occurred."""
+
+
+class JSONDecodeError(InvalidJSONError, ValueError):
+    """Failed to decode JSON text into Python object."""
diff --git a/requests/models.py b/requests/models.py
new file mode 100644
index 0000000..b6762be
--- /dev/null
+++ b/requests/models.py
@@ -0,0 +1,28 @@
+    def json(self, **kwargs):
+        r"""Returns the json-encoded content of a response, if any.
+
+        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.
+        :raises requests.exceptions.JSONDecodeError: If the response body does not contain valid json.
+        """
+        if not self.encoding and self.content and len(self.content) > 3:
+            # No encoding set. JSON RFC 4627 section 3 states we should expect
+            # UTF-8, -16 or -32. Detect which one to use; If the detection or
+            # decoding fails, fall back to `self.text` (using charset_normalizer to make
+            # a best guess).
+            encoding = guess_json_utf(self.content)
+            if encoding is not None:
+                try:
+                    return complexjson.loads(
+                        self.content.decode(encoding), **kwargs
+                    )
+                except UnicodeDecodeError:
+                    # Wrong UTF codec detected; usually because it's not UTF-8
+                    # but some other 8-bit codec.  This is an RFC violation,
+                    # but the server might have forgotten the charset.
+                    pass
+        try:
+            return complexjson.loads(self.text, **kwargs)
+        except (ValueError, JSONDecodeError) as e:
+            # Catch JSON-related exceptions and re-raise as requests.exceptions.JSONDecodeError
+            # Note: JSONDecodeError is from the json module (Python 3) or simplejson
+            raise JSONDecodeError(e, request=self.request, response=self)
