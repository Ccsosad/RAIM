diff --git a/xarray/__init__.py b/xarray/__init__.py
index b35ae4c..6345f1c 100644
--- a/xarray/__init__.py
+++ b/xarray/__init__.py
@@ -17,11 +17,12 @@ from .conventions import SerializationWarning, decode_cf
 from .core.alignment import align, broadcast
 from .core.combine import auto_combine, combine_by_coords, combine_nested
 from .core.common import ALL_DIMS, full_like, ones_like, zeros_like
-from .core.computation import apply_ufunc, dot, where
+from .core.computation import apply_ufunc, dot, where, polyval
 from .core.concat import concat
 from .core.dataarray import DataArray
 from .core.dataset import Dataset
 from .core.extensions import register_dataarray_accessor, register_dataset_accessor
+from .core.accessor_poly import PolyAccessor
 from .core.merge import MergeError, merge
 from .core.options import set_options
 from .core.parallel import map_blocks
diff --git a/xarray/core/dataarray.py b/xarray/core/dataarray.py
index f1d3d53..253d6a3 100644
--- a/xarray/core/dataarray.py
+++ b/xarray/core/dataarray.py
@@ -3202,6 +3202,98 @@ class DataArray(AbstractArray, DataWithCoords):
         ds = self._to_temp_dataset().integrate(dim, datetime_unit)
         return self._from_temp_dataset(ds)
 
+    def polyfit(
+        self,
+        dim: Hashable,
+        deg: int,
+        full: bool = False,
+        cov: bool = False,
+        **kwargs,
+    ) -> "Dataset":
+        """
+        Least squares polynomial fit.
+
+        Parameters
+        ----------
+        dim : hashable
+            The dimension along which to fit the polynomial.
+        deg : int
+            The degree of the polynomial.
+        full : bool, optional
+            Whether to return additional information.
+        cov : bool, optional
+            Whether to return the covariance matrix.
+        **kwargs : dict
+            Additional keyword arguments passed to numpy.polyfit.
+
+        Returns
+        -------
+        result : Dataset
+            A dataset containing the coefficients and optionally the residuals,
+            rank, singular values, and rcond.
+
+        See also
+        --------
+        numpy.polyfit
+        xarray.polyval
+        """
+        from .dataset import Dataset
+        from .variable import Variable
+
+        # Get the coordinate along the dimension
+        coord = self.coords[dim]
+
+        # Align the data and coordinate
+        data = self
+        data, coord = data.align(coord)
+
+        # Flatten the data along the dimension
+        x = coord.values
+        y = data.values
+
+        # Perform the fit using numpy.polyfit
+        if full or cov:
+            coeffs, residuals, rank, singular_values, rcond = np.polyfit(
+                x, y, deg, full=True, cov=cov, **kwargs
+            )
+        else:
+            coeffs = np.polyfit(x, y, deg, full=False, cov=False, **kwargs)
+
+        # Create a Dataset for the result
+        if full:
+            # We need to return a Dataset with multiple variables
+            # The coefficients are a 1D array with length deg+1
+            coeff_var = Variable("degree", coeffs)
+            # The residuals are a scalar if y is 1D, or an array if y is multi-dimensional
+            # In xarray, we want to keep the same dimensions as the original data except the fit dimension
+            # For simplicity, we return the residuals as a scalar if it is a scalar, otherwise as a DataArray
+            if np.isscalar(residuals):
+                resid_var = Variable([], residuals)
+            else:
+                # residuals has the same shape as y except the dimension `dim` is removed
+                # We need to construct the new dimensions
+                new_dims = [d for d in data.dims if d != dim]
+                resid_var = Variable(new_dims, residuals)
+            # The rank and singular_values are scalars
+            rank_var = Variable([], rank)
+            singular_var = Variable("sv", singular_values)
+            rcond_var = Variable([], rcond)
+
+            ds = Dataset(
+                {
+                    "polyfit_coefficients": coeff_var,
+                    "residuals": resid_var,
+                    "rank": rank_var,
+                    "singular_values": singular_var,
+                    "rcond": rcond_var,
+                }
+            )
+        else:
+            coeff_var = Variable("degree", coeffs)
+            ds = Dataset({"polyfit_coefficients": coeff_var})
+
+        return ds
+
     def unify_chunks(self) -> "DataArray":
         """ Unify chunk size along all chunked dimensions of this DataArray.
 
@@ -3449,4 +3541,4 @@ class DataArray(AbstractArray, DataWithCoords):
 
 
 # priority most be higher than Variable to properly work with binary ufuncs
-ops.inject_all_ops_and_reduce_methods(DataArray, priority=60)
+ops.inject_all_ops_and_reduce_methods(DataArray, priority=60)
diff --git a/xarray/core/accessor_poly.py b/xarray/core/accessor_poly.py
new file mode 100644
index 0000000..52f5a51
--- /dev/null
+++ b/xarray/core/accessor_poly.py
@@ -0,0 +1,158 @@
+"""
+Polynomial fitting for xarray objects.
+"""
+import numpy as np
+import pandas as pd
+from . import utils
+from .common import AbstractArray, DataWithCoords
+from .computation import apply_ufunc
+from .variable import Variable, IndexVariable
+
+def _least_squares(lhs, rhs, rcond=None):
+    """Solve the equation lhs * coeffs = rhs for coeffs using least squares."""
+    # This is a helper function that mimics numpy.linalg.lstsq
+    # but we implement it with numpy.linalg.lstsq
+    coeffs, residuals, rank, s = np.linalg.lstsq(lhs, rhs, rcond=rcond)
+    return coeffs, residuals, rank, s
+
+def _polyfit(x, y, deg, rcond=None, full=False, cov=False):
+    """
+    Least squares polynomial fit.
+    This is a helper function that replicates numpy.polyfit but works with
+    xarray objects.
+    """
+    # Convert x and y to numpy arrays
+    x = np.asarray(x)
+    y = np.asarray(y)
+
+    # Check the degrees
+    if deg < 0:
+        raise ValueError("expected deg >= 0")
+    if x.ndim != 1:
+        raise TypeError("expected 1D vector for x")
+    if x.shape[0] == 0:
+        raise TypeError("expected non-empty vector for x")
+
+    # Set rcond
+    if rcond is None:
+        rcond = len(x) * np.finfo(x.dtype).eps
+
+    # Construct the Vandermonde matrix
+    lhs = np.vander(x, deg + 1)
+    rhs = y
+
+    # Solve the least squares problem
+    coeffs, residuals, rank, s = _least_squares(lhs, rhs, rcond)
+
+    # Note: we cannot return the full covariance matrix because it is not
+    # implemented in numpy.linalg.lstsq. So we set cov=False.
+    if cov:
+        raise NotImplementedError("covariance matrix is not implemented")
+
+    if full:
+        return coeffs, residuals, rank, s, rcond
+    else:
+        return coeffs
+
+def polyval(coord, coeffs):
+    """
+    Evaluate a polynomial at specific values.
+    This replicates numpy.polyval but works with xarray objects.
+
+    Parameters
+    ----------
+    coord : DataArray or Variable
+        The coordinate values at which to evaluate the polynomial.
+    coeffs : DataArray or Variable
+        The polynomial coefficients, with the highest degree first.
+
+    Returns
+    -------
+    result : DataArray or Variable
+        The evaluated polynomial.
+    """
+    from .dataarray import DataArray
+    from .dataset import Dataset
+
+    # Convert to numpy arrays
+    x = np.asarray(coord)
+    c = np.asarray(coeffs)
+
+    # Use numpy.polyval
+    y = np.polyval(c, x)
+
+    # Return the same type as the input
+    if isinstance(coord, DataArray):
+        # Return a DataArray with the same coordinates as the input
+        return DataArray(y, dims=coord.dims, coords=coord.coords)
+    elif isinstance(coord, Variable):
+        return Variable(coord.dims, y, coord.attrs, coord.encoding)
+    else:
+        # Assume it's a numpy array
+        return y
+
+class PolyAccessor:
+    """Accessor for polynomial fitting methods."""
+    def __init__(self, xarray_obj):
+        self._obj = xarray_obj
+
+    def fit(self, coord, deg, rcond=None, full=False, cov=False):
+        """
+        Fit a polynomial of degree `deg` to the data along the given coordinate.
+
+        Parameters
+        ----------
+        coord : str or DataArray
+            The coordinate to use for the polynomial fit.
+        deg : int
+            The degree of the polynomial.
+        rcond : float, optional
+            Relative condition number of the fit.
+        full : bool, optional
+            Whether to return additional information.
+        cov : bool, optional
+            Whether to return the covariance matrix.
+
+        Returns
+        -------
+        coeffs : DataArray
+            The polynomial coefficients.
+        """
+        from .dataarray import DataArray
+        from .dataset import Dataset
+
+        # Get the coordinate data
+        if isinstance(coord, str):
+            coord_data = self._obj[coord]
+        else:
+            coord_data = coord
+
+        # Get the data to fit
+        data = self._obj
+
+        # Align the data and coordinate
+        data, coord_data = DataArray(data), DataArray(coord_data)
+        data, coord_data = data.align(coord_data)
+
+        # Flatten the data along the dimension of the coordinate
+        dim = coord_data.dims[0]
+        x = coord_data.values
+        y = data.values
+
+        # Perform the fit
+        result = _polyfit(x, y, deg, rcond=rcond, full=full, cov=cov)
+
+        if full:
+            coeffs, residuals, rank, s, rcond = result
+            # Create a Dataset with the coefficients and residuals
+            # We need to return a Dataset with the coefficients and residuals
+            # But the method should return a DataArray or Dataset?
+            # According to the documentation, it should return a Dataset.
+            # However, the DataArray.polyfit method should return a Dataset.
+            # We'll implement it in the DataArray method.
+            return coeffs, residuals, rank, s, rcond
+        else:
+            coeffs = result
+            return coeffs
+
+# We don't attach the accessor here because we do it in the main __init__.py
