diff --git a/_pytest/logging.py b/_pytest/logging.py
new file mode 100644
index 0000000..404ce9d
--- /dev/null
+++ b/_pytest/logging.py
@@ -0,0 +1,258 @@
+"""
+Logging plugin for pytest.
+"""
+import logging
+import sys
+import warnings
+from contextlib import contextmanager
+from logging import LogRecord
+
+import pytest
+from _pytest.capture import CaptureManager
+from _pytest.config import Config
+from _pytest.config.argparsing import Parser
+from _pytest.fixtures import fixture
+from _pytest.main import Session
+from _pytest.nodes import Item
+from _pytest.reports import TestReport
+
+
+class LogCaptureHandler(logging.StreamHandler):
+    """A logging handler that stores log records and the log text."""
+
+    def __init__(self):
+        """Initialize the handler."""
+        logging.StreamHandler.__init__(self)
+        self.records = []
+        self.stream = None  # we don't need a stream
+
+    def emit(self, record):
+        """Keep the record and store it in the list."""
+        self.records.append(record)
+
+    def reset(self):
+        """Reset the list of records."""
+        self.records = []
+
+    def clear(self):
+        """Clear the list of records."""
+        self.records.clear()
+
+
+class LogCaptureFixture:
+    """Fixture to capture log messages."""
+
+    def __init__(self, item):
+        """Initialize the fixture."""
+        self._item = item
+        self._initial_log_levels = {}  # type: dict[str, int]
+        self.handler = None
+
+    def _setup(self, handler):
+        """Set up the fixture with the given handler."""
+        self.handler = handler
+        # Set the handler's level to the lowest level to capture everything.
+        self.handler.setLevel(logging.NOTSET)
+        # Attach the handler to the root logger.
+        logging.root.addHandler(self.handler)
+
+    def _finalize(self):
+        """Finalize the fixture."""
+        if self.handler is not None:
+            logging.root.removeHandler(self.handler)
+            self.handler.reset()
+            self.handler = None
+        # Restore the original log levels.
+        for logger_name, level in self._initial_log_levels.items():
+            logger = logging.getLogger(logger_name)
+            logger.setLevel(level)
+
+    @property
+    def records(self):
+        """Return the list of log records captured."""
+        return self.handler.records if self.handler else []
+
+    @property
+    def record_tuples(self):
+        """Return a list of tuples (logger_name, level, message)."""
+        return [(r.name, r.levelno, r.getMessage()) for r in self.records]
+
+    @property
+    def text(self):
+        """Return the formatted log text."""
+        return "\n".join(self.handler.format(r) for r in self.records)
+
+    def set_level(self, level, logger=None):
+        """Set the log level for the given logger (or the handler if None)."""
+        if logger is None:
+            self.handler.setLevel(level)
+        else:
+            logger_obj = logging.getLogger(logger)
+            self._initial_log_levels.setdefault(logger, logger_obj.level)
+            logger_obj.setLevel(level)
+
+    @contextmanager
+    def at_level(self, level, logger=None):
+        """Context manager to set the log level temporarily."""
+        if logger is None:
+            old_level = self.handler.level
+            self.handler.setLevel(level)
+            try:
+                yield
+            finally:
+                self.handler.setLevel(old_level)
+        else:
+            logger_obj = logging.getLogger(logger)
+            old_level = logger_obj.level
+            self._initial_log_levels.setdefault(logger, old_level)
+            logger_obj.setLevel(level)
+            try:
+                yield
+            finally:
+                logger_obj.setLevel(old_level)
+
+    def clear(self):
+        """Clear the captured records."""
+        if self.handler:
+            self.handler.clear()
+
+
+class LoggingPlugin:
+    """A plugin to capture log messages and provide a fixture."""
+
+    def __init__(self, config):
+        """Initialize the plugin."""
+        self.config = config
+        self.log_capture_handler = None
+        self.log_file_handler = None
+        self.log_cli_handler = None
+
+    def pytest_sessionstart(self, session):
+        """Set up the log capture handler at the start of the session."""
+        self.log_capture_handler = LogCaptureHandler()
+        # Set the formatter for the handler.
+        formatter = logging.Formatter(
+            fmt=self.config.getoption("log_format"),
+            datefmt=self.config.getoption("log_date_format"),
+        )
+        self.log_capture_handler.setFormatter(formatter)
+
+    def pytest_runtest_setup(self, item):
+        """Attach the log capture handler to the root logger for the test."""
+        if self.log_capture_handler is not None:
+            # Create a fixture for the test.
+            fixture = LogCaptureFixture(item)
+            fixture._setup(self.log_capture_handler)
+            item._log_capture_fixture = fixture
+
+    def pytest_runtest_teardown(self, item):
+        """Remove the log capture handler after the test."""
+        if hasattr(item, '_log_capture_fixture'):
+            item._log_capture_fixture._finalize()
+            del item._log_capture_fixture
+
+    def pytest_runtest_makereport(self, item, call):
+        """Add captured log messages to the test report."""
+        if not hasattr(item, '_log_capture_fixture'):
+            return
+        fixture = item._log_capture_fixture
+        if call.when == "call":
+            # Only for the call phase.
+            if call.excinfo is not None or self.config.getoption("log_print"):
+                # If the test failed or log_print is True, add the logs.
+                if fixture.handler and fixture.handler.records:
+                    # Add the logs to the report.
+                    report = item._report
+                    if hasattr(report, 'sections'):
+                        report.sections.append(("Captured stdlog call", fixture.text))
+
+    @fixture
+    def caplog(self, request):
+        """Fixture to capture log messages."""
+        if not hasattr(request.node, '_log_capture_fixture'):
+            # This should not happen.
+            raise RuntimeError("LogCaptureFixture not set up for this test.")
+        return request.node._log_capture_fixture
+
+
+def pytest_addoption(parser: Parser) -> None:
+    """Add command line options for logging."""
+    group = parser.getgroup("logging")
+    group.addoption(
+        "--log-format",
+        action="store",
+        default="%(levelname)s %(name)s %(message)s",
+        help="Log format used by the logging module.",
+    )
+    group.addoption(
+        "--log-date-format",
+        action="store",
+        default="%H:%M:%S",
+        help="Log date format used by the logging module.",
+    )
+    group.addoption(
+        "--log-cli-level",
+        action="store",
+        default=None,
+        help="Set the logging level for the console.",
+    )
+    group.addoption(
+        "--log-cli-format",
+        action="store",
+        default=None,
+        help="Log format for the console.",
+    )
+    group.addoption(
+        "--log-cli-date-format",
+        action="store",
+        default=None,
+        help="Log date format for the console.",
+    )
+    group.addoption(
+        "--log-file",
+        action="store",
+        default=None,
+        help="Path to a file to log to.",
+    )
+    group.addoption(
+        "--log-file-level",
+        action="store",
+        default=None,
+        help="Log level for the file.",
+    )
+    group.addoption(
+        "--log-file-format",
+        action="store",
+        default=None,
+        help="Log format for the file.",
+    )
+    group.addoption(
+        "--log-file-date-format",
+        action="store",
+        default=None,
+        help="Log date format for the file.",
+    )
+    group.addoption(
+        "--no-print-logs",
+        action="store_false",
+        dest="log_print",
+        default=True,
+        help="Disable printing logs on failed tests.",
+    )
+    parser.addini("log_format", "Log format", default="%(levelname)s %(name)s %(message)s")
+    parser.addini("log_date_format", "Log date format", default="%H:%M:%S")
+    parser.addini("log_cli_level", "Console logging level", default=None)
+    parser.addini("log_cli_format", "Console log format", default=None)
+    parser.addini("log_cli_date_format", "Console log date format", default=None)
+    parser.addini("log_file", "Log file path", default=None)
+    parser.addini("log_file_level", "Log file level", default=None)
+    parser.addini("log_file_format", "Log file format", default=None)
+    parser.addini("log_file_date_format", "Log file date format", default=None)
+    parser.addini("log_print", "Print logs on failed tests", type="bool", default=True)
+
+
+def pytest_configure(config: Config) -> None:
+    """Configure the logging plugin."""
+    # Register the plugin.
+    plugin = LoggingPlugin(config)
+    config.pluginmanager.register(plugin, "logging-plugin")
