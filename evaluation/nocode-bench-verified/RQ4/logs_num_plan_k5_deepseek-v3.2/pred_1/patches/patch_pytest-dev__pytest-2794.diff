diff --git a/_pytest/capture.py b/_pytest/capture.py
index 2a7dde5..a689c08 100644
--- a/_pytest/capture.py
+++ b/_pytest/capture.py
@@ -137,6 +137,7 @@ class CaptureManager:
                 rep.sections.append(("Captured stdout", out))
             if err:
                 rep.sections.append(("Captured stderr", err))
+            # Also capture logs during collection? Not required by the feature.
         else:
             yield
 
@@ -177,6 +178,13 @@ class CaptureManager:
         out, err = self.suspend_global_capture(item, in_=in_)
         item.add_report_section(when, "stdout", out)
         item.add_report_section(when, "stderr", err)
+        # Also add captured logs if available.
+        if hasattr(item, '_capturelog_fixture'):
+            log_fixture = item._capturelog_fixture
+            if log_fixture is not None:
+                log_text = log_fixture.text
+                if log_text:
+                    item.add_report_section(when, "log", log_text)
 
 
 error_capsysfderror = "cannot use capsys and capfd at the same time"
diff --git a/_pytest/logging.py b/_pytest/logging.py
new file mode 100644
index 0000000..acdd005
--- /dev/null
+++ b/_pytest/logging.py
@@ -0,0 +1,223 @@
+"""
+Logging integration for pytest.
+"""
+import logging
+import sys
+from contextlib import contextmanager
+from io import StringIO
+
+import pytest
+from _pytest.capture import CaptureManager
+
+
+class LogCaptureHandler(logging.StreamHandler):
+    """A logging handler that stores log records and their formatted output."""
+
+    def __init__(self):
+        super().__init__(StringIO())
+        self.records = []
+
+    def emit(self, record):
+        self.records.append(record)
+        super().emit(record)
+
+    def reset(self):
+        self.records.clear()
+        self.stream = StringIO()
+
+
+class LogCaptureFixture:
+    """Fixture to capture log messages."""
+
+    def __init__(self, item):
+        self._item = item
+        self._handler = None
+        self._initial_logger_levels = {}  # original levels for loggers we adjust
+
+    def _setup(self):
+        # Install a logging handler for the root logger.
+        root_logger = logging.getLogger()
+        self._handler = LogCaptureHandler()
+        root_logger.addHandler(self._handler)
+        # Set the handler's level to the lowest so it captures all logs.
+        self._handler.setLevel(logging.NOTSET)
+        # Save the original level of the root logger to restore later.
+        self._initial_logger_levels[root_logger] = root_logger.level
+        # Set the root logger level to the lowest to capture all logs.
+        root_logger.setLevel(logging.NOTSET)
+
+    def _teardown(self):
+        if self._handler is not None:
+            root_logger = logging.getLogger()
+            root_logger.removeHandler(self._handler)
+            # Restore the original level of the root logger.
+            root_logger.setLevel(self._initial_logger_levels.pop(root_logger))
+            self._handler = None
+
+    @property
+    def records(self):
+        """A list of log records captured."""
+        return self._handler.records if self._handler else []
+
+    @property
+    def text(self):
+        """The formatted log text."""
+        if self._handler:
+            return self._handler.stream.getvalue()
+        return ""
+
+    @property
+    def record_tuples(self):
+        """A list of tuples (logger_name, level, message) for captured records."""
+        return [(r.name, r.levelno, r.getMessage()) for r in self.records]
+
+    def clear(self):
+        """Clear the captured records and text."""
+        if self._handler:
+            self._handler.reset()
+
+    def set_level(self, level, logger=None):
+        """Set the level for the handler or a specific logger."""
+        if logger is None:
+            self._handler.setLevel(level)
+        else:
+            logger_obj = logging.getLogger(logger)
+            self._initial_logger_levels[logger_obj] = logger_obj.level
+            logger_obj.setLevel(level)
+
+    @contextmanager
+    def at_level(self, level, logger=None):
+        """Context manager to temporarily set the level for the handler or a logger."""
+        if logger is None:
+            old_level = self._handler.level
+            self.set_level(level)
+            try:
+                yield
+            finally:
+                self.set_level(old_level)
+        else:
+            logger_obj = logging.getLogger(logger)
+            old_level = logger_obj.level
+            self.set_level(level, logger)
+            try:
+                yield
+            finally:
+                logger_obj.setLevel(old_level)
+
+
+@pytest.fixture
+def caplog(request):
+    """Fixture to capture log messages."""
+    fixture = LogCaptureFixture(request.node)
+    fixture._setup()
+    request.addfinalizer(fixture._teardown)
+    return fixture
+
+
+class LoggingPlugin:
+    """Plugin to capture logging and provide command line options."""
+
+    def __init__(self, config):
+        self.config = config
+        self.log_level = getattr(config.option, 'log_cli_level', None)
+        self.log_format = config.getini('log_format')
+        self.log_date_format = config.getini('log_date_format')
+        self.log_print = config.getini('log_print')
+        self.caplog_handler = None
+
+    @pytest.hookimpl
+    def pytest_configure(self, config):
+        config.pluginmanager.register(self, "logging")
+
+    @pytest.hookimpl
+    def pytest_runtest_setup(self, item):
+        # Install the log capture handler for the test.
+        caplog_fixture = item._request.getfixturevalue('caplog')
+        # We don't need to do anything else here because the fixture is already set up.
+
+    @pytest.hookimpl
+    def pytest_runtest_teardown(self, item):
+        # We don't need to do anything here because the fixture will be torn down.
+        pass
+
+    @pytest.hookimpl
+    def pytest_report_teststatus(self, report):
+        # If the test failed and we are supposed to print logs, add the captured logs.
+        if report.failed and self.log_print:
+            if hasattr(report, 'caplog'):
+                out = report.caplog
+                if out:
+                    report.sections.append(("Captured log", out))
+
+    @pytest.hookimpl
+    def pytest_addoption(self, parser):
+        group = parser.getgroup("logging")
+        group.addoption(
+            "--log-format",
+            default="%(levelname)-8s %(name)s %(message)s",
+            help="Log format used by the logging module."
+        )
+        group.addoption(
+            "--log-date-format",
+            default="%Y-%m-%d %H:%M:%S",
+            help="Log date format used by the logging module."
+        )
+        group.addoption(
+            "--log-cli-level",
+            default=None,
+            help="Set the logging level for the console."
+        )
+        group.addoption(
+            "--log-cli-format",
+            default=None,
+            help="Log format for the console."
+        )
+        group.addoption(
+            "--log-cli-date-format",
+            default=None,
+            help="Log date format for the console."
+        )
+        group.addoption(
+            "--log-file",
+            default=None,
+            help="Path to a file to log to."
+        )
+        group.addoption(
+            "--log-file-level",
+            default=None,
+            help="Log level for the file."
+        )
+        group.addoption(
+            "--log-file-format",
+            default=None,
+            help="Log format for the file."
+        )
+        group.addoption(
+            "--log-file-date-format",
+            default=None,
+            help="Log date format for the file."
+        )
+        group.addoption(
+            "--no-print-logs",
+            dest="log_print",
+            action="store_false",
+            default=True,
+            help="Disable printing captured logs on failed tests."
+        )
+        parser.addini("log_format", "Log format", default="%(levelname)-8s %(name)s %(message)s")
+        parser.addini("log_date_format", "Log date format", default="%Y-%m-%d %H:%M:%S")
+        parser.addini("log_cli_level", "Console logging level", default=None)
+        parser.addini("log_cli_format", "Console logging format", default=None)
+        parser.addini("log_cli_date_format", "Console logging date format", default=None)
+        parser.addini("log_file", "Log file path", default=None)
+        parser.addini("log_file_level", "Log file level", default=None)
+        parser.addini("log_file_format", "Log file format", default=None)
+        parser.addini("log_file_date_format", "Log file date format", default=None)
+        parser.addini("log_print", "Print captured logs on failed tests", default=True)
+
+    @pytest.hookimpl
+    def pytest_capturelog(self, record):
+        """This hook is called for each log record captured.
+        We can use it to forward logs to the console or file if needed.
+        """
+        pass
