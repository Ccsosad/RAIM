diff --git a/astropy/visualization/wcsaxes/wcsapi.py b/astropy/visualization/wcsaxes/wcsapi.py
index 18817a1..bdfe9d4 100644
--- a/astropy/visualization/wcsaxes/wcsapi.py
+++ b/astropy/visualization/wcsaxes/wcsapi.py
@@ -33,10 +33,10 @@ def transform_coord_meta_from_wcs(wcs, frame_class, slices=None):
             raise ValueError("'slices' should have as many elements as WCS "
                              "has pixel dimensions (should be {})"
                              .format(wcs.pixel_n_dim))
-    elif wcs.pixel_n_dim < 2:
-        raise ValueError("WCS should have at least 2 pixel dimensions")
-    elif slices is not None and slices != ('x', 'y') and slices != ('y', 'x'):
-        raise ValueError("WCS only has 2 pixel dimensions and cannot be sliced")
+    elif wcs.pixel_n_dim == 2:
+        if slices is not None and slices != ('x', 'y') and slices != ('y', 'x'):
+            raise ValueError("WCS only has 2 pixel dimensions and cannot be sliced")
+    # For 1D WCS, we don't need to check slices because it will be handled later.
 
     is_fits_wcs = isinstance(wcs, WCS)
 
@@ -124,10 +124,20 @@ def transform_coord_meta_from_wcs(wcs, frame_class, slices=None):
     invert_xy = False
     if slices is not None:
         wcs_slice = list(slices)
-        wcs_slice[wcs_slice.index("x")] = slice(None)
-        wcs_slice[wcs_slice.index("y")] = slice(None)
-        wcs = SlicedLowLevelWCS(wcs, wcs_slice[::-1])
-        invert_xy = slices.index('x') > slices.index('y')
+        # Check if we are doing a 1D plot (only one axis is 'x')
+        if 'x' in wcs_slice and 'y' not in wcs_slice:
+            # 1D plot
+            wcs_slice[wcs_slice.index("x")] = slice(None)
+            wcs = SlicedLowLevelWCS(wcs, wcs_slice[::-1])
+            invert_xy = False
+        elif 'x' in wcs_slice and 'y' in wcs_slice:
+            # 2D plot
+            wcs_slice[wcs_slice.index("x")] = slice(None)
+            wcs_slice[wcs_slice.index("y")] = slice(None)
+            wcs = SlicedLowLevelWCS(wcs, wcs_slice[::-1])
+            invert_xy = slices.index('x') > slices.index('y')
+        else:
+            raise ValueError("slices should contain at least 'x' for 1D plot or both 'x' and 'y' for 2D plot")
         world_keep = wcs._world_keep
     else:
         world_keep = list(range(wcs.world_n_dim))
@@ -137,27 +147,45 @@ def transform_coord_meta_from_wcs(wcs, frame_class, slices=None):
 
     transform = WCSPixel2WorldTransform(wcs, invert_xy=invert_xy)
 
-    m = wcs.axis_correlation_matrix.copy()
-    if invert_xy:
-        m = m[:, ::-1]
+    # For 1D plots, we don't have an axis_correlation_matrix with 2 columns.
+    # We need to handle 1D and 2D separately.
+    if hasattr(wcs, 'axis_correlation_matrix'):
+        m = wcs.axis_correlation_matrix.copy()
+        if invert_xy:
+            m = m[:, ::-1]
+    else:
+        # For 1D, we create a dummy matrix.
+        m = np.ones((wcs.world_n_dim, 1), dtype=bool)
 
     if frame_class is RectangularFrame:
 
-        for i, spine_name in enumerate('bltr'):
-            pos = np.nonzero(m[:, i % 2])[0]
-            if len(pos) > 0:
-                index = world_keep[pos[0]]
-                coord_meta['default_axislabel_position'][index] = spine_name
-                coord_meta['default_ticklabel_position'][index] = spine_name
-                coord_meta['default_ticks_position'][index] = spine_name
-                m[pos[0], :] = 0
-
-        # In the special and common case where the frame is rectangular and
-        # we are dealing with 2-d WCS (after slicing), we show all ticks on
-        # all axes for backward-compatibility.
-        if len(world_keep) == 2:
-            for index in world_keep:
-                coord_meta['default_ticks_position'][index] = 'bltr'
+        # For 1D plots, we want to put the axis label on the bottom spine.
+        if m.shape[1] == 1:
+            # 1D plot
+            for i in range(m.shape[0]):
+                if m[i, 0]:
+                    index = world_keep[i]
+                    coord_meta['default_axislabel_position'][index] = 'b'
+                    coord_meta['default_ticklabel_position'][index] = 'b'
+                    coord_meta['default_ticks_position'][index] = 'b'
+                    break
+        else:
+            # 2D plot
+            for i, spine_name in enumerate('bltr'):
+                pos = np.nonzero(m[:, i % 2])[0]
+                if len(pos) > 0:
+                    index = world_keep[pos[0]]
+                    coord_meta['default_axislabel_position'][index] = spine_name
+                    coord_meta['default_ticklabel_position'][index] = spine_name
+                    coord_meta['default_ticks_position'][index] = spine_name
+                    m[pos[0], :] = 0
+
+            # In the special and common case where the frame is rectangular and
+            # we are dealing with 2-d WCS (after slicing), we show all ticks on
+            # all axes for backward-compatibility.
+            if len(world_keep) == 2:
+                for index in world_keep:
+                    coord_meta['default_ticks_position'][index] = 'bltr'
 
     elif frame_class is EllipticalFrame:
 
