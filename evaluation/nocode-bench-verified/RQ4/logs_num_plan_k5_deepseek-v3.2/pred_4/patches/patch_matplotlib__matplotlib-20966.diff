diff --git a/lib/matplotlib/cm.py b/lib/matplotlib/cm.py
index a7f28ce..8e11449 100644
--- a/lib/matplotlib/cm.py
+++ b/lib/matplotlib/cm.py
@@ -331,13 +331,14 @@ class ScalarMappable:
         norm : `matplotlib.colors.Normalize` (or subclass thereof)
             The normalizing object which scales data, typically into the
             interval ``[0, 1]``.
-            If *None*, *norm* defaults to a *colors.Normalize* object which
+            If *None*, *norm* defaults to a *colors.Normalize` object which
             initializes its scaling based on the first data processed.
         cmap : str or `~matplotlib.colors.Colormap`
             The colormap used to map normalized data values to RGBA colors.
         """
         self._A = None
         self.norm = None  # So that the setter knows we're initializing.
+        self._norm_cid = None  # callback id for norm's callbacks
         self.set_norm(norm)  # The Normalize instance of this ScalarMappable.
         self.cmap = None  # So that the setter knows we're initializing.
         self.set_cmap(cmap)  # The Colormap instance of this ScalarMappable.
@@ -547,9 +548,23 @@ class ScalarMappable:
         """
         _api.check_isinstance((colors.Normalize, None), norm=norm)
         in_init = self.norm is None
+        # Disconnect from the previous norm's callbacks
+        if self._norm_cid is not None:
+            self.norm.callbacks.disconnect(self._norm_cid)
+            self._norm_cid = None
         if norm is None:
             norm = colors.Normalize()
         self.norm = norm
+        # Connect to the new norm's callbacks
+        import weakref
+        weak_self = weakref.ref(self)
+        def on_norm_changed(norm):
+            self_ref = weak_self()
+            if self_ref is not None:
+                self_ref.changed()
+        self._norm_cid = self.norm.callbacks.connect('changed', on_norm_changed)
+        # Keep a reference to the callback to avoid garbage collection
+        self._norm_changed_callback = on_norm_changed
         if not in_init:
             self.changed()  # Things are not set up properly yet.
 
@@ -573,10 +588,14 @@ class ScalarMappable:
         self.norm.autoscale_None(self._A)
         self.changed()
 
+    def _on_norm_changed(self, norm):
+        # This method is called when the norm's attributes change.
+        self.changed()
+
     def changed(self):
         """
         Call this whenever the mappable is changed to notify all the
         callbackSM listeners to the 'changed' signal.
         """
         self.callbacks.process('changed', self)
-        self.stale = True
+        self.stale = True
diff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py
index 2e9d5d5..cc17260 100644
--- a/lib/matplotlib/colors.py
+++ b/lib/matplotlib/colors.py
@@ -1123,10 +1123,11 @@ class Normalize:
         -----
         Returns 0 if ``vmin == vmax``.
         """
-        self.vmin = _sanitize_extrema(vmin)
-        self.vmax = _sanitize_extrema(vmax)
+        self._vmin = _sanitize_extrema(vmin)
+        self._vmax = _sanitize_extrema(vmax)
         self.clip = clip
         self._scale = None  # will default to LinearScale for colorbar
+        self.callbacks = cbook.CallbackRegistry()
 
     @staticmethod
     def process_value(value):
@@ -1220,6 +1221,28 @@ class Normalize:
         else:
             return vmin + value * (vmax - vmin)
 
+    @property
+    def vmin(self):
+        return self._vmin
+
+    @vmin.setter
+    def vmin(self, value):
+        value = _sanitize_extrema(value)
+        if value != self._vmin:
+            self._vmin = value
+            self.callbacks.process('changed', self)
+
+    @property
+    def vmax(self):
+        return self._vmax
+
+    @vmax.setter
+    def vmax(self, value):
+        value = _sanitize_extrema(value)
+        if value != self._vmax:
+            self._vmax = value
+            self.callbacks.process('changed', self)
+
     def autoscale(self, A):
         """Set *vmin*, *vmax* to min, max of *A*."""
         A = np.asanyarray(A)
