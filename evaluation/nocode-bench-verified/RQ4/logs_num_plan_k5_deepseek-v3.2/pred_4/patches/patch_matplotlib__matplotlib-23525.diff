diff --git a/lib/matplotlib/axes/_axes.py b/lib/matplotlib/axes/_axes.py
index 677b319..6359e00 100644
--- a/lib/matplotlib/axes/_axes.py
+++ b/lib/matplotlib/axes/_axes.py
@@ -2335,6 +2335,15 @@ class Axes(_AxesBase):
         label = kwargs.pop('label', '')
         tick_labels = kwargs.pop('tick_label', None)
 
+        # Check if label is a list/array with the same length as the number of bars.
+        # If so, we will assign each label to each patch and set the container label to '_nolegend_'.
+        per_bar_labels = None
+        if (isinstance(label, (list, tuple, np.ndarray)) and 
+            len(label) == len(x) and 
+            not isinstance(label, str)):
+            per_bar_labels = label
+            label = '_nolegend_'
+
         y = bottom  # Matches barh call signature.
         if orientation == 'vertical':
             if y is None:
@@ -2419,25 +2428,45 @@ class Axes(_AxesBase):
             bottom = y
 
         patches = []
-        args = zip(left, bottom, width, height, color, edgecolor, linewidth,
-                   hatch)
-        for l, b, w, h, c, e, lw, htch in args:
-            r = mpatches.Rectangle(
-                xy=(l, b), width=w, height=h,
-                facecolor=c,
-                edgecolor=e,
-                linewidth=lw,
-                label='_nolegend_',
-                hatch=htch,
-                )
-            r._internal_update(kwargs)
-            r.get_path()._interpolation_steps = 100
-            if orientation == 'vertical':
-                r.sticky_edges.y.append(b)
-            else:  # horizontal
-                r.sticky_edges.x.append(l)
-            self.add_patch(r)
-            patches.append(r)
+        if per_bar_labels is not None:
+            # If we have per-bar labels, we need to iterate with an index.
+            for i, (l, b, w, h, c, e, lw, htch) in enumerate(zip(left, bottom, width, height, color, edgecolor, linewidth, hatch)):
+                r = mpatches.Rectangle(
+                    xy=(l, b), width=w, height=h,
+                    facecolor=c,
+                    edgecolor=e,
+                    linewidth=lw,
+                    label=per_bar_labels[i],
+                    hatch=htch,
+                    )
+                r._internal_update(kwargs)
+                r.get_path()._interpolation_steps = 100
+                if orientation == 'vertical':
+                    r.sticky_edges.y.append(b)
+                else:  # horizontal
+                    r.sticky_edges.x.append(l)
+                self.add_patch(r)
+                patches.append(r)
+        else:
+            args = zip(left, bottom, width, height, color, edgecolor, linewidth,
+                       hatch)
+            for l, b, w, h, c, e, lw, htch in args:
+                r = mpatches.Rectangle(
+                    xy=(l, b), width=w, height=h,
+                    facecolor=c,
+                    edgecolor=e,
+                    linewidth=lw,
+                    label='_nolegend_',
+                    hatch=htch,
+                    )
+                r._internal_update(kwargs)
+                r.get_path()._interpolation_steps = 100
+                if orientation == 'vertical':
+                    r.sticky_edges.y.append(b)
+                else:  # horizontal
+                    r.sticky_edges.x.append(l)
+                self.add_patch(r)
+                patches.append(r)
 
         if xerr is not None or yerr is not None:
             if orientation == 'vertical':
@@ -8162,4 +8191,4 @@ such objects
         figure_size = self.get_figure().get_size_inches()
         ll, ur = self.get_position() * figure_size
         width, height = ur - ll
-        return height / (width * self.get_data_ratio())
+        return height / (width * self.get_data_ratio())
