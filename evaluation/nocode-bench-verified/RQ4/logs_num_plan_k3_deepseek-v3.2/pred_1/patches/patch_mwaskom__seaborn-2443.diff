diff --git a/seaborn/categorical.py b/seaborn/categorical.py
index 27d5801..ea8f3bf 100644
--- a/seaborn/categorical.py
+++ b/seaborn/categorical.py
@@ -1556,18 +1556,16 @@ class _SwarmPlotter(_CategoricalScatterPlotter):
                 swarm_data = np.asarray(group_data[hue_mask])
                 point_colors = np.asarray(self.point_colors[i][hue_mask])
 
-                # Sort the points for the beeswarm algorithm
-                sorter = np.argsort(swarm_data)
-                swarm_data = swarm_data[sorter]
-                point_colors = point_colors[sorter]
-
+                # Do not sort the points, keep original order
                 # Plot the points in centered positions
                 cat_pos = np.ones(swarm_data.size) * i
                 kws.update(c=palette[point_colors])
                 if self.orient == "v":
-                    points = ax.scatter(cat_pos, swarm_data, s=s, **kws)
+                    orig_xy = np.c_[cat_pos, swarm_data]
                 else:
-                    points = ax.scatter(swarm_data, cat_pos, s=s, **kws)
+                    orig_xy = np.c_[swarm_data, cat_pos]
+                points = Beeswarm(orig_xy, i, width, s, self, **kws)
+                ax.add_collection(points)
 
                 centers.append(i)
                 swarms.append(points)
@@ -1581,19 +1579,17 @@ class _SwarmPlotter(_CategoricalScatterPlotter):
                     swarm_data = np.asarray(group_data[hue_mask])
                     point_colors = np.asarray(self.point_colors[i][hue_mask])
 
-                    # Sort the points for the beeswarm algorithm
-                    sorter = np.argsort(swarm_data)
-                    swarm_data = swarm_data[sorter]
-                    point_colors = point_colors[sorter]
-
+                    # Do not sort the points, keep original order
                     # Plot the points in centered positions
                     center = i + offsets[j]
                     cat_pos = np.ones(swarm_data.size) * center
                     kws.update(c=palette[point_colors])
                     if self.orient == "v":
-                        points = ax.scatter(cat_pos, swarm_data, s=s, **kws)
+                        orig_xy = np.c_[cat_pos, swarm_data]
                     else:
-                        points = ax.scatter(swarm_data, cat_pos, s=s, **kws)
+                        orig_xy = np.c_[swarm_data, cat_pos]
+                    points = Beeswarm(orig_xy, center, width, s, self, **kws)
+                    ax.add_collection(points)
 
                     centers.append(center)
                     swarms.append(points)
@@ -1601,11 +1597,8 @@ class _SwarmPlotter(_CategoricalScatterPlotter):
         # Autoscale the valus axis to set the data/axes transforms properly
         ax.autoscale_view(scalex=self.orient == "h", scaley=self.orient == "v")
 
-        # Update the position of each point on the categorical axis
-        # Do this after plotting so that the numerical axis limits are correct
-        for center, swarm in zip(centers, swarms):
-            if swarm.get_offsets().size:
-                self.swarm_points(ax, swarm, center, width, s, **kws)
+        # The swarming is now done by the Beeswarm artists at draw time
+        # So we don't need to update them here.
 
     def plot(self, ax, kws):
         """Make the full plot."""
@@ -1616,6 +1609,37 @@ class _SwarmPlotter(_CategoricalScatterPlotter):
             ax.invert_yaxis()
 
 
+class Beeswarm(mpl.collections.PathCollection):
+    """A PathCollection that recomputes swarm positions on draw."""
+    def __init__(self, orig_xy, center, width, s, plotter, **kwargs):
+        super().__init__([], **kwargs)
+        self.orig_xy = orig_xy  # in data coordinates
+        self.center = center
+        self.width = width
+        self.s = s
+        self.plotter = plotter
+        self.recomputed = False
+
+    def recompute(self):
+        """Update the positions of the points to avoid overlaps."""
+        ax = self.axes
+        if ax is None:
+            return
+        # Create a temporary collection with the original offsets
+        temp = mpl.collections.PathCollection([], offsets=self.orig_xy)
+        temp.set_transform(ax.transData)
+        # Use the plotter to compute new positions
+        self.plotter.swarm_points(ax, temp, self.center, self.width, self.s)
+        new_offsets = temp.get_offsets()
+        self.set_offsets(new_offsets)
+        self.recomputed = True
+
+    def draw(self, renderer):
+        if not self.recomputed:
+            self.recompute()
+        super().draw(renderer)
+
+
 class _CategoricalStatPlotter(_CategoricalPlotter):
 
     require_numeric = True
