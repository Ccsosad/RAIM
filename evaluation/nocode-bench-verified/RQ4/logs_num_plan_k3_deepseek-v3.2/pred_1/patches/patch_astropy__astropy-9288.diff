diff --git a/astropy/table/operations.py b/astropy/table/operations.py
index 0d1d769..7cc46dd 100644
--- a/astropy/table/operations.py
+++ b/astropy/table/operations.py
@@ -104,7 +104,7 @@ def join(left, right, keys=None, join_type='inner',
         Name(s) of column(s) used to match rows of left and right tables.
         Default is to use all columns which are common to both tables.
     join_type : str
-        Join type ('inner' | 'outer' | 'left' | 'right'), default is 'inner'
+        Join type ('inner' | 'outer' | 'left' | 'right' | 'cartesian'), default is 'inner'
     uniq_col_name : str or None
         String generate a unique output column name in case of a conflict.
         The default is '{col_name}_{table_name}'.
@@ -777,7 +777,7 @@ def _join(left, right, keys=None, join_type='inner',
         Name(s) of column(s) used to match rows of left and right tables.
         Default is to use all columns which are common to both tables.
     join_type : str
-        Join type ('inner' | 'outer' | 'left' | 'right'), default is 'inner'
+        Join type ('inner' | 'outer' | 'left' | 'right' | 'cartesian'), default is 'inner'
     uniq_col_name : str or None
         String generate a unique output column name in case of a conflict.
         The default is '{col_name}_{table_name}'.
@@ -801,18 +801,24 @@ def _join(left, right, keys=None, join_type='inner',
     # Store user-provided col_name_map until the end
     _col_name_map = col_name_map
 
-    if join_type not in ('inner', 'outer', 'left', 'right'):
+    if join_type not in ('inner', 'outer', 'left', 'right', 'cartesian'):
         raise ValueError("The 'join_type' argument should be in 'inner', "
-                         "'outer', 'left' or 'right' (got '{}' instead)".
+                         "'outer', 'left', 'right' or 'cartesian' (got '{}' instead)".
                          format(join_type))
 
-    # If we have a single key, put it in a tuple
-    if keys is None:
-        keys = tuple(name for name in left.colnames if name in right.colnames)
-        if len(keys) == 0:
-            raise TableMergeError('No keys in common between left and right tables')
-    elif isinstance(keys, str):
-        keys = (keys,)
+    # For cartesian join, keys must be None (or empty) and we don't look for common keys.
+    if join_type == 'cartesian':
+        if keys is not None:
+            raise TableMergeError('cannot supply keys for a cartesian join')
+        keys = ()
+    else:
+        # If we have a single key, put it in a tuple
+        if keys is None:
+            keys = tuple(name for name in left.colnames if name in right.colnames)
+            if len(keys) == 0:
+                raise TableMergeError('No keys in common between left and right tables')
+        elif isinstance(keys, str):
+            keys = (keys,)
 
     # Check the key columns
     for arr, arr_label in ((left, 'Left'), (right, 'Right')):
@@ -833,16 +839,27 @@ def _join(left, right, keys=None, join_type='inner',
     col_name_map = get_col_name_map([left, right], keys, uniq_col_name, table_names)
     out_descrs = get_descrs([left, right], col_name_map)
 
-    try:
-        idxs, idx_sort = _get_join_sort_idxs(keys, left, right)
-    except NotImplementedError:
-        raise TypeError('one or more key columns are not sortable')
-
-    # Main inner loop in Cython to compute the cartesian product
-    # indices for the given join type
-    int_join_type = {'inner': 0, 'outer': 1, 'left': 2, 'right': 3}[join_type]
-    masked, n_out, left_out, left_mask, right_out, right_mask = \
-        _np_utils.join_inner(idxs, idx_sort, len_left, int_join_type)
+    if join_type == 'cartesian':
+        # For cartesian join, we don't have keys, so we generate indices for all combinations.
+        # left_out is repeated for each right row, right_out is tiled for each left row.
+        left_out = np.repeat(np.arange(len_left), len_right)
+        right_out = np.tile(np.arange(len_right), len_left)
+        # No masking for cartesian join (all rows are present)
+        left_mask = np.zeros(len(left_out), dtype=bool)
+        right_mask = np.zeros(len(right_out), dtype=bool)
+        n_out = len(left_out)
+        masked = False
+    else:
+        try:
+            idxs, idx_sort = _get_join_sort_idxs(keys, left, right)
+        except NotImplementedError:
+            raise TypeError('one or more key columns are not sortable')
+
+        # Main inner loop in Cython to compute the cartesian product
+        # indices for the given join type
+        int_join_type = {'inner': 0, 'outer': 1, 'left': 2, 'right': 3}[join_type]
+        masked, n_out, left_out, left_mask, right_out, right_mask = \
+            _np_utils.join_inner(idxs, idx_sort, len_left, int_join_type)
 
     out = _get_out_class([left, right])()
 
