diff --git a/astropy/visualization/wcsaxes/wcsapi.py b/astropy/visualization/wcsaxes/wcsapi.py
index 18817a1..e0a146c 100644
--- a/astropy/visualization/wcsaxes/wcsapi.py
+++ b/astropy/visualization/wcsaxes/wcsapi.py
@@ -33,10 +33,8 @@ def transform_coord_meta_from_wcs(wcs, frame_class, slices=None):
             raise ValueError("'slices' should have as many elements as WCS "
                              "has pixel dimensions (should be {})"
                              .format(wcs.pixel_n_dim))
-    elif wcs.pixel_n_dim < 2:
-        raise ValueError("WCS should have at least 2 pixel dimensions")
-    elif slices is not None and slices != ('x', 'y') and slices != ('y', 'x'):
-        raise ValueError("WCS only has 2 pixel dimensions and cannot be sliced")
+    elif wcs.pixel_n_dim < 1:
+        raise ValueError("WCS should have at least 1 pixel dimension")
 
     is_fits_wcs = isinstance(wcs, WCS)
 
@@ -125,9 +123,10 @@ def transform_coord_meta_from_wcs(wcs, frame_class, slices=None):
     if slices is not None:
         wcs_slice = list(slices)
         wcs_slice[wcs_slice.index("x")] = slice(None)
-        wcs_slice[wcs_slice.index("y")] = slice(None)
+        if 'y' in slices:
+            wcs_slice[wcs_slice.index("y")] = slice(None)
+            invert_xy = slices.index('x') > slices.index('y')
         wcs = SlicedLowLevelWCS(wcs, wcs_slice[::-1])
-        invert_xy = slices.index('x') > slices.index('y')
         world_keep = wcs._world_keep
     else:
         world_keep = list(range(wcs.world_n_dim))
@@ -144,6 +143,8 @@ def transform_coord_meta_from_wcs(wcs, frame_class, slices=None):
     if frame_class is RectangularFrame:
 
         for i, spine_name in enumerate('bltr'):
+            if i % 2 >= m.shape[1]:
+                continue
             pos = np.nonzero(m[:, i % 2])[0]
             if len(pos) > 0:
                 index = world_keep[pos[0]]
@@ -205,8 +206,8 @@ class WCSWorld2PixelTransform(CurvedTransform):
 
         super().__init__()
 
-        if wcs.pixel_n_dim != 2:
-            raise ValueError('Only pixel_n_dim==2 is supported')
+        if wcs.pixel_n_dim not in (1, 2):
+            raise ValueError('Only pixel_n_dim=1 or 2 is supported')
 
         self.wcs = wcs
         self.invert_xy = invert_xy
@@ -230,7 +231,7 @@ class WCSWorld2PixelTransform(CurvedTransform):
             raise ValueError(f"Expected {self.wcs.world_n_dim} world coordinates, got {len(world)} ")
 
         if len(world[0]) == 0:
-            pixel = np.zeros((0, 2))
+            pixel = np.zeros((0, self.wcs.pixel_n_dim))
         else:
             pixel = self.wcs.world_to_pixel_values(*world)
 
@@ -261,8 +262,8 @@ class WCSPixel2WorldTransform(CurvedTransform):
 
         super().__init__()
 
-        if wcs.pixel_n_dim != 2:
-            raise ValueError('Only pixel_n_dim==2 is supported')
+        if wcs.pixel_n_dim not in (1, 2):
+            raise ValueError('Only pixel_n_dim=1 or 2 is supported')
 
         self.wcs = wcs
         self.invert_xy = invert_xy
@@ -283,7 +284,7 @@ class WCSPixel2WorldTransform(CurvedTransform):
         pixel = list(pixel.T)
 
         if len(pixel) != self.wcs.pixel_n_dim:
-            raise ValueError(f"Expected {self.wcs.pixel_n_dim} world coordinates, got {len(pixel)} ")
+            raise ValueError(f"Expected {self.wcs.pixel_n_dim} pixel coordinates, got {len(pixel)} ")
 
         if self.invert_xy:
             pixel = pixel[::-1]
@@ -313,4 +314,4 @@ class WCSPixel2WorldTransform(CurvedTransform):
         """
         Return the inverse of the transform
         """
-        return WCSWorld2PixelTransform(self.wcs, invert_xy=self.invert_xy)
+        return WCSWorld2PixelTransform(self.wcs, invert_xy=self.invert_xy)
