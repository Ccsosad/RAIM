diff --git a/xarray/__init__.py b/xarray/__init__.py
index baa9651..f2d0e58 100644
--- a/xarray/__init__.py
+++ b/xarray/__init__.py
@@ -9,6 +9,7 @@ from .backends.api import (
 )
 from .backends.rasterio_ import open_rasterio
 from .backends.zarr import open_zarr
+from .coding.calendar_ops import date_range, date_range_like
 from .coding.cftime_offsets import cftime_range
 from .coding.cftimeindex import CFTimeIndex
 from .coding.frequencies import infer_freq
diff --git a/xarray/core/accessor_dt.py b/xarray/core/accessor_dt.py
index 469c69b..4a04d01 100644
--- a/xarray/core/accessor_dt.py
+++ b/xarray/core/accessor_dt.py
@@ -404,6 +404,10 @@ class DatetimeAccessor(Properties):
 
     season = Properties._tslib_field_accessor("season", "Season of the year", object)
 
+    calendar = Properties._tslib_field_accessor(
+        "calendar", "The calendar of the datetimes", object
+    )
+
     time = Properties._tslib_field_accessor(
         "time", "Timestamps corresponding to datetimes", object
     )
diff --git a/xarray/core/dataarray.py b/xarray/core/dataarray.py
index e6fae2b..34ad465 100644
--- a/xarray/core/dataarray.py
+++ b/xarray/core/dataarray.py
@@ -1045,6 +1045,49 @@ class DataArray(AbstractArray, DataWithCoords, DataArrayArithmetic):
             indexes = {k: v.copy(deep=deep) for k, v in self._indexes.items()}
         return self._replace(variable, coords, indexes=indexes)
 
+    def convert_calendar(self, calendar, use_cftime=None, align_on=None):
+        """Convert the calendar of the time coordinate.
+        The data is not modified, only the time coordinate is.
+        For conversions involving a "360_day" calendar, the dates can be aligned
+        on the "month" or "year" to avoid missing values.
+        Parameters
+        ----------
+        calendar : str
+            The target calendar.
+        use_cftime : bool, optional
+            Whether to generate a :py:class:`~xarray.CFTimeIndex`.
+            If ``None`` (default), this is inferred from the calendar.
+        align_on : {"month", "year"}, optional
+            Only used for conversions involving a "360_day" calendar.
+            If "month", the last day of a month in the source calendar is
+            converted to the last day of the month in the target calendar.
+            If "year", the last day of the year is converted to the last day of
+            the year.
+        Returns
+        -------
+        DataArray
+        """
+        ds = self._to_temp_dataset().convert_calendar(
+            calendar, use_cftime=use_cftime, align_on=align_on
+        )
+        return self._from_temp_dataset(ds)
+
+    def interp_calendar(self, calendar, use_cftime=None):
+        """Interpolate the DataArray from one calendar to another.
+        Parameters
+        ----------
+        calendar : str
+            The target calendar.
+        use_cftime : bool, optional
+            Whether to generate a :py:class:`~xarray.CFTimeIndex`.
+            If ``None`` (default), this is inferred from the calendar.
+        Returns
+        -------
+        DataArray
+        """
+        ds = self._to_temp_dataset().interp_calendar(calendar, use_cftime=use_cftime)
+        return self._from_temp_dataset(ds)
+
     def __copy__(self) -> "DataArray":
         return self.copy(deep=False)
 
@@ -4658,4 +4701,4 @@ class DataArray(AbstractArray, DataWithCoords, DataArrayArithmetic):
 
     # this needs to be at the end, or mypy will confuse with `str`
     # https://mypy.readthedocs.io/en/latest/common_issues.html#dealing-with-conflicting-names
-    str = utils.UncachedAccessor(StringAccessor)
+    str = utils.UncachedAccessor(StringAccessor)
diff --git a/xarray/core/dataset.py b/xarray/core/dataset.py
index 0054d15..5cca67a 100644
--- a/xarray/core/dataset.py
+++ b/xarray/core/dataset.py
@@ -1808,6 +1808,49 @@ class Dataset(DataWithCoords, DatasetArithmetic, Mapping):
                 del obj._variables[name]
         return obj
 
+    def convert_calendar(self, calendar, use_cftime=None, align_on=None):
+        """Convert the calendar of the time coordinate.
+        The data is not modified, only the time coordinate is.
+        For conversions involving a "360_day" calendar, the dates can be aligned
+        on the "month" or "year" to avoid missing values.
+        Parameters
+        ----------
+        calendar : str
+            The target calendar.
+        use_cftime : bool, optional
+            Whether to generate a :py:class:`~xarray.CFTimeIndex`.
+            If ``None`` (default), this is inferred from the calendar.
+        align_on : {"month", "year"}, optional
+            Only used for conversions involving a "360_day" calendar.
+            If "month", the last day of a month in the source calendar is
+            converted to the last day of the month in the target calendar.
+            If "year", the last day of the year is converted to the last day of
+            the year.
+        Returns
+        -------
+        Dataset
+        """
+        from ..coding.calendar_ops import convert_calendar
+
+        return convert_calendar(self, calendar, use_cftime=use_cftime, align_on=align_on)
+
+    def interp_calendar(self, calendar, use_cftime=None):
+        """Interpolate the dataset from one calendar to another.
+        Parameters
+        ----------
+        calendar : str
+            The target calendar.
+        use_cftime : bool, optional
+            Whether to generate a :py:class:`~xarray.CFTimeIndex`.
+            If ``None`` (default), this is inferred from the calendar.
+        Returns
+        -------
+        Dataset
+        """
+        from ..coding.calendar_ops import interp_calendar
+
+        return interp_calendar(self, calendar, use_cftime=use_cftime)
+
     def dump_to_store(self, store: "AbstractDataStore", **kwargs) -> None:
         """Store dataset contents to a backends.*DataStore object."""
         from ..backends.api import dump_to_store
@@ -7730,4 +7773,4 @@ class Dataset(DataWithCoords, DatasetArithmetic, Mapping):
         )
         result.attrs = self.attrs.copy()
 
-        return result
+        return result
diff --git a/xarray/coding/calendar_ops.py b/xarray/coding/calendar_ops.py
new file mode 100644
index 0000000..57ee274
--- /dev/null
+++ b/xarray/coding/calendar_ops.py
@@ -0,0 +1,148 @@
+"""Operations for converting between different calendars."""
+import numpy as np
+import pandas as pd
+
+from ..core.dataarray import DataArray
+from .cftime_offsets import cftime_range
+from .frequencies import infer_freq
+
+
+def _should_cftime_be_used(calendar, use_cftime):
+    """Helper function to decide if cftime should be used."""
+    if use_cftime is None:
+        return calendar.lower() not in ("standard", "gregorian", "proleptic_gregorian")
+    return use_cftime
+
+
+def date_range(
+    start=None,
+    end=None,
+    periods=None,
+    freq=None,
+    calendar="standard",
+    use_cftime=None,
+    **kwargs,
+):
+    """Returns a fixed frequency DatetimeIndex or CFTimeIndex.
+    This is a wrapper around :py:func:`pandas.date_range` and
+    :py:func:`xarray.cftime_range`.
+    Parameters
+    ----------
+    start : str or datetime-like, optional
+        Left bound for generating dates.
+    end : str or datetime-like, optional
+        Right bound for generating dates.
+    periods : int, optional
+        Number of periods to generate.
+    freq : str or DateOffset, default: "D"
+        Frequency strings can have multiples, e.g. "5H".
+    calendar : str, default: "standard"
+        Calendar to use for the datetimes.
+    use_cftime : bool, optional
+        Whether to generate a :py:class:`~xarray.CFTimeIndex`.
+        If ``None`` (default), this is inferred from the calendar.
+    **kwargs :
+        Other arguments passed to :py:func:`pandas.date_range` or
+        :py:func:`xarray.cftime_range`.
+    Returns
+    -------
+    datetimes : DatetimeIndex or CFTimeIndex
+    """
+    if _should_cftime_be_used(calendar, use_cftime):
+        return cftime_range(start, end, periods, freq, calendar=calendar, **kwargs)
+    if calendar not in ("standard", "gregorian", "proleptic_gregorian"):
+        raise ValueError(
+            f"Calendar '{calendar}' is not supported by pandas. "
+            "To use a non-standard calendar, please install cftime and "
+            "set `use_cftime=True`."
+        )
+    return pd.date_range(start, end, periods, freq, **kwargs)
+
+
+def date_range_like(source, calendar, use_cftime=None, infer_freq=True):
+    """Generate a date range of a new calendar from a source DataArray.
+    The new range will have the same number of elements and the same start and
+    end dates as the source. If ``infer_freq`` is ``True``, the frequency will
+    be inferred from the source and used in the new range.
+    Parameters
+    ----------
+    source : DataArray
+        A 1D DataArray of datetime objects.
+    calendar : str
+        The calendar of the new date range.
+    use_cftime : bool, optional
+        Whether to generate a :py:class:`~xarray.CFTimeIndex`.
+        If ``None`` (default), this is inferred from the calendar.
+    infer_freq : bool, default: True
+        Whether to infer the frequency from the source and use it to generate
+        the new date range.
+    Returns
+    -------
+    CFTimeIndex or DatetimeIndex
+    """
+    if not isinstance(source, DataArray) or source.ndim != 1:
+        raise TypeError(
+            "'source' must be a 1D array of datetime objects for inferring its range."
+        )
+
+    start = source.min().item()
+    periods = source.size
+    if infer_freq:
+        freq = infer_freq(source)
+        if freq is None:
+            raise ValueError(
+                "`date_range_like` was unable to generate a range as the source frequency was not inferrable."
+            )
+        end = None
+    else:
+        freq = None
+        end = source.max().item()
+
+    return date_range(
+        start=start,
+        end=end,
+        periods=periods,
+        freq=freq,
+        calendar=calendar,
+        use_cftime=use_cftime,
+    )
+
+
+def convert_calendar(dataset, target, use_cftime=None, align_on=None):
+    """Convert the calendar of a dataset's time coordinate."""
+    if "time" not in dataset.coords:
+        raise ValueError("Dataset does not have a 'time' coordinate.")
+
+    source_calendar = dataset.time.dt.calendar
+    if source_calendar == target:
+        return dataset.copy()
+
+    if align_on is not None and not (
+        source_calendar == "360_day" or target == "360_day"
+    ):
+        raise ValueError("`align_on` is only supported for 360_day calendars.")
+
+    new_time = date_range_like(dataset.time, target, use_cftime=use_cftime)
+
+    if align_on == "month":
+        source_eom = dataset.time.dt.is_month_end
+        target_eom_ind = np.where(new_time.is_month_end)[0]
+        new_time_values = new_time.values
+        new_time_values[source_eom] = new_time[target_eom_ind]
+        new_time = DataArray(new_time_values, dims="time")
+    elif align_on == "year":
+        source_eoy = dataset.time.dt.is_year_end
+        target_eoy_ind = np.where(new_time.is_year_end)[0]
+        new_time_values = new_time.values
+        new_time_values[source_eoy] = new_time[target_eoy_ind]
+        new_time = DataArray(new_time_values, dims="time")
+
+    return dataset.assign_coords(time=new_time)
+
+
+def interp_calendar(dataset, target, use_cftime=None):
+    """Interpolate a dataset from one calendar to another."""
+    if "time" not in dataset.coords:
+        raise ValueError("Dataset does not have a 'time' coordinate.")
+    new_time = date_range_like(dataset.time, target, use_cftime=use_cftime)
+    return dataset.interp(time=new_time)
