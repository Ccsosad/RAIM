diff --git a/astropy/visualization/wcsaxes/wcsapi.py b/astropy/visualization/wcsaxes/wcsapi.py
index 18817a1..de1179b 100644
--- a/astropy/visualization/wcsaxes/wcsapi.py
+++ b/astropy/visualization/wcsaxes/wcsapi.py
@@ -25,18 +25,23 @@ def transform_coord_meta_from_wcs(wcs, frame_class, slices=None):
     if slices is not None:
         slices = tuple(slices)
 
-    if wcs.pixel_n_dim > 2:
-        if slices is None:
-            raise ValueError("WCS has more than 2 pixel dimensions, so "
-                             "'slices' should be set")
-        elif len(slices) != wcs.pixel_n_dim:
-            raise ValueError("'slices' should have as many elements as WCS "
-                             "has pixel dimensions (should be {})"
-                             .format(wcs.pixel_n_dim))
-    elif wcs.pixel_n_dim < 2:
-        raise ValueError("WCS should have at least 2 pixel dimensions")
-    elif slices is not None and slices != ('x', 'y') and slices != ('y', 'x'):
-        raise ValueError("WCS only has 2 pixel dimensions and cannot be sliced")
+    # Determine the number of pixel dimensions in the sliced WCS
+    if slices is not None:
+        # We will create a temporary sliced WCS to get its pixel dimensions
+        wcs_slice_temp = list(slices)
+        if 'x' in wcs_slice_temp:
+            wcs_slice_temp[wcs_slice_temp.index('x')] = slice(None)
+        if 'y' in wcs_slice_temp:
+            wcs_slice_temp[wcs_slice_temp.index('y')] = slice(None)
+        wcs_temp = SlicedLowLevelWCS(wcs, wcs_slice_temp[::-1])
+        pixel_n_dim_sliced = wcs_temp.pixel_n_dim
+    else:
+        pixel_n_dim_sliced = wcs.pixel_n_dim
+
+    if pixel_n_dim_sliced > 2:
+        raise ValueError("Sliced WCS has more than 2 pixel dimensions")
+    elif pixel_n_dim_sliced < 1:
+        raise ValueError("Sliced WCS should have at least 1 pixel dimension")
 
     is_fits_wcs = isinstance(wcs, WCS)
 
@@ -124,10 +129,15 @@ def transform_coord_meta_from_wcs(wcs, frame_class, slices=None):
     invert_xy = False
     if slices is not None:
         wcs_slice = list(slices)
-        wcs_slice[wcs_slice.index("x")] = slice(None)
-        wcs_slice[wcs_slice.index("y")] = slice(None)
+        if 'x' in wcs_slice:
+            wcs_slice[wcs_slice.index('x')] = slice(None)
+        if 'y' in wcs_slice:
+            wcs_slice[wcs_slice.index('y')] = slice(None)
         wcs = SlicedLowLevelWCS(wcs, wcs_slice[::-1])
-        invert_xy = slices.index('x') > slices.index('y')
+        if 'x' in slices and 'y' in slices:
+            invert_xy = slices.index('x') > slices.index('y')
+        else:
+            invert_xy = False
         world_keep = wcs._world_keep
     else:
         world_keep = list(range(wcs.world_n_dim))
@@ -141,40 +151,51 @@ def transform_coord_meta_from_wcs(wcs, frame_class, slices=None):
     if invert_xy:
         m = m[:, ::-1]
 
-    if frame_class is RectangularFrame:
-
-        for i, spine_name in enumerate('bltr'):
-            pos = np.nonzero(m[:, i % 2])[0]
-            if len(pos) > 0:
-                index = world_keep[pos[0]]
-                coord_meta['default_axislabel_position'][index] = spine_name
-                coord_meta['default_ticklabel_position'][index] = spine_name
-                coord_meta['default_ticks_position'][index] = spine_name
-                m[pos[0], :] = 0
-
-        # In the special and common case where the frame is rectangular and
-        # we are dealing with 2-d WCS (after slicing), we show all ticks on
-        # all axes for backward-compatibility.
-        if len(world_keep) == 2:
-            for index in world_keep:
-                coord_meta['default_ticks_position'][index] = 'bltr'
-
-    elif frame_class is EllipticalFrame:
-
-        if 'longitude' in coord_meta['type']:
-            lon_idx = coord_meta['type'].index('longitude')
-            coord_meta['default_axislabel_position'][lon_idx] = 'h'
-            coord_meta['default_ticklabel_position'][lon_idx] = 'h'
-            coord_meta['default_ticks_position'][lon_idx] = 'h'
-
-        if 'latitude' in coord_meta['type']:
-            lat_idx = coord_meta['type'].index('latitude')
-            coord_meta['default_axislabel_position'][lat_idx] = 'c'
-            coord_meta['default_ticklabel_position'][lat_idx] = 'c'
-            coord_meta['default_ticks_position'][lat_idx] = 'c'
+    if wcs.pixel_n_dim == 2:
+        if frame_class is RectangularFrame:
+
+            for i, spine_name in enumerate('bltr'):
+                pos = np.nonzero(m[:, i % 2])[0]
+                if len(pos) > 0:
+                    index = world_keep[pos[0]]
+                    coord_meta['default_axislabel_position'][index] = spine_name
+                    coord_meta['default_ticklabel_position'][index] = spine_name
+                    coord_meta['default_ticks_position'][index] = spine_name
+                    m[pos[0], :] = 0
+
+            # In the special and common case where the frame is rectangular and
+            # we are dealing with 2-d WCS (after slicing), we show all ticks on
+            # all axes for backward-compatibility.
+            if len(world_keep) == 2:
+                for index in world_keep:
+                    coord_meta['default_ticks_position'][index] = 'bltr'
+
+        elif frame_class is EllipticalFrame:
+
+            if 'longitude' in coord_meta['type']:
+                lon_idx = coord_meta['type'].index('longitude')
+                coord_meta['default_axislabel_position'][lon_idx] = 'h'
+                coord_meta['default_ticklabel_position'][lon_idx] = 'h'
+                coord_meta['default_ticks_position'][lon_idx] = 'h'
+
+            if 'latitude' in coord_meta['type']:
+                lat_idx = coord_meta['type'].index('latitude')
+                coord_meta['default_axislabel_position'][lat_idx] = 'c'
+                coord_meta['default_ticklabel_position'][lat_idx] = 'c'
+                coord_meta['default_ticks_position'][lat_idx] = 'c'
 
-    else:
+        else:
 
+            for i in range(len(coord_meta['type'])):
+                if i in world_keep:
+                    index = world_keep[i]
+                    coord_meta['default_axislabel_position'][index] = frame_class.spine_names
+                    coord_meta['default_ticklabel_position'][index] = frame_class.spine_names
+                    coord_meta['default_ticks_position'][index] = frame_class.spine_names
+    else:
+        # 1D case
+        # We assume the frame is a 1D frame with one spine.
+        # We'll set the only visible coordinate to that spine.
         for i in range(len(coord_meta['type'])):
             if i in world_keep:
                 index = world_keep[i]
