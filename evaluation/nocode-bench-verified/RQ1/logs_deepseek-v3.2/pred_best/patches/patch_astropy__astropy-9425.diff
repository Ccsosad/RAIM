diff --git a/astropy/table/table.py b/astropy/table/table.py
index dbde177..efc0144 100644
--- a/astropy/table/table.py
+++ b/astropy/table/table.py
@@ -814,22 +814,48 @@ class Table:
         else:
             names_from_data = sorted(names_from_data)
 
-        # Note: if set(data[0].keys()) != names_from_data, this will give an
-        # exception later, so NO need to catch here.
+        # Check if there are any missing keys in any row
+        has_missing = False
+        for row in data:
+            if set(row.keys()) != names_from_data:
+                has_missing = True
+                break
+
+        # If there are missing keys and the table is not masked, we need to mask it
+        if has_missing and not self.masked:
+            self._set_masked(True)
 
         cols = {}
         for name in names_from_data:
-            cols[name] = []
-            for i, row in enumerate(data):
-                try:
-                    cols[name].append(row[name])
-                except KeyError:
-                    raise ValueError(f'Row {i} has no value for column {name}')
+            col_vals = []
+            mask_vals = []
+            for row in data:
+                if name in row:
+                    col_vals.append(row[name])
+                    mask_vals.append(False)
+                else:
+                    # Placeholder value (will be masked)
+                    col_vals.append(None)
+                    mask_vals.append(True)
+            
+            # Create the column
+            if self.masked and any(mask_vals):
+                # Create a MaskedColumn
+                col = self.MaskedColumn(data=col_vals, mask=mask_vals, name=name)
+            else:
+                # Create a regular Column
+                col = self.Column(data=col_vals, name=name)
+            
+            cols[name] = col
 
         if all(name is None for name in names):
             names = names_from_data
 
-        self._init_from_dict(cols, names, dtype, n_cols, copy)
+        # Now we have a dictionary of columns. We can call _init_from_dict
+        # but we need to pass the columns as data. However, _init_from_dict expects
+        # raw data, not Column objects. So we will use _init_from_cols instead.
+        col_list = [cols[name] for name in names_from_data]
+        self._init_from_cols(col_list)
         return
 
     def _init_from_list(self, data, names, dtype, n_cols, copy):
