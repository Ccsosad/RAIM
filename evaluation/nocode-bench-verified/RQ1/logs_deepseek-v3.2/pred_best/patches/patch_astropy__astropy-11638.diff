diff --git a/astropy/time/core.py b/astropy/time/core.py
index 836039e..ffb2a89 100644
--- a/astropy/time/core.py
+++ b/astropy/time/core.py
@@ -1,3 +1,4 @@
+
 # -*- coding: utf-8 -*-
 # Licensed under a 3-clause BSD style license - see LICENSE.rst
 """
@@ -1484,27 +1485,6 @@ class Time(TimeBase):
                 precision=None, in_subfmt=None, out_subfmt=None,
                 location=None, copy=False):
 
-        # Because of import problems, this can only be done on
-        # first call of Time. The initialization is complicated because
-        # update_leap_seconds uses Time.
-        # In principle, this may cause wrong leap seconds in
-        # update_leap_seconds itself, but since expiration is in
-        # units of days, that is fine.
-        global _LEAP_SECONDS_CHECK
-        if _LEAP_SECONDS_CHECK != _LeapSecondsCheck.DONE:
-            with _LEAP_SECONDS_LOCK:
-                # There are three ways we can get here:
-                # 1. First call (NOT_STARTED).
-                # 2. Re-entrant call (RUNNING). We skip the initialisation
-                #    and don't worry about leap second errors.
-                # 3. Another thread which raced with the first call
-                #    (RUNNING). The first thread has relinquished the
-                #    lock to us, so initialization is complete.
-                if _LEAP_SECONDS_CHECK == _LeapSecondsCheck.NOT_STARTED:
-                    _LEAP_SECONDS_CHECK = _LeapSecondsCheck.RUNNING
-                    update_leap_seconds()
-                    _LEAP_SECONDS_CHECK = _LeapSecondsCheck.DONE
-
         if isinstance(val, Time):
             self = val.replicate(format=format, copy=copy, cls=cls)
         else:
@@ -1927,6 +1907,22 @@ class Time(TimeBase):
         If delta_ut1_utc is not yet set, this will interpolate them from the
         the IERS table.
         """
+        # Update leap seconds if needed, before doing any UTC-related transformation.
+        global _LEAP_SECONDS_CHECK
+        if _LEAP_SECONDS_CHECK != _LeapSecondsCheck.DONE:
+            with _LEAP_SECONDS_LOCK:
+                # There are three ways we can get here:
+                # 1. First call (NOT_STARTED).
+                # 2. Re-entrant call (RUNNING). We skip the initialisation
+                #    and don't worry about leap second errors.
+                # 3. Another thread which raced with the first call
+                #    (RUNNING). The first thread has relinquished the
+                #    lock to us, so initialization is complete.
+                if _LEAP_SECONDS_CHECK == _LeapSecondsCheck.NOT_STARTED:
+                    _LEAP_SECONDS_CHECK = _LeapSecondsCheck.RUNNING
+                    update_leap_seconds()
+                    _LEAP_SECONDS_CHECK = _LeapSecondsCheck.DONE
+
         # Sec. 4.3.1: the arg DUT is the quantity delta_UT1 = UT1 - UTC in
         # seconds. It is obtained from tables published by the IERS.
         if not hasattr(self, '_delta_ut1_utc'):
