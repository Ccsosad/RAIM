diff --git a/_pytest/logging.py b/_pytest/logging.py
new file mode 100644
index 0000000..79cb7e3
--- /dev/null
+++ b/_pytest/logging.py
@@ -0,0 +1,335 @@
+"""
+Logging related functionality.
+"""
+import logging
+import os
+from contextlib import contextmanager
+from io import StringIO
+
+import py
+
+import _pytest
+from _pytest.config import create_terminal_writer
+
+
+class LogCaptureHandler(logging.StreamHandler):
+    """
+    A logging handler that stores log records and the log text.
+    """
+
+    def __init__(self):
+        """
+        Initialize the handler.
+        """
+        logging.StreamHandler.__init__(self)
+        self.records = []
+        self.stream = StringIO()
+
+    def emit(self, record):
+        """
+        Handle a log record.
+        """
+        self.records.append(record)
+        logging.StreamHandler.emit(self, record)
+
+    def reset(self):
+        """
+        Reset the handler.
+        """
+        self.records = []
+        self.stream = StringIO()
+
+
+class LogCaptureFixture(object):
+    """
+    Fixture for capturing log messages.
+    """
+
+    def __init__(self, item):
+        """
+        Initialize the fixture.
+        """
+        self._item = item
+        self._initial_log_levels = {}  # type: dict
+        self.handler = None
+
+    def _setup(self):
+        """
+        Set up the fixture.
+        """
+        # Add a log handler to the root logger.
+        self.handler = LogCaptureHandler()
+        logging.root.addHandler(self.handler)
+        # Set a custom formatter with the same format as the log capture.
+        self.handler.setFormatter(self._item.session._log_formatter)
+        # Set the handler level to the root logger level.
+        self.handler.setLevel(logging.root.level)
+
+    def _finalize(self):
+        """
+        Finalize the fixture.
+        """
+        if self.handler is not None:
+            logging.root.removeHandler(self.handler)
+            self.handler = None
+        # Restore the initial log levels.
+        for logger_name, level in self._initial_log_levels.items():
+            logging.getLogger(logger_name).setLevel(level)
+
+    @property
+    def records(self):
+        """
+        Get the log records.
+        """
+        if self.handler is None:
+            return []
+        return self.handler.records
+
+    @property
+    def text(self):
+        """
+        Get the log text.
+        """
+        if self.handler is None:
+            return ""
+        return self.handler.stream.getvalue()
+
+    @property
+    def record_tuples(self):
+        """
+        Get the log records as tuples.
+        """
+        return [(r.name, r.levelno, r.getMessage()) for r in self.records]
+
+    def set_level(self, level, logger=None):
+        """
+        Set the log level.
+        """
+        if logger is None:
+            logger = logging.root
+        else:
+            logger = logging.getLogger(logger)
+        # Save the initial log level.
+        if logger.name not in self._initial_log_levels:
+            self._initial_log_levels[logger.name] = logger.level
+        logger.setLevel(level)
+        if self.handler is not None and logger is logging.root:
+            self.handler.setLevel(level)
+
+    @contextmanager
+    def at_level(self, level, logger=None):
+        """
+        Context manager to set the log level temporarily.
+        """
+        if logger is None:
+            logger = logging.root
+        else:
+            logger = logging.getLogger(logger)
+        original_level = logger.level
+        logger.setLevel(level)
+        try:
+            yield
+        finally:
+            logger.setLevel(original_level)
+
+    def clear(self):
+        """
+        Clear the captured log records.
+        """
+        if self.handler is not None:
+            self.handler.reset()
+
+
+def pytest_addoption(parser):
+    """
+    Add logging related options.
+    """
+    group = parser.getgroup("logging")
+    group.addoption(
+        "--log-level",
+        dest="log_level",
+        default=None,
+        help="Set the log level for the root logger.",
+    )
+    group.addoption(
+        "--log-format",
+        dest="log_format",
+        default="%(levelname)-8s %(name)s:%(lineno)d %(message)s",
+        help="Set the log format.",
+    )
+    group.addoption(
+        "--log-date-format",
+        dest="log_date_format",
+        default=None,
+        help="Set the log date format.",
+    )
+    group.addoption(
+        "--log-cli-level",
+        dest="log_cli_level",
+        default=None,
+        help="Set the log level for the console.",
+    )
+    group.addoption(
+        "--log-cli-format",
+        dest="log_cli_format",
+        default=None,
+        help="Set the log format for the console.",
+    )
+    group.addoption(
+        "--log-cli-date-format",
+        dest="log_cli_date_format",
+        default=None,
+        help="Set the log date format for the console.",
+    )
+    group.addoption(
+        "--log-file",
+        dest="log_file",
+        default=None,
+        help="Write logs to a file.",
+    )
+    group.addoption(
+        "--log-file-level",
+        dest="log_file_level",
+        default=None,
+        help="Set the log level for the log file.",
+    )
+    group.addoption(
+        "--log-file-format",
+        dest="log_file_format",
+        default=None,
+        help="Set the log format for the log file.",
+    )
+    group.addoption(
+        "--log-file-date-format",
+        dest="log_file_date_format",
+        default=None,
+        help="Set the log date format for the log file.",
+    )
+    group.addoption(
+        "--no-print-logs",
+        dest="log_print",
+        action="store_false",
+        default=True,
+        help="Disable printing logs on test failure.",
+    )
+
+
+def pytest_configure(config):
+    """
+    Configure the logging plugin.
+    """
+    # Create a formatter for log capture.
+    log_format = config.getoption("log_format")
+    log_date_format = config.getoption("log_date_format")
+    formatter = logging.Formatter(log_format, log_date_format)
+    config._log_formatter = formatter
+
+    # Set up the root logger level.
+    log_level = config.getoption("log_level")
+    if log_level is not None:
+        logging.root.setLevel(log_level.upper())
+
+    # Set up console logging if required.
+    log_cli_level = config.getoption("log_cli_level")
+    if log_cli_level is not None:
+        # Create a terminal writer.
+        tw = create_terminal_writer(config)
+        # Create a console handler.
+        console_handler = logging.StreamHandler(tw._file)
+        console_handler.setLevel(log_cli_level.upper())
+        # Set the formatter.
+        log_cli_format = config.getoption("log_cli_format")
+        log_cli_date_format = config.getoption("log_cli_date_format")
+        if log_cli_format is None:
+            log_cli_format = log_format
+        if log_cli_date_format is None:
+            log_cli_date_format = log_date_format
+        console_formatter = logging.Formatter(log_cli_format, log_cli_date_format)
+        console_handler.setFormatter(console_formatter)
+        logging.root.addHandler(console_handler)
+
+    # Set up file logging if required.
+    log_file = config.getoption("log_file")
+    if log_file is not None:
+        # Create a file handler.
+        file_handler = logging.FileHandler(log_file, mode="w")
+        log_file_level = config.getoption("log_file_level")
+        if log_file_level is not None:
+            file_handler.setLevel(log_file_level.upper())
+        else:
+            file_handler.setLevel(logging.root.level)
+        # Set the formatter.
+        log_file_format = config.getoption("log_file_format")
+        log_file_date_format = config.getoption("log_file_date_format")
+        if log_file_format is None:
+            log_file_format = log_format
+        if log_file_date_format is None:
+            log_file_date_format = log_date_format
+        file_formatter = logging.Formatter(log_file_format, log_file_date_format)
+        file_handler.setFormatter(file_formatter)
+        logging.root.addHandler(file_handler)
+
+    # Register the plugin.
+    config.pluginmanager.register(LoggingPlugin(config), "logging-plugin")
+
+
+class LoggingPlugin(object):
+    """
+    Plugin for capturing logs.
+    """
+
+    def __init__(self, config):
+        """
+        Initialize the plugin.
+        """
+        self.config = config
+        self.log_capture_fixture = None
+
+    @pytest.hookimpl(hookwrapper=True)
+    def pytest_runtest_setup(self, item):
+        """
+        Set up the log capture for a test.
+        """
+        # Check if the test uses the caplog fixture.
+        if "caplog" in item.fixturenames:
+            self.log_capture_fixture = LogCaptureFixture(item)
+            self.log_capture_fixture._setup()
+        yield
+        # No cleanup here, that's done in teardown.
+
+    @pytest.hookimpl(hookwrapper=True)
+    def pytest_runtest_teardown(self, item):
+        """
+        Tear down the log capture for a test.
+        """
+        yield
+        if self.log_capture_fixture is not None:
+            self.log_capture_fixture._finalize()
+            self.log_capture_fixture = None
+
+    @pytest.hookimpl(hookwrapper=True)
+    def pytest_runtest_makereport(self, item, call):
+        """
+        Add captured logs to the test report.
+        """
+        outcome = yield
+        report = outcome.get_result()
+        # Only add logs to the report if the test failed and we have captured logs.
+        if report.failed and self.log_capture_fixture is not None:
+            # Get the captured log text.
+            log_text = self.log_capture_fixture.text
+            if log_text:
+                # Add a new section to the report.
+                report.sections.append(("Captured stdlog call", log_text))
+        return report
+
+    @pytest.fixture
+    def caplog(self, request):
+        """
+        Fixture for capturing log messages.
+        """
+        if self.log_capture_fixture is None:
+            # This should not happen, but just in case.
+            self.log_capture_fixture = LogCaptureFixture(request.node)
+            self.log_capture_fixture._setup()
+        return self.log_capture_fixture
