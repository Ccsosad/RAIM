diff --git a/xarray/coding/times.py b/xarray/coding/times.py
index 3885b1c..5406125 100644
--- a/xarray/coding/times.py
+++ b/xarray/coding/times.py
@@ -250,7 +250,7 @@ def _decode_datetime_with_pandas(flat_num_dates, units, calendar):
     return (pd.to_timedelta(flat_num_dates_ns_int, "ns") + ref_date).values
 
 
-def decode_cf_datetime(num_dates, units, calendar=None, use_cftime=None):
+def decode_cf_datetime(num_dates, units, calendar=None, use_cftime=None, name=None):
     """Given an array of numeric dates in netCDF format, convert it into a
     numpy array of date time objects.
 
@@ -265,41 +265,50 @@ def decode_cf_datetime(num_dates, units, calendar=None, use_cftime=None):
     --------
     cftime.num2date
     """
-    num_dates = np.asarray(num_dates)
-    flat_num_dates = num_dates.ravel()
-    if calendar is None:
-        calendar = "standard"
+    try:
+        num_dates = np.asarray(num_dates)
+        flat_num_dates = num_dates.ravel()
+        if calendar is None:
+            calendar = "standard"
+
+        if use_cftime is None:
+            try:
+                dates = _decode_datetime_with_pandas(flat_num_dates, units, calendar)
+            except (KeyError, OutOfBoundsDatetime, OutOfBoundsTimedelta, OverflowError):
+                dates = _decode_datetime_with_cftime(
+                    flat_num_dates.astype(float), units, calendar
+                )
 
-    if use_cftime is None:
-        try:
+                if (
+                    dates[np.nanargmin(num_dates)].year < 1678
+                    or dates[np.nanargmax(num_dates)].year >= 2262
+                ):
+                    if _is_standard_calendar(calendar):
+                        warnings.warn(
+                            "Unable to decode time axis into full "
+                            "numpy.datetime64 objects, continuing using "
+                            "cftime.datetime objects instead, reason: dates out "
+                            "of range",
+                            SerializationWarning,
+                            stacklevel=3,
+                        )
+                else:
+                    if _is_standard_calendar(calendar):
+                        dates = cftime_to_nptime(dates)
+        elif use_cftime:
+            dates = _decode_datetime_with_cftime(flat_num_dates, units, calendar)
+        else:
             dates = _decode_datetime_with_pandas(flat_num_dates, units, calendar)
-        except (KeyError, OutOfBoundsDatetime, OutOfBoundsTimedelta, OverflowError):
-            dates = _decode_datetime_with_cftime(
-                flat_num_dates.astype(float), units, calendar
-            )
 
-            if (
-                dates[np.nanargmin(num_dates)].year < 1678
-                or dates[np.nanargmax(num_dates)].year >= 2262
-            ):
-                if _is_standard_calendar(calendar):
-                    warnings.warn(
-                        "Unable to decode time axis into full "
-                        "numpy.datetime64 objects, continuing using "
-                        "cftime.datetime objects instead, reason: dates out "
-                        "of range",
-                        SerializationWarning,
-                        stacklevel=3,
-                    )
-            else:
-                if _is_standard_calendar(calendar):
-                    dates = cftime_to_nptime(dates)
-    elif use_cftime:
-        dates = _decode_datetime_with_cftime(flat_num_dates, units, calendar)
-    else:
-        dates = _decode_datetime_with_pandas(flat_num_dates, units, calendar)
-
-    return dates.reshape(num_dates.shape)
+        return dates.reshape(num_dates.shape)
+    except Exception as e:
+        if name is not None:
+            raise ValueError(
+                f"Failed to decode time variable {name!r} with units {units!r} "
+                f"and calendar {calendar!r}. Error: {e}"
+            ) from e
+        else:
+            raise
 
 
 def to_timedelta_unboxed(value, **kwargs):
@@ -691,6 +700,7 @@ class CFDatetimeCoder(VariableCoder):
                 units=units,
                 calendar=calendar,
                 use_cftime=self.use_cftime,
+                name=name,
             )
             data = lazy_elemwise_func(data, transform, dtype)
 
diff --git a/xarray/coding/variables.py b/xarray/coding/variables.py
index 9592ba1..c3c7350 100644
--- a/xarray/coding/variables.py
+++ b/xarray/coding/variables.py
@@ -209,19 +209,28 @@ class CFMaskCoder(VariableCoder):
                     encoded_fill_values=encoded_fill_values,
                     decoded_fill_value=decoded_fill_value,
                     dtype=dtype,
+                    name=name,
                 )
                 data = lazy_elemwise_func(data, transform, dtype)
 
         return Variable(dims, data, attrs, encoding)
 
 
-def _scale_offset_decoding(data, scale_factor, add_offset, dtype):
-    data = np.array(data, dtype=dtype, copy=True)
-    if scale_factor is not None:
-        data *= scale_factor
-    if add_offset is not None:
-        data += add_offset
-    return data
+def _scale_offset_decoding(data, scale_factor, add_offset, dtype, name=None):
+    try:
+        data = np.array(data, dtype=dtype, copy=True)
+        if scale_factor is not None:
+            data *= scale_factor
+        if add_offset is not None:
+            data += add_offset
+        return data
+    except Exception as e:
+        if name is not None:
+            raise ValueError(
+                f"Failed to decode scale/offset for variable {name!r}. Error: {e}"
+            ) from e
+        else:
+            raise
 
 
 def _choose_float_dtype(dtype, has_offset):
@@ -279,6 +288,7 @@ class CFScaleOffsetCoder(VariableCoder):
                 scale_factor=scale_factor,
                 add_offset=add_offset,
                 dtype=dtype,
+                name=name,
             )
             data = lazy_elemwise_func(data, transform, dtype)
 
