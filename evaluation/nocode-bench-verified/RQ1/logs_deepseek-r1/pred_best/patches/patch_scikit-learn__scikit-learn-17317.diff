diff --git a/sklearn/preprocessing/_encoders.py b/sklearn/preprocessing/_encoders.py
index 221a7b7..d49b5f8 100644
--- a/sklearn/preprocessing/_encoders.py
+++ b/sklearn/preprocessing/_encoders.py
@@ -71,6 +71,17 @@ class _BaseEncoder(TransformerMixin, BaseEstimator):
         # numpy arrays, sparse arrays
         return X[:, feature_idx]
 
+    def _is_null(self, x):
+        """Check if values are null (None or np.nan)"""
+        if hasattr(pd, 'isnull'):
+            return pd.isnull(x)
+        else:
+            if x.dtype == object:
+                return np.array([val is None or (isinstance(val, float) and np.isnan(val)) 
+                               for val in x], dtype=bool)
+            else:
+                return np.isnan(x)
+
     def _fit(self, X, handle_unknown='error'):
         X_list, n_samples, n_features = self._check_X(X)
 
@@ -84,7 +95,20 @@ class _BaseEncoder(TransformerMixin, BaseEstimator):
         for i in range(n_features):
             Xi = X_list[i]
             if self.categories == 'auto':
-                cats = _unique(Xi)
+                # Handle missing values by including them as categories
+                mask = pd.isnull(Xi) if hasattr(pd, 'isnull') else _is_null(Xi)
+                valid_values = Xi[~mask]
+                unique_valid = _unique(valid_values)
+                
+                # Add missing values as separate categories
+                null_mask = mask
+                if np.any(null_mask):
+                    null_indices = np.where(null_mask)[0]
+                    null_values = Xi[null_indices]
+                    unique_nulls = _unique(null_values)
+                    cats = np.concatenate([unique_valid, unique_nulls])
+                else:
+                    cats = unique_valid
             else:
                 cats = np.array(self.categories[i], dtype=Xi.dtype)
                 if Xi.dtype != object:
@@ -105,6 +129,54 @@ class _BaseEncoder(TransformerMixin, BaseEstimator):
         X_int = np.zeros((n_samples, n_features), dtype=int)
         X_mask = np.ones((n_samples, n_features), dtype=bool)
 
+        # Handle missing values by mapping them to their respective categories
+        for i in range(n_features):
+            Xi = X_list[i]
+            cats = self.categories_[i]
+            null_mask = self._is_null(Xi)
+            
+            if np.any(null_mask):
+                # For missing values, find their position in categories
+                null_values = Xi[null_mask]
+                for j, val in enumerate(null_values):
+                    # Find the index of this null value in categories
+                    for k, cat_val in enumerate(cats):
+                        if (val is None and cat_val is None) or \
+                           (isinstance(val, float) and np.isnan(val) and 
+                            isinstance(cat_val, float) and np.isnan(cat_val)):
+                            X_int[null_mask, i] = k
+                            X_mask[null_mask, i] = True
+                            break
+                
+                # Handle non-null values normally
+                non_null_mask = ~null_mask
+                if np.any(non_null_mask):
+                    diff, valid_mask = _check_unknown(Xi[non_null_mask], cats, 
+                                                     return_mask=True)
+                    if diff:
+                        if handle_unknown == 'error':
+                            msg = ("Found unknown categories {0} in column {1}"
+                                   " during transform".format(diff, i))
+                            raise ValueError(msg)
+                        else:
+                            X_mask[non_null_mask, i] = valid_mask
+                            X_int[non_null_mask, i] = 0
+                    else:
+                        X_int[non_null_mask, i] = np.searchsorted(cats, Xi[non_null_mask])
+            else:
+                # Original logic for no missing values
+                diff, valid_mask = _check_unknown(Xi, cats, return_mask=True)
+                if diff:
+                    if handle_unknown == 'error':
+                        msg = ("Found unknown categories {0} in column {1}"
+                               " during transform".format(diff, i))
+                        raise ValueError(msg)
+                    else:
+                        X_mask[:, i] = valid_mask
+                        X_int[:, i] = 0
+                else:
+                    X_int[:, i] = np.searchsorted(cats, Xi)
+
         if n_features != len(self.categories_):
             raise ValueError(
                 "The number of features in X is different to the number of "
