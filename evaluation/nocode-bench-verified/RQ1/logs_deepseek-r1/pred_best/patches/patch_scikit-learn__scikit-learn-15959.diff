diff --git a/sklearn/multioutput.py b/sklearn/multioutput.py
index 50d6d32..4f388bf 100644
--- a/sklearn/multioutput.py
+++ b/sklearn/multioutput.py
@@ -32,12 +32,9 @@ __all__ = ["MultiOutputRegressor", "MultiOutputClassifier",
            "ClassifierChain", "RegressorChain"]
 
 
-def _fit_estimator(estimator, X, y, sample_weight=None):
+def _fit_estimator(estimator, X, y, **fit_params):
     estimator = clone(estimator)
-    if sample_weight is not None:
-        estimator.fit(X, y, sample_weight=sample_weight)
-    else:
-        estimator.fit(X, y)
+    estimator.fit(X, y, **fit_params)
     return estimator
 
 
@@ -121,7 +118,7 @@ class _MultiOutputEstimator(BaseEstimator, MetaEstimatorMixin,
                 sample_weight, first_time) for i in range(y.shape[1]))
         return self
 
-    def fit(self, X, y, sample_weight=None):
+    def fit(self, X, y, sample_weight=None, **fit_params):
         """ Fit the model to data.
         Fit a separate model for each output variable.
 
@@ -139,6 +136,9 @@ class _MultiOutputEstimator(BaseEstimator, MetaEstimatorMixin,
             Only supported if the underlying regressor supports sample
             weights.
 
+        **fit_params : dict of string -> object
+            Parameters passed to the ``estimator.fit`` method of each step.
+
         Returns
         -------
         self : object
@@ -159,14 +159,15 @@ class _MultiOutputEstimator(BaseEstimator, MetaEstimatorMixin,
             raise ValueError("y must have at least two dimensions for "
                              "multi-output regression but has only one.")
 
-        if (sample_weight is not None and
-                not has_fit_parameter(self.estimator, 'sample_weight')):
-            raise ValueError("Underlying estimator does not support"
-                             " sample weights.")
+        if sample_weight is not None:
+            if not has_fit_parameter(self.estimator, 'sample_weight'):
+                raise ValueError("Underlying estimator does not support"
+                                 " sample weights.")
+            fit_params['sample_weight'] = sample_weight
 
         self.estimators_ = Parallel(n_jobs=self.n_jobs)(
             delayed(_fit_estimator)(
-                self.estimator, X, y[:, i], sample_weight)
+                self.estimator, X, y[:, i], **fit_params)
             for i in range(y.shape[1]))
         return self
 
