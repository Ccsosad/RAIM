diff --git a/lib/matplotlib/axes/_axes.py b/lib/matplotlib/axes/_axes.py
index 44120b5..7a255ae 100644
--- a/lib/matplotlib/axes/_axes.py
+++ b/lib/matplotlib/axes/_axes.py
@@ -3075,10 +3075,9 @@ class Axes(_AxesBase):
             autopct=None, pctdistance=0.6, shadow=False, labeldistance=1.1,
             startangle=0, radius=1, counterclock=True,
             wedgeprops=None, textprops=None, center=(0, 0),
-            frame=False, rotatelabels=False, *, normalize=True):
+            frame=False, rotatelabels=False, *, hatch=None, normalize=True):
         """
         Plot a pie chart.
-
         Make a pie chart of array *x*.  The fractional area of each wedge is
         given by ``x/sum(x)``.
 
@@ -3101,6 +3100,11 @@ class Axes(_AxesBase):
             A sequence of colors through which the pie chart will cycle.  If
             *None*, will use the colors in the currently active cycle.
 
+        hatch : str or list of str, default: None
+            A hatch pattern or a list of hatch patterns. If a string, the same
+            pattern is used for all wedges. If a list, each wedge is assigned
+            the corresponding pattern, cycling through the list as needed.
+
         autopct : None or str or callable, default: None
             If not *None*, is a string or function used to label the wedges
             with their numeric value.  The label will be placed inside the
@@ -3208,9 +3212,18 @@ class Axes(_AxesBase):
                 return next(color_cycle)
 
         _api.check_isinstance(Number, radius=radius, startangle=startangle)
+        
+        if hatch is not None:
+            if isinstance(hatch, str):
+                hatch_cycle = itertools.cycle([hatch])
+            else:
+                hatch_cycle = itertools.cycle(hatch)
+                
+            def get_next_hatch():
+                return next(hatch_cycle)
+                
         if radius <= 0:
             raise ValueError(f'radius must be a positive number, not {radius}')
-
         # Starting theta1 is the start fraction of the circle
         theta1 = startangle / 360
 
@@ -3233,12 +3246,12 @@ class Axes(_AxesBase):
             w = mpatches.Wedge((x, y), radius, 360. * min(theta1, theta2),
                                360. * max(theta1, theta2),
                                facecolor=get_next_color(),
-                               clip_on=False,
-                               label=label)
+                               clip_on=False)
             w.set(**wedgeprops)
+            if hatch is not None:
+                w.set(hatch=get_next_hatch())
             slices.append(w)
             self.add_patch(w)
-
             if shadow:
                 # Make sure to add a shadow after the call to add_patch so the
                 # figure and transform props will be set.
diff --git a/lib/matplotlib/pyplot.py b/lib/matplotlib/pyplot.py
index bce5058..ff14644 100644
--- a/lib/matplotlib/pyplot.py
+++ b/lib/matplotlib/pyplot.py
@@ -2778,18 +2778,16 @@ def pie(
         x, explode=None, labels=None, colors=None, autopct=None,
         pctdistance=0.6, shadow=False, labeldistance=1.1,
         startangle=0, radius=1, counterclock=True, wedgeprops=None,
-        textprops=None, center=(0, 0), frame=False,
-        rotatelabels=False, *, normalize=True, data=None):
+        textprops=None, center=(0, 0), frame=False, rotatelabels=False,
+        *, hatch=None, normalize=True, data=None):
     return gca().pie(
         x, explode=explode, labels=labels, colors=colors,
         autopct=autopct, pctdistance=pctdistance, shadow=shadow,
         labeldistance=labeldistance, startangle=startangle,
         radius=radius, counterclock=counterclock,
         wedgeprops=wedgeprops, textprops=textprops, center=center,
-        frame=frame, rotatelabels=rotatelabels, normalize=normalize,
+        frame=frame, rotatelabels=rotatelabels, hatch=hatch, normalize=normalize,
         **({"data": data} if data is not None else {}))
-
-
 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
 @_copy_docstring_and_deprecators(Axes.plot)
 def plot(*args, scalex=True, scaley=True, data=None, **kwargs):
