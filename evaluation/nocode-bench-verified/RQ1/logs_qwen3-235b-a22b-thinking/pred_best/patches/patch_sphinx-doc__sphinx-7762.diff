diff --git a/sphinx/builders/linkcheck.py b/sphinx/builders/linkcheck.py
index 31d7f5b..9af91fc 100644
--- a/sphinx/builders/linkcheck.py
+++ b/sphinx/builders/linkcheck.py
@@ -91,30 +91,48 @@ class CheckExternalLinksBuilder(Builder):
         socket.setdefaulttimeout(5.0)
         # create output file
         open(path.join(self.outdir, 'output.txt'), 'w').close()
-        # create JSON output file
-        open(path.join(self.outdir, 'output.json'), 'w').close()
+        # create JSON output file (if not already created)
+        if not path.exists(path.join(self.outdir, 'output.json')):
+            open(path.join(self.outdir, 'output.json'), 'w').close()
 
         # create queues and worker threads
         self.wqueue = queue.Queue()  # type: queue.Queue
         self.rqueue = queue.Queue()  # type: queue.Queue
         self.workers = []  # type: List[threading.Thread]
         for i in range(self.app.config.linkcheck_workers):
-            thread = threading.Thread(target=self.check_thread)
+            thread = threading.Thread(target=self._check_thread)
             thread.setDaemon(True)
             thread.start()
             self.workers.append(thread)
 
-    def check_thread(self) -> None:
-        kwargs = {
+    def _check_thread(self) -> None:
+        base_kwargs = {
             'allow_redirects': True,
-            'headers': {
-                'Accept': 'text/html,application/xhtml+xml;q=0.9,*/*;q=0.8',
-            },
         }
         if self.app.config.linkcheck_timeout:
-            kwargs['timeout'] = self.app.config.linkcheck_timeout
+            base_kwargs['timeout'] = self.app.config.linkcheck_timeout
 
         def check_uri() -> Tuple[str, str, int]:
+            # Compute headers for this req_url
+            default_headers = {
+                'Accept': 'text/html,application/xhtml+xml;q=0.9,*/*;q=0.8',
+            }
+            config_headers = {}
+            headers_config = self.app.config.linkcheck_request_headers
+            if headers_config:
+                base = None
+                for key in headers_config:
+                    if key == '*':
+                        continue
+                    if req_url.startswith(key):
+                        if base is None or len(key) > len(base):
+                            base = key
+                if base is not None:
+                    config_headers = headers_config[base]
+                else:
+                    config_headers = headers_config.get('*', {})
+            headers = {**default_headers, **config_headers}
+
             # split off anchor
             if '#' in uri:
                 req_url, anchor = uri.split('#', 1)
@@ -142,8 +160,8 @@ class CheckExternalLinksBuilder(Builder):
             try:
                 if anchor and self.app.config.linkcheck_anchors:
                     # Read the whole document and see if #anchor exists
-                    response = requests.get(req_url, stream=True, config=self.app.config,
-                                            auth=auth_info, **kwargs)
+                    response = requests.get(req_url, stream=True,
+                                            auth=auth_info, headers=headers, **base_kwargs)
                     found = check_anchor(response, unquote(anchor))
 
                     if not found:
@@ -151,15 +169,14 @@ class CheckExternalLinksBuilder(Builder):
                 else:
                     try:
                         # try a HEAD request first, which should be easier on
-                        # the server and the network
-                        response = requests.head(req_url, config=self.app.config,
-                                                 auth=auth_info, **kwargs)
+                        response = requests.head(req_url, auth=auth_info,
+                                                 headers=headers, **base_kwargs)
                         response.raise_for_status()
                     except HTTPError:
                         # retry with GET request if that fails, some servers
                         # don't like HEAD requests.
-                        response = requests.get(req_url, stream=True, config=self.app.config,
-                                                auth=auth_info, **kwargs)
+                        response = requests.get(req_url, stream=True, auth=auth_info,
+                                                headers=headers, **base_kwargs)
                         response.raise_for_status()
             except HTTPError as err:
                 if err.response.status_code == 401:
@@ -228,7 +245,6 @@ class CheckExternalLinksBuilder(Builder):
 
     def process_result(self, result: Tuple[str, str, int, str, str, int]) -> None:
         uri, docname, lineno, status, info, code = result
-
         filename = self.env.doc2path(docname, None)
         linkstat = dict(filename=filename, lineno=lineno,
                         status=status, code=code, uri=uri,
@@ -289,7 +305,6 @@ class CheckExternalLinksBuilder(Builder):
         return
 
     def write_doc(self, docname: str, doctree: Node) -> None:
-        logger.info('')
         n = 0
 
         # reference nodes
@@ -312,6 +327,7 @@ class CheckExternalLinksBuilder(Builder):
         done = 0
         while done < n:
             self.process_result(self.rqueue.get())
+            logger.info('.')
             done += 1
 
         if self.broken:
@@ -331,6 +347,10 @@ class CheckExternalLinksBuilder(Builder):
         for worker in self.workers:
             self.wqueue.put((None, None, None), False)
 
+    def check_thread(self) -> None:
+        # Deprecated alias for _check_thread (to be removed in future versions)
+        self._check_thread()
+
 
 def setup(app: Sphinx) -> Dict[str, Any]:
     app.add_builder(CheckExternalLinksBuilder)
