diff --git a/requests/exceptions.py b/requests/exceptions.py
index dd3ff05..b0b91c1 100644
--- a/requests/exceptions.py
+++ b/requests/exceptions.py
@@ -28,6 +28,9 @@ class RequestException(IOError):
 class InvalidJSONError(RequestException):
     """A JSON error occurred."""
 
+class JSONDecodeError(InvalidJSONError):
+    """There was an error decoding JSON."""
+
 
 class HTTPError(RequestException):
     """An HTTP error occurred."""
diff --git a/requests/models.py b/requests/models.py
index 612041a..1b1bdb0 100644
--- a/requests/models.py
+++ b/requests/models.py
@@ -882,32 +882,36 @@ class Response(object):
         r"""Returns the json-encoded content of a response, if any.
 
         :param \*\*kwargs: Optional arguments that ``json.loads`` takes.
-        :raises simplejson.JSONDecodeError: If the response body does not
-            contain valid json and simplejson is installed.
-        :raises json.JSONDecodeError: If the response body does not contain
-            valid json and simplejson is not installed on Python 3.
-        :raises ValueError: If the response body does not contain valid
-            json and simplejson is not installed on Python 2.        
+        :raises requests.exceptions.JSONDecodeError: If the response body does not contain valid JSON.
         """
 
-        if not self.encoding and self.content and len(self.content) > 3:
-            # No encoding set. JSON RFC 4627 section 3 states we should expect
-            # UTF-8, -16 or -32. Detect which one to use; If the detection or
-            # decoding fails, fall back to `self.text` (using charset_normalizer to make
-            # a best guess).
-            encoding = guess_json_utf(self.content)
-            if encoding is not None:
-                try:
-                    return complexjson.loads(
-                        self.content.decode(encoding), **kwargs
-                    )
-                except UnicodeDecodeError:
-                    # Wrong UTF codec detected; usually because it's not UTF-8
-                    # but some other 8-bit codec.  This is an RFC violation,
-                    # and the server didn't bother to tell us what codec *was*
-                    # used.
-                    pass
-        return complexjson.loads(self.text, **kwargs)
+        # Determine the appropriate JSON decode error exception
+        try:
+            json_decode_error = complexjson.JSONDecodeError
+        except AttributeError:
+            json_decode_error = ValueError
+
+        try:
+            if not self.encoding and self.content and len(self.content) > 3:
+                # No encoding set. JSON RFC 4627 section 3 states we should expect
+                # UTF-8, -16 or -32. Detect which one to use; If the detection or
+                # decoding fails, fall back to `self.text` (using charset_normalizer to make
+                # a best guess).
+                encoding = guess_json_utf(self.content)
+                if encoding is not None:
+                    try:
+                        return complexjson.loads(
+                            self.content.decode(encoding), **kwargs
+                        )
+                    except UnicodeDecodeError:
+                        # Wrong UTF codec detected; usually because it's not UTF-8
+                        # but some other 8-bit codec.  This is an RFC violation,
+                        # and the server didn't bother to tell us what codec *was*
+                        # used.
+                        pass
+            return complexjson.loads(self.text, **kwargs)
+        except json_decode_error as e:
+            raise exceptions.JSONDecodeError(f"JSON decode error: {str(e)}", request=self.request, response=self)
 
     @property
     def links(self):
