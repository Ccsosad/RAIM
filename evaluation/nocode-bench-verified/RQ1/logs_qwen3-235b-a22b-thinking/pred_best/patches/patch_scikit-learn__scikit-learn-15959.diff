diff --git a/sklearn/multioutput.py b/sklearn/multioutput.py
index 50d6d32..3554757 100644
--- a/sklearn/multioutput.py
+++ b/sklearn/multioutput.py
@@ -60,6 +60,17 @@ def _partial_fit_estimator(estimator, X, y, classes=None, sample_weight=None,
     return estimator
 
 
+def _fit_estimator(estimator, X, y, sample_weight=None, **fit_params):
+    """Private function to fit an estimator per output variable for multi-output"""
+    estimator = clone(estimator)
+    params = {}
+    if sample_weight is not None:
+        params['sample_weight'] = sample_weight
+    params.update(fit_params)
+    estimator.fit(X, y, **params)
+    return estimator
+
+
 class _MultiOutputEstimator(BaseEstimator, MetaEstimatorMixin,
                             metaclass=ABCMeta):
     @abstractmethod
@@ -94,6 +105,9 @@ class _MultiOutputEstimator(BaseEstimator, MetaEstimatorMixin,
             Only supported if the underlying regressor supports sample
             weights.
 
+        **fit_params : dict of {str: object}, optional
+            Parameters to pass to the fit method of each step.
+
         Returns
         -------
         self : object
@@ -121,10 +135,9 @@ class _MultiOutputEstimator(BaseEstimator, MetaEstimatorMixin,
                 sample_weight, first_time) for i in range(y.shape[1]))
         return self
 
-    def fit(self, X, y, sample_weight=None):
+    def fit(self, X, y, sample_weight=None, **fit_params):
         """ Fit the model to data.
         Fit a separate model for each output variable.
-
         Parameters
         ----------
         X : (sparse) array-like, shape (n_samples, n_features)
@@ -139,6 +152,9 @@ class _MultiOutputEstimator(BaseEstimator, MetaEstimatorMixin,
             Only supported if the underlying regressor supports sample
             weights.
 
+        **fit_params : dict of {str: object}, optional
+            Parameters to pass to the fit method of each step.
+
         Returns
         -------
         self : object
@@ -165,11 +181,10 @@ class _MultiOutputEstimator(BaseEstimator, MetaEstimatorMixin,
                              " sample weights.")
 
         self.estimators_ = Parallel(n_jobs=self.n_jobs)(
-            delayed(_fit_estimator)(
-                self.estimator, X, y[:, i], sample_weight)
+            delayed(_fit_estimator)(self.estimator, X, y[:, i], 
+                                   sample_weight, **fit_params)
             for i in range(y.shape[1]))
         return self
-
     def predict(self, X):
         """Predict multi-output variable using a model
          trained for each target variable.
@@ -352,6 +367,9 @@ class MultiOutputClassifier(ClassifierMixin, _MultiOutputEstimator):
             Only supported if the underlying classifier supports sample
             weights.
 
+        **fit_params : dict of {str: object}, optional
+            Parameters to pass to the fit method of each step.
+
         Returns
         -------
         self : object
