diff --git a/seaborn/categorical.py b/seaborn/categorical.py
index 27d5801..c590e07 100644
--- a/seaborn/categorical.py
+++ b/seaborn/categorical.py
@@ -1370,7 +1370,6 @@ class _SwarmPlotter(_CategoricalScatterPlotter):
 
     def could_overlap(self, xy_i, swarm, d):
         """Return a list of all swarm points that could overlap with target.
-
         Assumes that swarm is a sorted list of all points below xy_i.
         """
         _, y_i = xy_i
@@ -1402,69 +1401,35 @@ class _SwarmPlotter(_CategoricalScatterPlotter):
 
     def first_non_overlapping_candidate(self, candidates, neighbors, d):
         """Remove candidates from the list if they overlap with the swarm."""
-
-        # IF we have no neighbours, all candidates are good.
         if len(neighbors) == 0:
             return candidates[0]
 
         neighbors_x = neighbors[:, 0]
         neighbors_y = neighbors[:, 1]
-
         d_square = d ** 2
 
         for xy_i in candidates:
             x_i, y_i = xy_i
-
             dx = neighbors_x - x_i
             dy = neighbors_y - y_i
-
             sq_distances = np.power(dx, 2.0) + np.power(dy, 2.0)
-
-            # good candidate does not overlap any of neighbors
-            # which means that squared distance between candidate
-            # and any of the neighbours has to be at least
-            # square of the diameter
             good_candidate = np.all(sq_distances >= d_square)
-
             if good_candidate:
                 return xy_i
 
-        # If `position_candidates` works well
-        # this should never happen
-        raise Exception('No non-overlapping candidates found. '
-                        'This should not happen.')
+        raise Exception('No non-overlapping candidates found. This should not happen.')
 
     def beeswarm(self, orig_xy, d):
         """Adjust x position of points to avoid overlaps."""
-        # In this method, ``x`` is always the categorical axis
-        # Center of the swarm, in point coordinates
         midline = orig_xy[0, 0]
-
-        # Start the swarm with the first point
         swarm = [orig_xy[0]]
-
-        # Loop over the remaining points
         for xy_i in orig_xy[1:]:
-
-            # Find the points in the swarm that could possibly
-            # overlap with the point we are currently placing
             neighbors = self.could_overlap(xy_i, swarm, d)
-
-            # Find positions that would be valid individually
-            # with respect to each of the swarm neighbors
             candidates = self.position_candidates(xy_i, neighbors, d)
-
-            # Sort candidates by their centrality
             offsets = np.abs(candidates[:, 0] - midline)
             candidates = candidates[np.argsort(offsets)]
-
-            # Find the first candidate that does not overlap any neighbours
-            new_xy_i = self.first_non_overlapping_candidate(candidates,
-                                                            neighbors, d)
-
-            # Place it into the swarm
+            new_xy_i = self.first_non_overlapping_candidate(candidates, neighbors, d)
             swarm.append(new_xy_i)
-
         return np.array(swarm)
 
     def add_gutters(self, points, center, width):
@@ -1481,48 +1446,11 @@ class _SwarmPlotter(_CategoricalScatterPlotter):
 
         gutter_prop = (off_high + off_low).sum() / len(points)
         if gutter_prop > .05:
-            msg = (
-                "{:.1%} of the points cannot be placed; you may want "
-                "to decrease the size of the markers or use stripplot."
-            ).format(gutter_prop)
+            msg = ("{:.1%} of the points cannot be placed; you may want "
+                   "to decrease the size of the markers or use stripplot.").format(gutter_prop)
             warnings.warn(msg, UserWarning)
-
         return points
 
-    def swarm_points(self, ax, points, center, width, s, **kws):
-        """Find new positions on the categorical axis for each point."""
-        # Convert from point size (area) to diameter
-        default_lw = mpl.rcParams["patch.linewidth"]
-        lw = kws.get("linewidth", kws.get("lw", default_lw))
-        dpi = ax.figure.dpi
-        d = (np.sqrt(s) + lw) * (dpi / 72)
-
-        # Transform the data coordinates to point coordinates.
-        # We'll figure out the swarm positions in the latter
-        # and then convert back to data coordinates and replot
-        orig_xy = ax.transData.transform(points.get_offsets())
-
-        # Order the variables so that x is the categorical axis
-        if self.orient == "h":
-            orig_xy = orig_xy[:, [1, 0]]
-
-        # Do the beeswarm in point coordinates
-        new_xy = self.beeswarm(orig_xy, d)
-
-        # Transform the point coordinates back to data coordinates
-        if self.orient == "h":
-            new_xy = new_xy[:, [1, 0]]
-        new_x, new_y = ax.transData.inverted().transform(new_xy).T
-
-        # Add gutters
-        if self.orient == "v":
-            self.add_gutters(new_x, center, width)
-        else:
-            self.add_gutters(new_y, center, width)
-
-        # Reposition the points so they do not overlap
-        points.set_offsets(np.c_[new_x, new_y])
-
     def draw_swarmplot(self, ax, kws):
         """Plot the data."""
         s = kws.pop("s")
@@ -1548,26 +1476,27 @@ class _SwarmPlotter(_CategoricalScatterPlotter):
                 if self.hue_names is None:
                     hue_mask = np.ones(group_data.size, bool)
                 else:
-                    hue_mask = np.array([h in self.hue_names
-                                         for h in self.plot_hues[i]], bool)
-                    # Broken on older numpys
-                    # hue_mask = np.in1d(self.plot_hues[i], self.hue_names)
+                    hue_mask = np.array([h in self.hue_names for h in self.plot_hues[i]], bool)
 
                 swarm_data = np.asarray(group_data[hue_mask])
                 point_colors = np.asarray(self.point_colors[i][hue_mask])
 
-                # Sort the points for the beeswarm algorithm
+                # Store original indices before sorting for swarm calculation
+                orig_indices = np.arange(len(swarm_data))
                 sorter = np.argsort(swarm_data)
                 swarm_data = swarm_data[sorter]
                 point_colors = point_colors[sorter]
+                orig_indices = orig_indices[sorter]
 
                 # Plot the points in centered positions
                 cat_pos = np.ones(swarm_data.size) * i
                 kws.update(c=palette[point_colors])
                 if self.orient == "v":
-                    points = ax.scatter(cat_pos, swarm_data, s=s, **kws)
+                    points = Beeswarm(cat_pos, swarm_data, s, i, self.width, self.orient, 
+                                     self, orig_indices, **kws)
                 else:
-                    points = ax.scatter(swarm_data, cat_pos, s=s, **kws)
+                    points = Beeswarm(swarm_data, cat_pos, s, i, self.width, self.orient, 
+                                     self, orig_indices, **kws)
 
                 centers.append(i)
                 swarms.append(points)
@@ -1581,32 +1510,30 @@ class _SwarmPlotter(_CategoricalScatterPlotter):
                     swarm_data = np.asarray(group_data[hue_mask])
                     point_colors = np.asarray(self.point_colors[i][hue_mask])
 
-                    # Sort the points for the beeswarm algorithm
+                    # Store original indices before sorting for swarm calculation
+                    orig_indices = np.arange(len(swarm_data))
                     sorter = np.argsort(swarm_data)
                     swarm_data = swarm_data[sorter]
                     point_colors = point_colors[sorter]
+                    orig_indices = orig_indices[sorter]
 
                     # Plot the points in centered positions
                     center = i + offsets[j]
                     cat_pos = np.ones(swarm_data.size) * center
                     kws.update(c=palette[point_colors])
                     if self.orient == "v":
-                        points = ax.scatter(cat_pos, swarm_data, s=s, **kws)
+                        points = Beeswarm(cat_pos, swarm_data, s, center, width, self.orient, 
+                                         self, orig_indices, **kws)
                     else:
-                        points = ax.scatter(swarm_data, cat_pos, s=s, **kws)
+                        points = Beeswarm(swarm_data, cat_pos, s, center, width, self.orient, 
+                                         self, orig_indices, **kws)
 
                     centers.append(center)
                     swarms.append(points)
 
-        # Autoscale the valus axis to set the data/axes transforms properly
+        # Autoscale the values axis to set the data/axes transforms properly
         ax.autoscale_view(scalex=self.orient == "h", scaley=self.orient == "v")
 
-        # Update the position of each point on the categorical axis
-        # Do this after plotting so that the numerical axis limits are correct
-        for center, swarm in zip(centers, swarms):
-            if swarm.get_offsets().size:
-                self.swarm_points(ax, swarm, center, width, s, **kws)
-
     def plot(self, ax, kws):
         """Make the full plot."""
         self.draw_swarmplot(ax, kws)
